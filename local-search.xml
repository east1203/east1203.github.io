<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>UVM比较细节的知识点</title>
    <link href="/3019/09/10/Verification/UVM/UVM%E4%B8%AD%E6%AF%94%E8%BE%83%E7%BB%86%E8%8A%82%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/3019/09/10/Verification/UVM/UVM%E4%B8%AD%E6%AF%94%E8%BE%83%E7%BB%86%E8%8A%82%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>在博客上不是很方便随时更新这种比较细节的知识点，所以我就采用有道云笔记来记录了，这里先只放置一个链接，后续如果积累到了一定的量，再分类整理成单独的博客。</p><p><a href="http://note.youdao.com/noteshare?id=79565dca1690fa1313c4719d829b4901&sub=BF5136E4DFC449F2A0E75618B3C0289B"><strong>UVM的细节知识</strong></a></p>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>UVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
      <tag>UVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM使用经验</title>
    <link href="/3019/08/25/Verification/UVM/UVM%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C/"/>
    <url>/3019/08/25/Verification/UVM/UVM%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="0-介绍"><a href="#0-介绍" class="headerlink" title="0. 介绍"></a>0. 介绍</h3><p>这篇积累一下UVM使用过程中遇到的一些问题、bug和经验。</p><h3 id="1-经验"><a href="#1-经验" class="headerlink" title="1. 经验"></a>1. 经验</h3><h4 id="1-1-phase相关"><a href="#1-1-phase相关" class="headerlink" title="1.1  phase相关"></a>1.1  phase相关</h4><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p><em><em>1.每个phase函数或者任务都要加上super.</em> * _phase(phase)</em>*</p><p>之前再看《UVM实战》的时候以为只有build_phase需要使用super，但是今天在使用callback机制的时候，connect_phase中没有用super.，出现了一些怪异的错误。</p><p>好吧，我刚才把connect_phase注释了，跑一下发现也没错，醉了，以后留意一下吧。</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p><strong>2. 如果两个component有端口连接，需要注意connect_phase，是否要seper.connect_phase(phase)</strong></p><p>今天遇到一个问题，我们知道uvm_driver中有个seq_item_port，在uvm_sequencer中有一个seq_item_export，今天我在写的时候，出现了一个错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">UVM_ERROR @ 0: uvm_test_top.env.i_agt.sqr.rsp_export [Connection Error] connection count of 0 does not meet required minimum of 1<br>UVM_FATAL @ 0: reporter [BUILDERR] stopping due to build errors<br></code></pre></td></tr></table></figure><p>​    查了一下，好像是跟connect_phase有关，也不太清楚，我就看代码，发现我的sequencer、driver、agent，他们的connect_phase中都没有用super.connect_phase。因为看张强的那本书说，用不用都一样，今天我就省略了。然后我就把他们的super.connect_phase都加上了，结果正确了。</p><p>​    然后我又逐个注释掉，看到底是哪一个在起作用，结果发现只有在我重载了sequencer的connect_phase，但是在其中没有写super.connect_phase，才会出错，其他任何情况都不会出现这个错误。最简单的避免错误的方法就是如果用不到这个phase，就不要写出来，不写就没错，如果写了那么还是把super给加上吧。</p><p>​    然后我又用自定义port、export、imp来测试了一下，我不用seq_item_port和seq_item_export，发现怎么写都没有错，怪哉啊。</p><p>​    <strong>所以一个不严谨的结论就是，sequencer的connect_phase要写super.connect_phase(phase)，否则就别写connect_phase函数。</strong></p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>​    2019–08-29</p><p>​    可配置的验证平台中，会通过uvm_config_db#(..)::set来设置一些控制参数，来看重验证平台组件的生成，比如uvm_agent中的is_active。</p><p>​    比如现在是在给agent设置is_active，那么我们希望agent能知道我们重新设置了这个变量，为<strong>了实现这个在UG中强烈建议加上super.build_phase（uvm UG 1.1 P44）</strong>，而且出现了好多次。当然用这个也是有前提的，这个算是config_db自动获取，我们需要：</p><div class="code-wrapper"><pre><code class="hljs">1. 将agent用factory宏注册。 2. 将agent中需要 自动获取的变量用filed automation。 3. config_db中set函数的第三个参数和agent中的变量名是一样的。</code></pre></div><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>​    2019–08-29</p><p>​    <strong>我们创建component要在build_phase中，比如我们在base_test中例化了env，并在base_test::build_phase中创建了它，那么在特定的case（继承自base_test）中，我们不必再例化env和创建它，只需要调用super.build_phase就可以了。</strong></p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>​    2019–08-29</p><p><strong>如果想要再case中向sequence中传递sequencer指针，那么uvm_config_db：：set要写在build_phase之后的connect_phase中。</strong></p><p>详细见这篇博客<a href="https://east1203.github.io/2019/08/27/Verification/UVM/UVM%E2%80%94%E2%80%94Fun%20with%20UVM%20Sequences%20-%20Coding%20and%20Debugging/">UVM——Fun with UVM Sequences - Coding and Debugging</a>中的<strong>有用-CONTROLLING OTHER SEQUENCES</strong>一节</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><h4 id="1-2-callback"><a href="#1-2-callback" class="headerlink" title="1.2 callback"></a>1.2 callback</h4><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p><strong>1.在使用回调的时候，自己定义的回调对象不能跟sequence在同一个phase。可以是sequence在build phase上启动，而callback object在connect phase中创建。</strong></p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><h4 id="1-3-运行仿真环境"><a href="#1-3-运行仿真环境" class="headerlink" title="1.3 运行仿真环境"></a>1.3 运行仿真环境</h4><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>我们知道，UVM中的factory机制可以实现通过字符串创建对象，从书上知道，在VCS仿真的时候我们可以通过用+UVM_TESTNAME选项来指定不同的case。</p><p>如果我们的sequence都编译好了，也就是说已经执行了vcs -sverilog  ….这条脚本，那么我们可以通过</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">./simv +UVM_TESTNAME=case1<br>./simv +UVM_TESTNAME=case2<br>./simv +UVM_TESTNAME=case3<br></code></pre></td></tr></table></figure><p>来执行不同的case。</p><p>但是如果我们的<strong>sequence</strong>被修改了，那么我们需要用vcs脚本重新编译一下，再用simv仿真，这样改变之后的效果才能呈现出来。</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><h4 id="1-4-config-db使用"><a href="#1-4-config-db使用" class="headerlink" title="1.4 config_db使用"></a>1.4 config_db使用</h4><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>在top module中，要通过config_db来设置虚接口，然后运行run_test()例化test case，在这里有个顺序问题，需要先config_db，再run_test()</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    uvm_config_db<span class="hljs-variable">#(virtual wd_bfm)::set(null,&quot;*&quot;,&quot;bfm&quot;,bfm)</span>;<br>run_test();<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>要不然报错：driver得不到接口</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">UVM_FATAL comp/driver<span class="hljs-selector-class">.sv</span>(<span class="hljs-number">15</span>) @ <span class="hljs-number">0</span>: uvm_test_top<span class="hljs-selector-class">.env</span><span class="hljs-selector-class">.i_agt</span><span class="hljs-selector-class">.drv</span> <span class="hljs-selector-attr">[driver]</span> Failed get bfm!!!<br></code></pre></td></tr></table></figure><p><strong>可以猜测，uvm_config_db机制可能只是向一个表中记录设置参数的路径信息，当你创建对象的时候，你先要访问这个表，看有没有给对象设置了信息，如果先创建了对象，在对象的build_phase中get参数，就会发生get不到的情况，所以需要先set，然后再创建对象。</strong></p><p><strong>但是如果是在组件中使用的话，先创建对象还是先config_db都可以</strong>，比如：</p><p>在environment中创建i_agt，需要设置is_active变量。下面这两种方法都能run。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> enviroment::build_phase(uvm_phase phase);<br>  i_agt=agent::type_id::create(<span class="hljs-string">&quot;i_agt&quot;</span>,<span class="hljs-keyword">this</span>);<br>  uvm_config_db<span class="hljs-variable">#(uvm_active_passive_enum)::set(this,&quot;i_agt&quot;,&quot;is_active&quot;,UVM_ACTIVE)</span>;<br><span class="hljs-comment">//  i_agt.is_active = UVM_ACTIVE;</span><br><span class="hljs-keyword">endfunction</span><br></code></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> enviroment::build_phase(uvm_phase phase);<br>  uvm_config_db<span class="hljs-variable">#(uvm_active_passive_enum)::set(this,&quot;i_agt&quot;,&quot;is_active&quot;,UVM_ACTIVE)</span>;<br>    i_agt=agent::type_id::create(<span class="hljs-string">&quot;i_agt&quot;</span>,<span class="hljs-keyword">this</span>);<br><span class="hljs-comment">//  i_agt.is_active = UVM_ACTIVE;</span><br><span class="hljs-keyword">endfunction</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>config_db如果配置的对象是个参数类，那么可以将类的参数写出来，也可以不写出来，都能配置对，只要你set和get同步就行，别一个写了参数，一个没写，比如我要传递 sequencer#(transaction)到virtual sequence中。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">uvm_config_db(sequencer<span class="hljs-variable">#(transaction))::set(null,&quot;*&quot;,&quot;sqr&quot;,env.sqr)</span>;<br></code></pre></td></tr></table></figure><p>get的时候也一样，要加参数</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">uvm_config_db<span class="hljs-variable">#(sequencer#(transaction)):get(null,get_full_name(),&quot;sqr&quot;,get_sqr)</span>;<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p><strong>上面介绍的传递sequencer，有一点要注意，比如我实在test case中set，那么set函数一定不要写在build_phase中，可以写在connect_phase，否则传递失败，但编译器却不会报错，不过但你要用sequencer来启动sequence的时候，又会告诉你说sequencer没有实例化。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">case</span>::connect_phase(uvm_phase phase);<br><span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);<br>uvm_config_db<span class="hljs-variable">#(sequencer#(transaction)):get(null,get_full_name(),&quot;sqr&quot;,get_sqr)</span>;<br><span class="hljs-keyword">endfunction</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>在路径索引中使用的路径，比如一个i_agt，这个其实是i_agt对象在创建时候的名字，比如</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">i_agt = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;i_agt&quot;</span>,<span class="hljs-keyword">this</span>);<br></code></pre></td></tr></table></figure><p>名字是new中引号内的字符串，而不是开头的i_agt，当然，这里他们是相同的。</p><p>我们可以写成：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">uvm_config_db<span class="hljs-variable">#(transaction)::set(this,&#123;i_agt.get_name(),&quot;.&quot;,&quot;mon&quot;&#125;,&quot;tr&quot;,tr)</span>;<br></code></pre></td></tr></table></figure><h4 id="1-5-任务和函数"><a href="#1-5-任务和函数" class="headerlink" title="1.5 任务和函数"></a>1.5 任务和函数</h4><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p> 任务中的变量一定要先定义，然后才能进行接下来的操作。</p><p><strong>在phase方法中调用super之前一定要先把变量都声明好了。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> write();<br>  `uvm_info(get_type_name(),<span class="hljs-string">&quot;write&quot;</span>,UVM_LOW);<br>    transaction tr;<br>  `uvm_do(tr);<br><span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><p>上面那种写法会说 transaction tr;语句出错，应该把变量的定义写在开头。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> write();<br>    transaction tr;<br>  `uvm_info(get_type_name(),<span class="hljs-string">&quot;write&quot;</span>,UVM_LOW);<br>  `uvm_do(tr);<br><span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><h4 id="1-6-程序块"><a href="#1-6-程序块" class="headerlink" title="1.6 程序块"></a>1.6 程序块</h4><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>在写if else语句的时候，如果写成下面这样会报错，</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">if</span>(req==<span class="hljs-literal">null</span>)<br>      `uvm_info(get_type_name(),<span class="hljs-string">&quot;idle transaction&quot;</span>,UVM_LOW);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      `uvm_info(get_type_name(),<span class="hljs-string">&quot;driver get one tr&quot;</span>,UVM_LOW);<br>      rsp=<span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;rsp&quot;</span>);<br>      rsp<span class="hljs-variable">.set_id_info</span>(req);<br>      seq_item_port<span class="hljs-variable">.item_done</span>(rsp);<br>    <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>if也要加上 begin end</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">if</span>(req==<span class="hljs-literal">null</span>) <span class="hljs-keyword">begin</span><br>      `uvm_info(get_type_name(),<span class="hljs-string">&quot;idle transaction&quot;</span>,UVM_LOW);<br>      <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      `uvm_info(get_type_name(),<span class="hljs-string">&quot;driver get one tr&quot;</span>,UVM_LOW);<br>      rsp=<span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;rsp&quot;</span>);<br>      rsp<span class="hljs-variable">.set_id_info</span>(req);<br>      seq_item_port<span class="hljs-variable">.item_done</span>(rsp);<br>    <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>但是如果单独写if没有else，那么不需要加begin end（if后只有一条语句的时候）</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><h4 id="1-7-端口-port-export-imp-analysis-fifo"><a href="#1-7-端口-port-export-imp-analysis-fifo" class="headerlink" title="1.7 端口 port export imp analysis fifo"></a>1.7 端口 port export imp analysis fifo</h4><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p><strong>看UVM UG里面，端口的new写在build phase 里。</strong></p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><h4 id="1-8-tb上的组件"><a href="#1-8-tb上的组件" class="headerlink" title="1.8 tb上的组件"></a>1.8 tb上的组件</h4><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>UG中建议不要再new中创建组件（UG1.1 P62），它说在面向对象的编程中new函数在重载的时候有一些限制，所以，<strong>应该用build_phase来代替，在其中创建验证平台组件。</strong></p><p>比如说，我们在base_test中例化了env，并在base_test::build_phase中创建了它，那么在特定的case（继承自base_test）中，我们不必再例化env和创建它，只需要调用super.build_phase就可以了。****</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><h4 id="1-9-接口"><a href="#1-9-接口" class="headerlink" title="1.9 接口"></a>1.9 接口</h4><p>虚接口将硬件接口和SV仿真环境链接在一起，在顶层通过uvm_config_db机制传递。</p><p>之前都是用通配符*来传递，但是如果要传递多个接口那么可能会出现比必要的问题，在UG上看到一个写法：将虚接口传递给agent，然后在agent中通过uvm_config_db 得到虚接口，如果driver或者monitor中需要这个虚接口，可以通过如下方式：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// driver.sv</span><br>apb_vif sigs;<br>apb_agent agent;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">$cast</span>(agent, get_parent()) &amp;&amp; agent != <span class="hljs-literal">null</span>) <span class="hljs-keyword">begin</span> <span class="hljs-comment">// 从agent上拿到接口</span><br>sigs = agent<span class="hljs-variable">.vif</span>;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-comment">// 或者agent没有配置虚接口，那么在顶层直接设置到driver中</span><br>    <span class="hljs-keyword">if</span> (!uvm_config_db<span class="hljs-variable">#(apb_vif)::get(this, &quot;&quot;, &quot;vif&quot;, sigs))</span> <span class="hljs-keyword">begin</span><br>        `uvm_fatal(<span class="hljs-string">&quot;APB/DRV/NOVIF&quot;</span>, <span class="hljs-string">&quot;No virtual interface specified for this driver instance&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="1-10-一些函数"><a href="#1-10-一些函数" class="headerlink" title="1.10 一些函数"></a>1.10 一些函数</h4><p>$root，在SV1800中的介绍：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">Top-level modules are modules that are included in the SystemVerilog source text, but do<span class="hljs-built_in"> not </span>appear in any module instantiation statement.<br>The name $root is used to unambiguously refer to a top-level<span class="hljs-built_in"> instance </span>or to an<span class="hljs-built_in"> instance </span>path starting from the root of the instantiation tree. $root is the root of the instantiation tree.<br></code></pre></td></tr></table></figure><p>$root是在top module上面的实例，算是实例树种的根，类似于UVM中的uvm_top这个实例。</p><p>我们可以这样访问：$root.top.inst_A。这样就可以访问到top中的实例inst_A。</p><h3 id="2-问题"><a href="#2-问题" class="headerlink" title="2. 问题"></a>2. 问题</h3><h4 id="2-1-仿真时候卡主了"><a href="#2-1-仿真时候卡主了" class="headerlink" title="2.1 仿真时候卡主了"></a>2.1 仿真时候卡主了</h4><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>运行 .&#x2F;simv +UVM_TESTNAME&#x3D;case0 -l sim.log 卡在下面的界面</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><br>  ***********       IMPORTANT RELEASE NOTES         ************<br><br>  You are <span class="hljs-keyword">using</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">version</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> UVM library that has been compiled<br>  <span class="hljs-keyword">with</span> `UVM_NO_DEPRECATED undefined.<br>  See <span class="hljs-keyword">http</span>://www.eda.org/svdb/view.php?id=<span class="hljs-number">3313</span> <span class="hljs-keyword">for</span> more details.<br><br>  You are <span class="hljs-keyword">using</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">version</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> UVM library that has been compiled<br>  <span class="hljs-keyword">with</span> `UVM_OBJECT_MUST_HAVE_CONSTRUCTOR undefined.<br>  See <span class="hljs-keyword">http</span>://www.eda.org/svdb/view.php?id=<span class="hljs-number">3770</span> <span class="hljs-keyword">for</span> more details.<br><br>      (Specify +UVM_NO_RELNOTES <span class="hljs-built_in">to</span> turn off this notice)<br><br>VCD+ Writer I<span class="hljs-number">-2014.03</span> Copyright (c) <span class="hljs-number">1991</span><span class="hljs-number">-2014</span> <span class="hljs-keyword">by</span> Synopsys Inc.<br></code></pre></td></tr></table></figure><p>应该是忘了在top module中运行run_test</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    uvm_config_db<span class="hljs-variable">#(virtual wd_bfm)::set(null,&quot;*&quot;,&quot;bfm&quot;,bfm)</span>;<br>run_test();<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><h4 id="2-2-模块定义"><a href="#2-2-模块定义" class="headerlink" title="2.2 模块定义"></a>2.2 模块定义</h4><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>uvm_driver uvm_sequence uvm_sequencer是参数化的类，可以加上要传递什么类型的transaction，但是uvm_monitor不可以。</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>有的时候说找不到class定义，</p><p>这说明&#96;include的顺序不对，先用到的要先include，但也可以通过typedef来解决，在那些报错的类所在的文件夹中：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">class</span> classname;<br></code></pre></td></tr></table></figure><p>表明这个类在下文是有定义的。</p><h4 id="2-3-驱动接口编写"><a href="#2-3-驱动接口编写" class="headerlink" title="2.3 驱动接口编写"></a>2.3 驱动接口编写</h4><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><h5 id="driver中在何时驱动接口，接口信号才能在时钟被采样到"><a href="#driver中在何时驱动接口，接口信号才能在时钟被采样到" class="headerlink" title="driver中在何时驱动接口，接口信号才能在时钟被采样到"></a>driver中在何时驱动接口，接口信号才能在时钟被采样到</h5><p>这个好像是跟SV的仿真原理和EDA仿真工具都有关系。</p><p>我今天的错误情况：</p><p>​        TB驱动接口信号在时钟沿改变，DUT采样不到；</p><p>改变后的正确情况：</p><p>​        TB驱动接口信号提前半个周期，在下降沿改变，DUT采样到。</p><p><strong>所以应该在时钟下降沿使数据有效，等待DUT执行结束后，在上升沿使数据无效。</strong></p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><h4 id="2-4-ifdef-endif"><a href="#2-4-ifdef-endif" class="headerlink" title="2.4 `ifdef  `endif"></a>2.4 `ifdef  `endif</h4><p>Error-[IWNMEE] <code>ifdef or </code>ifndef with no matching<br>pkg.sv, 3<br>  <code>ifdef or </code>ifndef has no matching <code>else or </code>elsif or &#96;endif.<br>  Check that the directives are balanced.</p>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>UVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
      <tag>UVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MESI和MOESI Cache一致性协议</title>
    <link href="/2022/03/19/IC/Cache/MESI%E5%92%8CMOESI%20Cache%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/03/19/IC/Cache/MESI%E5%92%8CMOESI%20Cache%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="Cache简介"><a href="#Cache简介" class="headerlink" title="Cache简介"></a>Cache简介</h2><p>Cache是处理器结构中重要的组成部分，特别是现代处理器基本上都是采用冯诺依曼架构中存储程序的概念，CPU需要先从存储器中取到对应的指令和数据之后，才能执行指令。但是从存储器（一般是DDR）中取数据这个操作相对于CPU的工作频率来说，延迟很大。这时候cache的作用就体现出来了，cache在数据通路上位于存储器和CPU之间，数据和指令先从DDR中取出来，缓存到cache中，CPU再从cache中取。因为cache靠近CPU摆放，并且cache一般都是SRAM结构，访问速度快，所以CPU访问cache相比访问存储器，快很多。</p><p>现代处理器中，一般是多级cache结构，并且第一级cache是每个CPU核私有的，为了区分指令和数据，第一级cache又分成指令cache和数据cache，指令cache专门存放指令，数据cache存放指令执行需要的数据。第二级cache可能是私有的，也可能是多个core共享的。当然也可以设计三级cache。</p><p>对于每个CPU的私有cache来说，可能存储器中的某段数据，在多个CPU cache中都有备份，当存在这种情况的时候，要保证每一个CPU拿到的数据备份是存储器中最新的数据。如果一个CPU修改了共享数据，其他CPU要知道。<strong>这就是cache一致性。</strong></p><h2 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h2><p>MESI协议是处理多个CPU之间cache一致性常用的协议，该协议中有四个状态位来描述每一个cache行：</p><ol><li>M（modified）位。M位为1表示当前cache有效，<strong>当前cache行中的数据跟处理其中的不一样</strong>，并且只有当前cache保存这个cache行数据，其他cache没有该副本。当对这个cache进行替换的时候，不要现将cache行中的数据协会到存储器中。</li><li>E（exclusive）位。E位为1表示当前cache行有效，只在该cache中有副本，其他cache中没有该cache行副本。<strong>该cache行内容跟存储器中的一样。</strong></li><li>S（shared）位。S位为1表示当前cache行有效，<strong>cache行内容跟存储器一样</strong>，但有两个或者两个以上的cache有该cache行副本。</li><li>I（invalid）位。I位为1表示当前cache行没有有效数据，或者cache行没有使能。</li></ol><h2 id="MOESI协议"><a href="#MOESI协议" class="headerlink" title="MOESI协议"></a>MOESI协议</h2><p>MOESI协议引入O（owned）位，并且S位的含义跟MESI协议不一样：</p><ol><li>O（owned）位。当存在O位为1 的cache行的时候，<strong>该cache行数据一定在多个cache有副本，并且cache行中的内容跟存储器的内容不一样，各个cache行副本中的内容是一样的。</strong></li><li>S（shared）位，S位为1表示该cache行在多个cache中存在副本，但是cache行内容是否跟存储器内容一样要视情况而定，如果该cache行存在O位为1的副本，那么cache行内容跟存储器内容不同，如果不存在O位为1的副本，cache行内容跟存储器内容一致。</li></ol><h3 id="MOESI状态图"><a href="#MOESI状态图" class="headerlink" title="MOESI状态图"></a>MOESI状态图</h3><p>MOESI状态图如下所示，这两个图的内容是一样的，一个是我自己画的，一个是拍的书上的。</p><p>Read&#x2F;Write : CPU向自己的cache发起读写操作</p><p>Probe Read：cache收到其他CPU的读数据请求，读数据是为了读操作。</p><p>Probe  Write：cache收到其他CPU的读数据请求，读数据是为了写操作。都是读数据请求。</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/ic/cache/cache-moesi2.jpg" alt="自己画的MOESI状态图"></p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/ic/cache/cache-moesi.jpg" alt="书里面MOESI状态图"></p><h3 id="MOESI协议，存储器写，cache命中"><a href="#MOESI协议，存储器写，cache命中" class="headerlink" title="MOESI协议，存储器写，cache命中"></a>MOESI协议，存储器写，cache命中</h3><p>写命中的时候，cache行的状态可能是M, O, E, S四种：</p><ul><li>为M和E时候，直接将数据写入cache行，cache行的状态变为M。</li><li>为S时候，直接将数据写入cache行，cache行状态改为M，并且其他cache中保存该副本的cache行，从S或O改为I。</li><li>为O时候，直接将数据写入cache行，cache行状态改为M，并且其他cache中保存该副本的cache行，从S改为I。</li></ul><h3 id="MOESI协议，存储写，cache未命中"><a href="#MOESI协议，存储写，cache未命中" class="headerlink" title="MOESI协议，存储写，cache未命中"></a>MOESI协议，存储写，cache未命中</h3><p>如果CPU A对存储器的写操作没有在本地cache中命中，而是在其他CPU，比如CPU B中命中，那么CPU B 中该cache行的状态可能是M, O, E, S四种：</p><ul><li><p>当为M时候，CPU B将cache 行数据写会存储器，当且将cache行状态改为I，CPU A从存储器中取数据，并在本地cache申请一个cache行保存数据，cache行状态为M。</p></li><li><p>当为O时候，CPU B将将cache 行数据写回存储器，当且将该cache行和其他保存该副本的cache行状态改为I，CPU A从存储器中取数据，并在本地cache申请一个cache行保存数据，cache行状态为M。</p></li><li><p>当为E时候，CPU B中cache行状态改为I，CPU A从存储器中取数据，并在本地cache申请一个cache行保存数据，cache行状态为M。</p></li><li><p>当为S时候，将CPU B中该cache行和其他cache中保存该副本的cache行状态改为I，CPU A从存储器中取数据，保存在本地cache行中，状态为M。</p></li></ul><h3 id="MOESI协议，存储器读，cache命中"><a href="#MOESI协议，存储器读，cache命中" class="headerlink" title="MOESI协议，存储器读，cache命中"></a>MOESI协议，存储器读，cache命中</h3><p>如果CPU在本地cache中命中，那么直接从本地cache中读取。</p><h3 id="MOESI协议，存储器读，cache未命中"><a href="#MOESI协议，存储器读，cache未命中" class="headerlink" title="MOESI协议，存储器读，cache未命中"></a>MOESI协议，存储器读，cache未命中</h3><p>如果CPU A没有在本地cache中命中，而是在CPU B cache中命中，CPU B cache行状态可以是M, O, E, S：</p><ul><li>为M时候，CPU B cache行状态改为O，CPU B将数据传给CPU A新申请的cache行中。<strong>CPU B不需要将数据写会存储器。这是MOESI比MESI最大的优点，提高了cache利用率。</strong></li><li>为O时候，CPU B cache状态不变，CPU B将数据传给CPU A新申请的cache行中。</li><li>为E时候，CPU B cache行状态变为S，CPU B将数据传给CPU A新申请的cache行中。</li><li>为S时候，CPU B cache状态不变，CPU B将数据传给CPU A新申请的cache行中。</li></ul><h3 id="MOESI协议优点"><a href="#MOESI协议优点" class="headerlink" title="MOESI协议优点"></a>MOESI协议优点</h3><p>MOESI协议相比于MESI协议的优点是，当在其他CPU cache中发生Read hit时候，不需要将数据写回存储器，而是将数据从一个CPU直接传到另一个CPU，提高了cache利用率。</p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>Cache</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Memory BISR build-in self-repair</title>
    <link href="/2022/03/18/IC/power/Memory%20BISR/"/>
    <url>/2022/03/18/IC/power/Memory%20BISR/</url>
    
    <content type="html"><![CDATA[<p>S</p><h2 id="BISR简介"><a href="#BISR简介" class="headerlink" title="BISR简介"></a>BISR简介</h2><p>BISR是build-in self-test，是存储器内建的自测，可以在存储器的生命周期中任何时间进行测试与修复。很久之前，在BISR出现之前，使用外部的仪器，在memory出厂之前对memory进行测试。</p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>Power</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Power</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PMIC芯片介绍</title>
    <link href="/2022/03/17/IC/power/PMIC/"/>
    <url>/2022/03/17/IC/power/PMIC/</url>
    
    <content type="html"><![CDATA[<h2 id="PMIC-Power-management-IC，电源管理芯片"><a href="#PMIC-Power-management-IC，电源管理芯片" class="headerlink" title="PMIC(Power management IC，电源管理芯片)"></a>PMIC(Power management IC，电源管理芯片)</h2><p>电源管理IC (PMIC)是在单片芯片内包括了多种电源轨(power rail) 和电源管理功能的集成电路，具有可配置性、可编程性、高集成度和高效率的特点；精确的上下电时序、低压差、同步升降压可确保优化功耗。</p><p>PMIC常用于为小尺寸、电池供电设备供电，因为将多种功能集成到单片芯片内可提供更高的空间利用率和系统电源效率。PMIC内集成的常见功能包括电压转换器和调节器、电池充电器、电池电量计、LED驱动器、实时时钟、电源排序器和电源控制。</p><p>低功耗PMIC提供可穿戴设备、耳戴式设备、传感器和IoT设备等空间受限应用所需的高效率和小尺寸。高性能PMIC最大程度提高每瓦功率的利用率，同时提高系统性能，非常适合于计算密集型平台，例如片上系统(SoC)、FPGA和应用处理器。</p><h2 id="PMIC-作用"><a href="#PMIC-作用" class="headerlink" title="PMIC 作用"></a>PMIC 作用</h2><ol><li>用作电压降压，升压或降压&#x2F;升压转换器</li><li>确保提供稳压电流</li><li>管理主电池（非可充电电池）和二次电池（可充电电池）的放电以及二次电池的充电</li><li>管理当电池供电时，直流导轨输出，并在电池充电时这样做（如果适用）</li><li>确保正确完成多个导轨之间的上升&#x2F;下降时序和顺序</li><li>防止电源子系统或电池状况和故障（内部<a href="http://www.hqpcb.com/">短路</a>，完全放电或不存在）造成系统范围的损坏，反之亦然</li></ol><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ol><li><a href="https://www.maximintegrated.com/cn/products/power/power-management-ics.html#popupmodal">电源管理IC (PMIC) | Maxim Integrated</a></li><li><a href="http://www.elecfans.com/d/853037.html">PMIC的作用与面临了哪些挑战-电子发烧友网 (elecfans.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>Power</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Power</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023年地平线校招社招实习内推</title>
    <link href="/2022/03/16/others/2023%E5%B9%B4%E5%9C%B0%E5%B9%B3%E7%BA%BF%E6%A0%A1%E6%8B%9B%E7%A4%BE%E6%8B%9B%E5%AE%9E%E4%B9%A0%E5%86%85%E6%8E%A8/"/>
    <url>/2022/03/16/others/2023%E5%B9%B4%E5%9C%B0%E5%B9%B3%E7%BA%BF%E6%A0%A1%E6%8B%9B%E7%A4%BE%E6%8B%9B%E5%AE%9E%E4%B9%A0%E5%86%85%E6%8E%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="2022年、2023年地平线社招、校招、实习内推"><a href="#2022年、2023年地平线社招、校招、实习内推" class="headerlink" title="2022年、2023年地平线社招、校招、实习内推"></a>2022年、2023年地平线社招、校招、实习内推</h2><p>大量芯片、算法、软件、质量、功能安全的岗位等你来，社招校招实习都可以。</p><p>基于创新的人工智能专用计算架构BPU(Brain Processing Unit) ，地平线为自研 AI 芯片规划了完备的研发路线图。2017年，地平线即推出了中国首款边缘人工智能芯片；2019年，地平线又先后推出中国首款车规级 AI 芯片——征程2、新一代 AIoT 智能应用加速引擎——旭日2。2020年，地平线进一步加速AI芯片迭代，推出新一代高效能车规级AI芯片征程3和全新一代 AIoT 边缘 AI 芯片平台旭日3。</p><p>地平线于2021年7月推出业界第一款集成自动驾驶和智能交互于一体的全场景整车智能中央计算芯片——征程5，单芯片AI算力达128 TOPS。随着征程 5的推出，地平线成为业界唯一能够提供覆盖从L2到L4全场景整车智能芯片方案的边缘人工智能平台型企业。</p><h2 id="内推码-jwhymm"><a href="#内推码-jwhymm" class="headerlink" title="内推码  jwhymm"></a>内推码  jwhymm</h2><p><strong>添加内推码，增加简历筛选通过率</strong></p><h2 id="简历投递"><a href="#简历投递" class="headerlink" title="简历投递"></a>简历投递</h2><ol><li>关注【地平线招聘】微信公众号，进行投递。</li><li>去地平线官网  <a href="https://horizon.hotjob.cn/">地平线招聘官网 (hotjob.cn)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>others</category>
      
    </categories>
    
    
    <tags>
      
      <tag>others</tag>
      
      <tag>life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git错误及解决</title>
    <link href="/2022/03/13/tools/git/git%E9%94%99%E8%AF%AF%E5%8F%8A%E8%A7%A3%E5%86%B3/"/>
    <url>/2022/03/13/tools/git/git%E9%94%99%E8%AF%AF%E5%8F%8A%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="…-but-github-does-not-provide-shell-access"><a href="#…-but-github-does-not-provide-shell-access" class="headerlink" title="… but github does not provide shell access"></a>… but github does not provide shell access</h2><p>Solution：</p><p>Try and redefine the ssh url for remote origin:</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">git</span> <span class="hljs-string">remote</span> <span class="hljs-built_in">set-url</span> <span class="hljs-string">origin</span> <span class="hljs-string">git</span>@<span class="hljs-string">github</span>.<span class="hljs-string">com:lut/</span><span class="hljs-string">EvolutionApp</span>.<span class="hljs-string">git</span><br></code></pre></td></tr></table></figure><p>Only <a href="https://git-scm.com/docs/git-remote#Documentation/git-remote.txt-emset-urlem"><code>git remote set-url</code></a> can change an existing remote URL (as opposed to <a href="https://git-scm.com/docs/git-remote#Documentation/git-remote.txt-emaddem"><code>git remote add</code></a>, to <em>add</em> a <em>new</em> remote name and URL)<br>Here, is issue was the URL of the existing origin: <code>EvolutionApp</code>: it needed to be replaced by a valid one.</p><p>reference：<a href="https://stackoverflow.com/questions/26953071/github-authentication-failed-github-does-not-provide-shell-access">git - Github Authentication Failed - … GitHub does not provide shell access - Stack Overflow</a></p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git命令缩写</title>
    <link href="/2022/03/12/tools/git/git%E5%91%BD%E4%BB%A4%E7%BC%A9%E5%86%99/"/>
    <url>/2022/03/12/tools/git/git%E5%91%BD%E4%BB%A4%E7%BC%A9%E5%86%99/</url>
    
    <content type="html"><![CDATA[<p>git命令缩写形式，比如git status  -&gt; git st，git commit -&gt; git ci等等。</p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog">git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> <span class="hljs-keyword">alias</span><span class="hljs-variable">.co</span> checkout  <br>git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> <span class="hljs-keyword">alias</span><span class="hljs-variable">.br</span> branch  <br>git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> <span class="hljs-keyword">alias</span><span class="hljs-variable">.ci</span> commit  <br>git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> <span class="hljs-keyword">alias</span><span class="hljs-variable">.st</span> status<br></code></pre></td></tr></table></figure><p>执行上面几行语句之后，会在 ~&#x2F;.gitconfig中生成：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[alias]</span><br><span class="hljs-attr">co</span> = checkout<br><span class="hljs-attr">br</span> = branch<br><span class="hljs-attr">ci</span> = commit<br><span class="hljs-attr">st</span> = status<br></code></pre></td></tr></table></figure><p>当然也可以直接编辑~&#x2F;.gitconfig文件</p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>verdi-play选项加载settings</title>
    <link href="/2022/03/12/tools/verdi/verdi-play%E9%80%89%E9%A1%B9%E5%8A%A0%E8%BD%BDsettings/"/>
    <url>/2022/03/12/tools/verdi/verdi-play%E9%80%89%E9%A1%B9%E5%8A%A0%E8%BD%BDsettings/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>打开Verdi GUI之后，我们可以对verdi进行一些自己喜欢的设置，字体颜色什么的，但是<strong>在其他目录下打开其他波形</strong>，这些设置就没有了。</p><h2 id="command-replay-file-x2F-play-option"><a href="#command-replay-file-x2F-play-option" class="headerlink" title="command replay file&#x2F;  -play option"></a>command replay file&#x2F;  -play option</h2><p>在Verdi GUI中，我们进行的操作都会在verdi控制台<strong>（Tools-&gt;Preferences-&gt;General-&gt;Enable TCL Command Entry）</strong>中打印出来，比如点击了什么按钮，拖动了信号，字体设置等，基本上鼠标能进行的任何操作，都会在verdi控制台有对应的命令打印出来。</p><p>如果我们可以直接加载这些命令，那么就可以复现这些操作。</p><p>在SNPS文档<strong>《Verdi® and Siloti® Tcl Reference》</strong>中“<strong>How to Create and Use a Command Replay</strong> <strong>File</strong>”一节中介绍了在打开Verdi的时候，用-play选项加载command file。</p><p>这个command file以.cmd结尾，里面的内容就是在verdi 控制台中打印出来的内容。</p><figure class="highlight mel"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs mel"><span class="hljs-comment">// 打开Verdi的时候加载.cmd文件</span><br>verdi -<span class="hljs-keyword">play</span>  <span class="hljs-keyword">file</span>.cmd<br></code></pre></td></tr></table></figure><h3 id="介绍几个command"><a href="#介绍几个command" class="headerlink" title="介绍几个command"></a>介绍几个command</h3><h4 id="1-import-design"><a href="#1-import-design" class="headerlink" title="1. import design"></a>1. import design</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">debImport -f <span class="hljs-built_in">run</span>.f<br>或者<br>debImport <span class="hljs-string">&quot;-dbdir&quot;</span>   simv.daidir<br></code></pre></td></tr></table></figure><h4 id="2-打开波形"><a href="#2-打开波形" class="headerlink" title="2. 打开波形"></a>2. 打开波形</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#wave</span><br><span class="hljs-comment">#打开波形窗口</span><br><span class="hljs-built_in">set</span> wave1 [wvCreateWindow]  <br><span class="hljs-comment">#打开一个fsdb波形文件</span><br>wvOpenFile -win <span class="hljs-variable">$wave1</span> verilog.fsdb<br></code></pre></td></tr></table></figure><h4 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h4><p>其他的 命令都可以在Verdi GUI界面进行设置，再把Verdi控制台中的命令复制出来就行了。</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/tools/eda/verdi/verdi_console.png"></p><h2 id="也可以用-rc文件来保存设置"><a href="#也可以用-rc文件来保存设置" class="headerlink" title="也可以用.rc文件来保存设置"></a>也可以用.rc文件来保存设置</h2><p>当然如果再原来的目录下打开Verdi，会看到之前的设置还会在，这是因为打开Verdi的目录下面生成novas.rc文件，我们的一些配置什么的都会保存在novas.rc中</p><p>共有以下几种设置.rc文件的方法：</p><ul><li>-rcFile 命令行参数 <code>verdi -ssf &lt;fsdb filename&gt; -rcFile &lt;filename&gt;</code> 优先级最高</li><li>NOVAS_RC 环境变量</li><li>.&#x2F;novas.rc</li><li>$HOME&#x2F;novas.rc</li><li>&#x2F;etc&#x2F;novas.rc</li></ul>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
      <category>EDA</category>
      
      <category>verdi</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>verdi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git撤销add/commit操作</title>
    <link href="/2022/03/08/tools/git/git%E6%92%A4%E9%94%80addcommit/"/>
    <url>/2022/03/08/tools/git/git%E6%92%A4%E9%94%80addcommit/</url>
    
    <content type="html"><![CDATA[<p>如何把最后一次commit撤销回Changes not staged和Untracked files区呢？</p><p>有3种情况：<br>（1）把最后的commit切回 Changes to be committed状态，使用命令</p><figure class="highlight perl"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs perl">git <span class="hljs-keyword">reset</span> --soft HEAD^<br>注意：Windows系统需要在^符号后面两边加上引号，如：<br><br>git <span class="hljs-keyword">reset</span> --soft HEAD<span class="hljs-string">&quot;^&quot;</span><br></code></pre></td></tr></table></figure><p>（2）把最后的commit切回Changes not staged for commit状态，使用命令</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">git <span class="hljs-keyword">reset</span> HEAD^<br></code></pre></td></tr></table></figure><p>（3）把Changes to be committed状态切回Changes not staged for commit状态，使用命令</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">git <span class="hljs-keyword">reset</span> HEAD &lt;file&gt;...          <span class="hljs-comment"># 单个文件</span><br>git <span class="hljs-keyword">reset</span> HEAD -- .               <span class="hljs-comment"># 所有Changes to be committed的文件</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>验证文章视频收藏</title>
    <link href="/2020/12/05/Verification/Verif/%E9%AA%8C%E8%AF%81%E6%96%87%E7%AB%A0%E8%A7%86%E9%A2%91%E6%94%B6%E8%97%8F/"/>
    <url>/2020/12/05/Verification/Verif/%E9%AA%8C%E8%AF%81%E6%96%87%E7%AB%A0%E8%A7%86%E9%A2%91%E6%94%B6%E8%97%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="针对不同验证点验证点"><a href="#针对不同验证点验证点" class="headerlink" title="针对不同验证点验证点"></a>针对不同验证点验证点</h2><h3 id="1-dead-lock"><a href="#1-dead-lock" class="headerlink" title="1. dead lock"></a>1. dead lock</h3><ul><li>【video】 <a href="https://verificationacademy.com/conferences/dvcon-2020/deadlock-verification-for-dummies-using-sva-and-formal/video/1639?play=1">Mentor Deadlock Verification For Dummies - The Easy Way Using SVA and Formal</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vcs——radiant technology</title>
    <link href="/2020/10/31/tools/vcs/vcs%E2%80%94%E2%80%94radiant%20technology/"/>
    <url>/2020/10/31/tools/vcs/vcs%E2%80%94%E2%80%94radiant%20technology/</url>
    
    <content type="html"><![CDATA[<p><strong>Radiant Technology</strong></p><blockquote><p>VCS MX Radiant Technology applies performance optimizations to the Verilog portion of your design while VCS MX compiles your Verilog source code. These Radiant optimizations improve the simulation performance of all types of designs from behavioral, RTL to gate-level designs. Radiant Technology particularly improves the  performance of functional simulations <strong>where there are no timing specifications or when delays are distributed to gates and  assignment statements.</strong>  </p></blockquote><p>compile option，在compile阶段对Verilog code进行优化，以提高仿真性能。</p><p>使用：+rad</p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
      <category>EDA</category>
      
      <category>vcs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>vcs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV——pullup pulldown</title>
    <link href="/2020/10/29/Verification/SystemVerilog/SV%E2%80%94%E2%80%94pullup%20pulldown/"/>
    <url>/2020/10/29/Verification/SystemVerilog/SV%E2%80%94%E2%80%94pullup%20pulldown/</url>
    
    <content type="html"><![CDATA[<p>pullup上拉，pulldown下拉，当信号没有没驱动的时候（z态）才会有效；如果信号被驱动，忽略pullup pulldown。</p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> dut(<span class="hljs-keyword">input</span> enable);<br><span class="hljs-keyword">wire</span> a;<br><span class="hljs-keyword">pullup</span>(a);<br>a = enable?<span class="hljs-number">0</span>:z;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>enable为1的时候，a为0；</p><p>enable为0的时候，a为1，这是因为有pullup（a）将a从z态上拉到1.</p><p>pulldown同理。</p>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV——disable_fork与总线事务</title>
    <link href="/2020/09/06/Verification/SystemVerilog/disable_fork%E4%B8%8E%E6%80%BB%E7%BA%BF%E4%BA%8B%E5%8A%A1/"/>
    <url>/2020/09/06/Verification/SystemVerilog/disable_fork%E4%B8%8E%E6%80%BB%E7%BA%BF%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>对于下面的例子，假设实际中是thread1 先完成，thread0被disable。并且 signal&#x3D;&#x3D;1的时候，reg0的值恰好也会跳变为1。本意是再thread 2对reg 0 做的write clear.</p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">fork</span><br>    <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// thread 0</span><br>        <span class="hljs-keyword">while</span>(rd_data == <span class="hljs-number">0</span>) <span class="hljs-keyword">begin</span><br>            getreg(reg0,rd_data);<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span> <span class="hljs-comment">// thread 1</span><br>        <span class="hljs-keyword">wait</span>(signal == <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">join_any</span><br><span class="hljs-keyword">disable</span> <span class="hljs-keyword">fork</span>;<br>    wrreg(reg0,rd_data); <span class="hljs-comment">//thread 2</span><br></code></pre></td></tr></table></figure><p>但是实际波形中，在thread 1 结束之后，总线上先做了一个读操作，读到的值是跳变后的1；然后做了一个写操作，写的值是0.</p><p>这与期望不同，期望的是thread 1结束之后，是一个写1的操作。</p><p>这可能是因为，thread 1结束的时候thread 0已经在总线（好像是AXI）上了，它会读到1；但thread 1结束之后，thread 2也被提到总线上，此时写的值rd_data为0，因为thread 0还没有返回1，所以会有问题。</p><p>解决方法有两个，一个是在thread 2之前做一段时间的延迟（#）；另一个是在thread 2写之前，先读。</p><p>而且这次仿真中在thread 2之后还有一个读reg 0的操作，判断是否write clear，但是在总线上没有看到这次的transaction，最终timeout。</p>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM——关于RAL的一些方法</title>
    <link href="/2020/06/06/Verification/UVM/UVM%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8ERAL%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95/"/>
    <url>/2020/06/06/Verification/UVM/UVM%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8ERAL%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="0-引言"><a href="#0-引言" class="headerlink" title="0. 引言"></a>0. 引言</h3><p>　　在UVM支持的寄存器操作中，有get、update、mirror、write等等一些方法，在这里整理一下他们的用法。</p><p>　　寄存器模型中的寄存器值应该与DUT保持同步，但是由于DUT的值是实时更新的，所以寄存器模型并不能实时知道这种更新，<strong>在寄存器模型中专门有个值来尽可能与DUT中寄存器的值保持一致，叫镜像值（mirrorred value）。</strong></p><p>​    寄存器模型中还有一个值叫<strong>期望值（respected value）</strong>，这个值保存我们希望写入寄存器的值。比如希望向DUT某个寄存器写入’h1，用set函数设置期望值，然后用update任务（update会比较镜像值和期望值，如果不一样，将期望值写入DUT，并更新镜像值）。</p><h3 id="1-函数"><a href="#1-函数" class="headerlink" title="1.  函数"></a>1.  函数</h3><h4 id="1-1-set"><a href="#1-1-set" class="headerlink" title="1.1 set"></a>1.1 set</h4><figure class="highlight vala"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs vala"><span class="hljs-keyword">virtual</span> function <span class="hljs-keyword">void</span> <span class="hljs-keyword">set</span> (uvm_reg_data_t value, <span class="hljs-keyword">string</span> fname = <span class="hljs-string">&quot;&quot;</span>,<span class="hljs-keyword">int</span> lineno = <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>　　<strong>设置模型中寄存器的期望值，不会改变DUT中这个寄存器的值。</strong></p><h4 id="1-2-get"><a href="#1-2-get" class="headerlink" title="1.2 get"></a>1.2 get</h4><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> uvm_reg_data_t get(<span class="hljs-built_in">string</span> fname = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-built_in">int</span> lineno = <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>　　<strong>返回模型中寄存器的期望值，而不是DUT中的寄存器值</strong>。</p><h4 id="1-3-get-mirrored-value"><a href="#1-3-get-mirrored-value" class="headerlink" title="1.3 get_mirrored_value"></a>1.3 get_mirrored_value</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> uvm_reg_data_t get<span class="hljs-constructor">_mirrored_value(<span class="hljs-params">string</span> <span class="hljs-params">fname</span> = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-params">int</span> <span class="hljs-params">lineno</span> = 0)</span><br></code></pre></td></tr></table></figure><p>　　返回模型中寄存器的镜像值。</p><h4 id="1-4-get-reset"><a href="#1-4-get-reset" class="headerlink" title="1.4 get_reset"></a>1.4 get_reset</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> uvm_reg_data_t get<span class="hljs-constructor">_reset(<span class="hljs-params">string</span> <span class="hljs-params">kind</span> = <span class="hljs-string">&quot;HARD&quot;</span>)</span><br></code></pre></td></tr></table></figure><p>　　返回寄存器的复位值。</p><h4 id="1-5-predict"><a href="#1-5-predict" class="headerlink" title="1.5 predict"></a>1.5 predict</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">virtual</span> function bit <span class="hljs-title">predict</span> <span class="hljs-params">(<span class="hljs-type">uvm_reg_data_t</span> value,  </span></span><br><span class="hljs-params"><span class="hljs-function">　　<span class="hljs-type">uvm_reg_byte_en_t</span> be = <span class="hljs-number">-1</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">　　uvm_predict_e kind = UVM_PREDICT_DIRECT,</span></span><br><span class="hljs-params"><span class="hljs-function">　　uvm_path_e path = UVM_FRONTDOOR,</span></span><br><span class="hljs-params"><span class="hljs-function">　　uvm_reg_map map = null,</span></span><br><span class="hljs-params"><span class="hljs-function">　　string fname = <span class="hljs-string">&quot;&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">　　<span class="hljs-type">int</span> lineno = <span class="hljs-number">0</span>)</span></span><br></code></pre></td></tr></table></figure><p>　　<strong>更新模型中的镜像值。</strong>新的镜像值通过value参数传入。</p><p>　　<strong>当在DUT中实现一个计数器的时候，模型中的计数器是静止的。如果想在模型中得到DUT的计数值，这就需要手动更新镜像值，又不能对DUT进行操作，这可以通过predict函数。</strong></p><p>第三个参数是uvm_predict_e枚举类型，他有如下三个元素：</p><table><thead><tr><th>UVM_PREDICT_DIRECT</th><th>Predicted value is as-is</th></tr></thead><tbody><tr><td>UVM_PREDICT_READ</td><td>Predict based on the specified value having been read</td></tr><tr><td>UVM_PREDICT_WRITE</td><td>Predict based on the specified value having been written</td></tr></tbody></table><p>如果想要更新镜像值又不对DUT进行操作，要用UVM_PREDICT_DIRECT。</p><p>　　<strong>write、read、peek和poke在完成对DUT的读写之后也会调用这个函数，更新镜像值。</strong></p><h4 id="1-6-randomize"><a href="#1-6-randomize" class="headerlink" title="1.6 randomize"></a>1.6 randomize</h4><p>　　无论是uvm_reg，还是uvm_field、uvm_block，都是支持randomize（）。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">assert</span></span>(<span class="hljs-variable">rm.invert.reg_data.randomize</span>());</span><br><span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">assert</span></span>(<span class="hljs-variable">rm.invert.randomize</span>());</span><br><span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">assert</span></span>(<span class="hljs-variable">rm.randomize</span>()):</span><br></code></pre></td></tr></table></figure><p>　　</p><p>　　<strong>当寄存器随机化后，期望值会被随机，但是镜像值不变，之后调用update任务，可以更新DUT中的寄存器值。</strong></p><p>　　但是一个field能够被随机化，需要：</p><p>　　　　1. 在filed的configure第八个参数设为1.</p><p>　　　　2. filed为rand类型。</p><p>　　　　3. filed的读写类型为可写的。</p><h3 id="2-任务"><a href="#2-任务" class="headerlink" title="2. 任务"></a>2. 任务</h3><h4 id="2-1-update"><a href="#2-1-update" class="headerlink" title="2.1  update"></a>2.1  update</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> update(<span class="hljs-keyword">output</span> uvm_status_e status,  <br>　　<span class="hljs-keyword">input</span> uvm_path_e path = UVM_DEFAULT_PATH,<br>　　<span class="hljs-keyword">input</span> uvm_reg_map map = <span class="hljs-literal">null</span>,<br>　　<span class="hljs-keyword">input</span> uvm_sequence_base parent = <span class="hljs-literal">null</span>,<br>　　<span class="hljs-keyword">input</span> <span class="hljs-keyword">int</span> prior = -<span class="hljs-number">1</span>,<br>　　<span class="hljs-keyword">input</span> uvm_object extension = <span class="hljs-literal">null</span>,<br>　　<span class="hljs-keyword">input</span> <span class="hljs-keyword">string</span> fname = <span class="hljs-string">&quot;&quot;</span>,<br>　　<span class="hljs-keyword">input</span> <span class="hljs-keyword">int</span> lineno = <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>　　<strong>将模型中的期望值更新到DUT中。改变DUT中的寄存器。****update会检查模型中的期望值和镜像值，如果两者不相等，那么将期望值更新到DUT中，并且更新镜像值。</strong>update与mirror操作相反。</p><p>　　<strong>如果镜像值和期望值相同，那么不会写DUT寄存器，也就不会产生总线transaction。</strong></p><h4 id="2-2-mirror"><a href="#2-2-mirror" class="headerlink" title="2.2 mirror"></a>2.2 mirror</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> mirror(<span class="hljs-keyword">output</span> uvm_status_e status,  <br>　　<span class="hljs-keyword">input</span> uvm_check_e check = UVM_NO_CHECK,<br>　　<span class="hljs-keyword">input</span> uvm_path_e path = UVM_DEFAULT_PATH,<br>　　<span class="hljs-keyword">input</span> uvm_reg_map map = <span class="hljs-literal">null</span>,<br>　　<span class="hljs-keyword">input</span> uvm_sequence_base parent = <span class="hljs-literal">null</span>,<br>　　<span class="hljs-keyword">input</span> <span class="hljs-keyword">int</span> prior = -<span class="hljs-number">1</span>,<br>　　<span class="hljs-keyword">input</span> uvm_object extension = <span class="hljs-literal">null</span>,<br>　　<span class="hljs-keyword">input</span> <span class="hljs-keyword">string</span> fname = <span class="hljs-string">&quot;&quot;</span>,<br>　　<span class="hljs-keyword">input</span> <span class="hljs-keyword">int</span> lineno = <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>　　<strong>读DUT中寄存器的值，与update操作相反。</strong>如果第二个参数check为UVM_CHECK，那么会检查读取的值与镜像值是否一样，如果不一样报错。通过mirror读取DUT的寄存器值之后，会调用predict函数，更新镜像值。</p><p>　　mirror有两种应用场景：一是在仿真中不断调用，但此时是UVM_NO_CHECK，保证镜像值与DUT中的值相等；二是在仿真结束的时候调用，这时是UVM_CHECK检查模型中的镜像值与DUT中的寄存器值是否一致。</p><h4 id="2-3-write"><a href="#2-3-write" class="headerlink" title="2.3 write"></a>2.3 write</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> write(<span class="hljs-keyword">output</span> uvm_status_e status,  <br>　　<span class="hljs-keyword">input</span> uvm_reg_data_t value,  <br>　　<span class="hljs-keyword">input</span> uvm_path_e path = UVM_DEFAULT_PATH,<br>　　<span class="hljs-keyword">input</span> uvm_reg_map map = <span class="hljs-literal">null</span>,<br>　　<span class="hljs-keyword">input</span> uvm_sequence_base parent = <span class="hljs-literal">null</span>,<br>　　<span class="hljs-keyword">input</span> <span class="hljs-keyword">int</span> prior = -<span class="hljs-number">1</span>,<br>　　<span class="hljs-keyword">input</span> uvm_object extension = <span class="hljs-literal">null</span>,<br>　　<span class="hljs-keyword">input</span> <span class="hljs-keyword">string</span> fname = <span class="hljs-string">&quot;&quot;</span>,<br>　　<span class="hljs-keyword">input</span> <span class="hljs-keyword">int</span> lineno = <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>　　模仿DUT的行为，通过前门或者后门方式向DUT中写入寄存器值，<strong>会产生总线transaction</strong>。并且调用predict更新镜像值。</p><p>　　uvm_path_e定义寄存器操作类型，如下：</p><table><thead><tr><th>UVM_FRONTDOOR</th><th>Use the front door</th></tr></thead><tbody><tr><td>UVM_BACKDOOR</td><td>Use the back door</td></tr><tr><td>UVM_PREDICT</td><td>Operation derived from observations by a bus monitor via the <a href="file:///D:/代码示例/uvm-1.1d/uvm-1.1d/docs/html/files/reg/uvm_reg_predictor-svh.html#uvm_reg_predictor">uvm_reg_predictor</a> class.</td></tr><tr><td>UVM_DEFAULT_PATH</td><td>Operation specified by the context</td></tr></tbody></table><p>　　我在使用中，<strong>如果用set_auto_predict(1)——采取自动更行镜像值的方式，write之后，调用get和get_mirrored_value都能得到新写入的值。</strong>　　</p><p>　　<strong>如果关闭auto_predict，用uvm_reg_predict来更新镜像值，我在在使用中write之后，调用get和get_mirrored_value得到0</strong>。</p><p>　　如果是read任务，那么无论是auto_predict还是uvm_reg_predict都会自动更新镜像值和期望值。</p><p>　　链接：<a href="https://github.com/east1203/uvm_codes/tree/master/tb1_wd/a.uvm_reg_predict">https://github.com/east1203/uvm_codes/tree/master/tb1_wd/a.uvm_reg_predict</a></p><h4 id="2-4-read"><a href="#2-4-read" class="headerlink" title="2.4 read"></a>2.4 read</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> read(<span class="hljs-keyword">output</span> uvm_status_e status,  <br>　　<span class="hljs-keyword">output</span> uvm_reg_data_t value,  <br>　　<span class="hljs-keyword">input</span> uvm_path_e path = UVM_DEFAULT_PATH,<br>　　<span class="hljs-keyword">input</span> uvm_reg_map map = <span class="hljs-literal">null</span>,<br>　　<span class="hljs-keyword">input</span> uvm_sequence_base parent = <span class="hljs-literal">null</span>,<br>　　<span class="hljs-keyword">input</span> <span class="hljs-keyword">int</span> prior = -<span class="hljs-number">1</span>,<br>　　<span class="hljs-keyword">input</span> uvm_object extension = <span class="hljs-literal">null</span>,<br>　　<span class="hljs-keyword">input</span> <span class="hljs-keyword">string</span> fname = <span class="hljs-string">&quot;&quot;</span>,<br>　　<span class="hljs-keyword">input</span> <span class="hljs-keyword">int</span> lineno = <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>　　<strong>模仿DUT的行为，通过前门或者后门方式读取DUT中寄存器的值，并更新镜像值，会产生总线transaction</strong>。</p><h4 id="2-5-peek"><a href="#2-5-peek" class="headerlink" title="2.5 peek"></a>2.5 peek</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> poke(<span class="hljs-keyword">output</span> uvm_status_e status,  <br>　　<span class="hljs-keyword">input</span> uvm_reg_data_t value,  <br>　　<span class="hljs-keyword">input</span> <span class="hljs-keyword">string</span> kind = <span class="hljs-string">&quot;&quot;</span>,<br>　　<span class="hljs-keyword">input</span> uvm_sequence_base parent = <span class="hljs-literal">null</span>,<br>　　<span class="hljs-keyword">input</span> uvm_object extension = <span class="hljs-literal">null</span>,<br>　　<span class="hljs-keyword">input</span> <span class="hljs-keyword">string</span> fname = <span class="hljs-string">&quot;&quot;</span>,<br>　　<span class="hljs-keyword">input</span> <span class="hljs-keyword">int</span> lineno = <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>　　<strong>通过后门访问方式读取寄存器的值，不关心DUT的行为，即使寄存器的读写类型是不能读，也可以将值读出来</strong>。</p><p> 　　对于read clear类型的field，peek读操作不会clear。所以有的时候peek和read操作结果不一样</p><h4 id="2-6-poke"><a href="#2-6-poke" class="headerlink" title="2.6 poke"></a>2.6 poke</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> peek(<span class="hljs-keyword">output</span> uvm_status_e status,  <br>　　<span class="hljs-keyword">output</span> uvm_reg_data_t value,  <br>　　<span class="hljs-keyword">input</span> <span class="hljs-keyword">string</span> kind = <span class="hljs-string">&quot;&quot;</span>,<br>　　<span class="hljs-keyword">input</span> uvm_sequence_base parent = <span class="hljs-literal">null</span>,<br>　　<span class="hljs-keyword">input</span> uvm_object extension = <span class="hljs-literal">null</span>,<br>　　<span class="hljs-keyword">input</span> <span class="hljs-keyword">string</span> fname = <span class="hljs-string">&quot;&quot;</span>,<br>　　<span class="hljs-keyword">input</span> <span class="hljs-keyword">int</span> lineno = <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>　　<strong>通过后门访问方式写入寄存器的值，不关心DUT的行为，即使寄存器的读写类型是不能写，也可以将值写进去</strong>。</p><p> 　　对于write clear类型的filed，poke操作不会clear，所以有的时候poke和write操作结果不一样。</p>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>UVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
      <tag>UVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>敏捷开发-IC极客摘要</title>
    <link href="/2020/05/04/IC/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91-IC%E6%9E%81%E5%AE%A2%E6%91%98%E8%A6%81/"/>
    <url>/2020/05/04/IC/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91-IC%E6%9E%81%E5%AE%A2%E6%91%98%E8%A6%81/</url>
    
    <content type="html"><![CDATA[<p>#Alice的敏捷分享–0323-验证#</p><p>我近一两年非常多次在社群里面启发大家思考一个问题，验证的目标是什么，相对能达成共识的有以下几点：</p><ul><li>验证的目标是保证质量，不是debug</li><li>芯片可以带bug交付 （乙方会表达成，这不是bug，这是feature,或者你的姿势不对）</li><li>bug分等级，category A&#x2F;B&#x2F;C，有严重到影响产品销售的bug，也有没任何影响的bug</li><li>bug可以通过软件规避</li></ul><p>验证team的loading实在是太重了，不996是不可能的。无论哪个部门改动都会影响到我们的loading和验证计划，需求改我们改，架构改我们改，设计改我们改，后端，DFT改了反馈给前端，我们接着改，每日三省吾身，这个bug是spec的错，设计的错还是验证自身的错。</p><p>不堪重负的验证团队于是开始自救，主流方法不外乎以下几种：</p><ol><li>把验证工作在全流程shift left</li><li>自动化，并行，解耦，分层</li><li>按特性跟设计结对，交付之前先过sanity check</li><li>跟其他部门划清楚河汉界，定交付规则，谁的活儿谁干，谁的锅谁背</li></ol><p>已经有点敏捷和CI的意思了，但，还不够，没有从根因上解决导致问题的元问题，罪魁祸首是谁，肯定不是design, 他们不无辜么？架构师，你忍心责怪他们？客户？你敢让客户背锅？客户也有他的客户啊。</p><p>在传统瀑布流模式下系统成员的关系：客户是甲方，芯片的需求方，业务，产品，研发（按流程切分4-8个部门），运营共同构成乙方，以芯片交付的方式满足甲方价值需求。其特点为 1，推，上游推下游，每个层级沟通都会有信息损耗，损耗导致误差，误差导致迭代 2. 下游是被动接任务，活儿是上游给的。特别是验证，谁改都是给他又来活儿了。这个系统模型从根因上决定了验证的loading，任务的总量降不下来，上述1234的方案一定程度上缓解，但没有解决根因问题。敏捷试图解决的是根因问题。</p><p>敏捷的底层逻辑从系统成员的关系视角来看：</p><ol><li>客户是甲方（需求方），研发是解决方案，解决方案要靠近问题，跟问题共生，跟需求直接发生化学反应，需求变，方案紧跟着变，按需求点拆成价值点，把价值点转化为特性和指标定义，这，叫业务驱动研发。</li><li>在研发内部，架构师是解决方案，解决方案的本质是一堆模型的组合（参考之前模型化架构师的交付物讨论），其他人帮他把模型实现成real的可交付价值的芯片，在组织内部，RTL, PR, DFT都是架构的乙方，帮他做实现。验证唯二的两个价值主张就是以最小的投入最大化保证过程质量，是中立的第三方，需要跟架构放在同一个layer。都有义务引导组织内部乙方loading不要太重，如果乙方过程飞掉，甲方自身利益受损。</li><li>上述所有的甲方乙方之间遵循两个原则，1. 乙方以成就甲方目标为己任（这个观念已经比较深入人心了）2. 每个人以谈判的形式争取自己利益最大化（scrum的3355）利他是天性，利己是人性，只有在这两种力的张力下充分沟通过了达成的一致性才是真正的一致性，才是组织利益的最大化。</li><li>PO管人管钱管事，是真正的product owner，他可以决定，这波研发不行，我们换一拨，这个研发是key player，给他加薪，这个feature优先级不高，砍掉，因为钱是他的，ROI是他最重要的决策指标。其他人，不代表他的利益，没有立场排序真正重要的事，但每个人的主张和利益诉求要给到他，他不掌握足够信息无法形成有效激励，但决策权在他。</li></ol><p>总结一句话，按照敏捷的系统论过程模型，从根因上解决了瀑布流导致的信息损耗的问题，解决了由于利益和权力不对等而导致的动力缺失和内耗问题，解决了由于信息不对等，不及时导致的出错和方案与价值需求不匹配问题。是一种以人为本，尊重人性，道法自然的工程实践方法论。聚焦客户的价值交付，以拉动的方式，持续改善工程生产力。</p><p>#Alice的敏捷分享–SAFe 和LeSS有什么区别#</p><p>敏捷体系当中发展出很多流派，其中影响最大的是SAFe和LeSS，他们俩的关系有点像C和S的关系，是经过一轮竞争唯二独大的两个友商（社区），这种道法术器一体化的敏捷转型不像EDA工具，直接基于同一个case跑，优劣立竿见影。企业文化研发体系转型，往往耗时几年，拼的是思想，方法和长久实践，两派各有一堆成功和失败的案例，用来互相打口水战，常年在社区互相攻击。</p><p>核心区别大约有以下几点：</p><ol><li><p>SAFe在超大规模组织中较流行，LeSS是classic的敏捷（轻量级方法论），认为SAFe的臃肿固定的框架已经背离了敏捷的初衷，你如果对着SAFe framework框架图，初学者不看上十分钟几乎完全看不懂，LeSS framework就是非常清清爽爽的泳道，冲刺，一目了然。</p></li><li><p>都注重沟通和敏捷团队，都需要CICD DevOps支持，在两个体系框架下用的术语和概念不同，稍微有点对应，但不同。价值流图，敏捷交付火车，看板方法是SAFe的术语，实例化文档，影响地图，用户故事地图，冲刺，scrum是LeSS的术语</p></li><li><p>在经典的项目管理工具Jira当中，两种方法都支持，Kanban vs. scrum sprint，但不能混用</p></li><li><p>Kanban vs. scrum核心区别有两个，一是任务切分的边界不同，一个是按交付物为边界切，一个是按activity切；看板是连续的流动，sprint多了个time box，1-2w，一个冲刺内，需求不允许变更，经典模式是冲-回顾-拉</p></li><li><p>发布计划不同，Kanban没有冲刺，一般做三个月的长期规划，LeSS注重快，小，并行的sprint-long iterations</p></li><li><p>SAFe注重resource 优化，注重人与人的关系，LeSS注重产出物优化，注重人与技术的关系</p></li><li><p>都注重客户导向，SAFe的客户沟通还是由business owner，PM驱动，LeSS直接砍掉了这一层，直接是业务驱动研发，把所有人拉到一线去直接面向客户</p></li><li><p>SAFe适应超大规模相对稳定的组织，LeSS在创业团队中更受欢迎</p></li></ol><p>#Alice的敏捷分享–三分钟快速了解敏捷体系#</p><p>本篇试图回答三个问题，以下言论纯属个人理解，仅供参考，欢迎拍砖</p><ol><li>敏捷体系的overview</li><li>立论基石</li><li>核心实践</li></ol><p>敏捷虽作为一种轻量级方法论诞生，但随着在科技公司，软件公司及企业的数字化转型中广泛普及，作为企业的工程生产力构建指南，仍然保罗万象，海纳百川。它最早始于重构，统一语言，简单设计，TDD，极限编程，实例化文档等用于开发环节的理念，后来吸收了CICD DevOps，项目管理层面融入了精益的思想，如前置时间，看板方法，产品需求及沟通管理层面引入了影响地图，用户故事地图，增量开发等理念，开发管理上引入了scrum，团队建设上直奔学习型组织，管理3.0那一套东西，注重沟通和赋能而非控制，沟通中注重启发式，教练式，倾听式，提问式，杜绝KPI，严禁指责。放到SOC语境里面则必须要把CICD DevOps和EDA流程进行深度融合。测试是整个体系改革的重点，也是唯一能无缝映射到SOC验证领域的最佳实践。</p><p>立论基石：1. 知识消费（参考下午发的内容）2. 聚焦价值交付的一致性沟通 3. 实例化文档&#x2F;TDD&#x2F;ATDD&#x2F;BDD 如果我说在一个系统论的框架下，这三点都是一回事，大家能理解么？你尝试跳出传统瀑布流，稍微升维一下，从业务视角向下看研发。</p><p>核心实践：1. 度量体系 2. 可视化一切 3. 流动及反馈</p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>敏捷开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git提交不同版本的程序</title>
    <link href="/2020/03/26/tools/git/git%E6%8F%90%E4%BA%A4%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%A8%8B%E5%BA%8F/"/>
    <url>/2020/03/26/tools/git/git%E6%8F%90%E4%BA%A4%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/sinat_39150454/article/details/73729196">https://blog.csdn.net/sinat_39150454/article/details/73729196</a></p><p>以前项目中版本控制通常使用小乌龟SVN版本控制器，最近发现github更胜一筹，不仅方便代码管理，而且还能反映程序员编程情况。今天简单记录一下如何使用git命令提交不同版本的项目代码到github.</p><p>1.查看版本分支</p><p>git branch -a #查看github现有的分支<br>git branch #查看本地分支<br>1<br>2<br>2.在本地创建分支<br>默认情况下，本地和远程端(github)只有一个名为master的分支。有时候为了方便区分每次修改提交的代码，我们可以通过利用不同的分支来加以区分，后续克隆clone代码可以方便的利用分支名签出不同版本的源程序。</p><p>git branch <YourBranchName><br>1<br>3.切换当前分支</p><p>git checkout <YourBranchName><br>1<br>4.推送新建分支到github上</p><p>git push origin <YourBranchName><br>1<br>5.提交项目到github</p><p>git add .<br>git commit -a -m ‘YourComments’<br>git push -u origin  <YourBranchName><br>1<br>2<br>3<br>接着输入github账号和密码即可完成项目提交。<br>————————————————<br>版权声明：本文为CSDN博主「ikinest」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/sinat_39150454/article/details/73729196">https://blog.csdn.net/sinat_39150454/article/details/73729196</a></p><h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs git">git branch -d branchname<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>负的保持时间和建立时间</title>
    <link href="/2020/01/14/IC/STA/%E8%B4%9F%E7%9A%84%E4%BF%9D%E6%8C%81%E6%97%B6%E9%97%B4%E5%92%8C%E5%BB%BA%E7%AB%8B%E6%97%B6%E9%97%B4/"/>
    <url>/2020/01/14/IC/STA/%E8%B4%9F%E7%9A%84%E4%BF%9D%E6%8C%81%E6%97%B6%E9%97%B4%E5%92%8C%E5%BB%BA%E7%AB%8B%E6%97%B6%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p>通常见到讲建立时间和保持时间，它们都是正的，那么负的建立时间（negative setup time) 和保持时间(negative hold up time) 是什么意思呢？</p><h4 id="negative-setup-time"><a href="#negative-setup-time" class="headerlink" title="negative setup time"></a>negative setup time</h4><p>​    当发生setup time violation的时候，是因为capture FF 的data比时钟沿来的慢，或者说capture FF 的时钟来得快了。如果要fix timing，那么需要在capture FF的时钟上加delay单元，如果把capture FF和delay单元看成一个单元，叫它FFA，那么当delay足够大的时候，FFA的setup time可以为负。</p><h4 id="negative-hold-time"><a href="#negative-hold-time" class="headerlink" title="negative hold time"></a>negative hold time</h4><p>对于hold time violation发生时，capture FF 的data来得太快，为了优化时序可以在FF的data端口添加delay单元，讲FF和delay单元看成同一个单元，那么当delay足够大的时候，这个FF单元的hold time可以为负。</p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>STA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>timing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何成为高效的工程师</title>
    <link href="/2019/12/19/others/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E9%AB%98%E6%95%88%E7%9A%84%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    <url>/2019/12/19/others/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E9%AB%98%E6%95%88%E7%9A%84%E5%B7%A5%E7%A8%8B%E5%B8%88/</url>
    
    <content type="html"><![CDATA[<h2 id="《how-to-be-a-star-engineer》"><a href="#《how-to-be-a-star-engineer》" class="headerlink" title="《how to be a star engineer》"></a>《how to be a star engineer》</h2><p>​                                                    —— Robert E.Kelley</p><p>作者跟踪了一些在Bell Lab工作的两种人的经历，一种是star performance people ，另一种是average performance people，发现这些人之所以star，不是因为他们的聪明天赋、大脑，而是因为他们如何使用自己已有的东西。”Stars, we saw, are made, not born 。“</p><p>给出了以下九个工作策略（Nine work strategies）</p><h3 id="1-Blazing-trails"><a href="#1-Blazing-trails" class="headerlink" title="1.Blazing trails"></a>1.Blazing trails</h3><ul><li>Seeking out responsibility above and beyond job description (as when Lai installed the PC software), while still completing your core assignment.（做自己工作范围之外的事情，前提是干好自己的任务）</li><li>l Undertaking extra efforts for the benefit of co-workers or the larger group, as when Lai offered to help fix the software program on her co-workers’ project.（为了同事或者整个组贡献一点额外的effort）</li></ul><p>特别是对于新员工来说，要表现出自己的initiative（积极主动性），不是只埋头于自己的工作范围，也要跨过自己的工作边界，帮一下同事，这样会给同事、主管留下印象。特别是同事，他们希望积极主动的同事，希望他们能够越过gaps between jobs，这样的话他们自己的load就减少了。</p><h3 id="2-Knowing-who-know"><a href="#2-Knowing-who-know" class="headerlink" title="2.Knowing who know"></a>2.Knowing who know</h3><p>保持好的人际关系，不只是跟同事聊一些有的没的，或者为了升职加薪拍领导马屁，多加几个猎头，更重要的是跟自己领域里的expert建立互帮互助的双向关系，这样遇到问题的时候知道去问谁。</p><h3 id="3-Proactive-self-management"><a href="#3-Proactive-self-management" class="headerlink" title="3.Proactive self-management"></a>3.Proactive self-management</h3><p>​    Average Performers认为自我管理就只是管理好时间、项目。如果他们的工作按照进度表、预期、指标完成了，那么他们就是好的self-managers。</p><p>​    但是，Star Performers认为做到这些本来就是应该的，他们的工作策略是帮助他们创造机会、直接的工作选择、工作干得更好，帮助他们刻画出一条职业路径。帮助他们发展智力和工作经验，使他们对于公司而言更有价值。</p><p>​    开展一些与工作有关的额外的活动，比如听个会议，参加个培训，了解一点最新的行业资讯、标准、工具、方法、软件等。</p><h3 id="4-Getting-the-big-picture"><a href="#4-Getting-the-big-picture" class="headerlink" title="4. Getting the big picture"></a>4. Getting the big picture</h3><p>​    Average Performers视野狭窄，只从自己的角度看问题。</p><p>​    Star Performers从自己的viewpoint中扩展出来，”客户会怎么想这个事“，”竞争对手会怎么想“，”同事怎么想“，”主管或者股东怎么想“。这样他可以评估这些观点的重要性，进而提高产品质量、解决问题的策略。</p><p>举了一个软件设计师的例子，她一开始做design，后来主动去做test，两年后，又回到design岗位，因为她既知道如何design，也知道tester是怎么想的，她后来成了manager。</p><h3 id="5-The-right-kind-of-followership"><a href="#5-The-right-kind-of-followership" class="headerlink" title="5. The  right kind of followership"></a>5. The  right kind of followership</h3><p>Average Performers认为，与有权威、级别高的人之间的关系是服从，不要挑战他们的观点，威胁他们的地位。</p><p>Star Performers早就知道服从关系的更积极的形式是当NO.2，更重要的是提供帮助而不是取得功绩。他们积极地帮助组织或者领导取得成功，当决定什么应该做，怎么做的时候可能会经历一些批评性的评价，</p><h3 id="6-Teemwork-as-joint-ownership-of-a-project"><a href="#6-Teemwork-as-joint-ownership-of-a-project" class="headerlink" title="6. Teemwork as joint ownership of a project"></a>6. Teemwork as joint ownership of a project</h3><p>Average Perfomers认为团队工作就是与其他人一起完成项目或者解决问题，只做自己的那份工作。</p><p>Star Performers认为团队合作是一系列复杂技能的集合，共同拥有目标、团队承诺、工作活动、时间表和团队成就。也意味着做一个组内的正向贡献者，帮助每一个人感受到自己是组内的一部分，能够处理冲突，帮助其他人解决问题。</p><h3 id="7-Small-I-leadership"><a href="#7-Small-I-leadership" class="headerlink" title="7. Small-I leadership"></a>7. Small-I leadership</h3><p>Average Perfomers认为leadership只是权力，可以决定要做什么。</p><p>Star Performers领导力是一种基于技术能力和影响力的工作策略，它可以说服一组人共同完成大量工作。努力做到：帮助团队清楚看到并且坚信他们能够去哪里；寻找资源来完成工作；引导工作成功完成。</p><p>Small-I的领导认为人类关系能够连接彼此，然而Big-I 领导太过于关注他们自己的观点、目标、风格。Small-I领导能够考虑到团队中每个人的需求、技能、期望和能量。</p><p>Small-I领导很少使用权威来对待团队成员。团队成员会根据兴趣喜好来追随他们的领导。Small-I领导会在努力工作之后弄点深夜披萨之类的东西来团结成员。</p><p>Star Performers的最大的秘密是他们从来不会假设自己已经对每个人都很了解了。他们会提前问一下其他人的以减，即使当他们确定自己已经知道了结果。</p><h3 id="8-Street-smarts"><a href="#8-Street-smarts" class="headerlink" title="8. Street smarts"></a>8. Street smarts</h3><p>讲的是办公室政治。</p><p>Average Performers喜欢讨好别人以至于让自己能够成功。他们要么热心于办公室政治，要么故作清高完全忽略他么。</p><p>Star Performers认为任何一个大的组织都会有不合理的利益。他们远离麻烦，促使团结合作，处理冲突，使事情更好。他们平衡好个人与组织的利益，知道什么时候要避免冲突，什么时候要向前迈一步，知道怎么使潜在的敌人成为盟友。</p><h3 id="9-Show-and-tell"><a href="#9-Show-and-tell" class="headerlink" title="9. Show and tell"></a>9. Show and tell</h3><p>Average Performers在做presentation的时候，关注点在讨好管理层，表现他们对工作的热爱，他们主要关注自己的形象和他们自己的信息，而不是听众。</p><p>Star Performers使用一系列技巧，包括选择某些信息传递给一些人，采用一种给有效、让人看起来舒服的格式呈现给特定的听众。更好以层次，Show-and-Tell要么是将正确的信息呈现给特定的人，要么是为正确的听众呈现特定的信息。</p><p>Star Performers能够将信息传递给目标听众，说服听众接收他们的信息，尽量避免冲突。</p>]]></content>
    
    
    <categories>
      
      <category>others</category>
      
    </categories>
    
    
    <tags>
      
      <tag>others</tag>
      
      <tag>life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01-Verilog and SystemVerilog Gotchas</title>
    <link href="/2019/12/18/books/Verilog%20and%20SystemVerilog%20Gotchas/01-Verilog%20and%20SystemVerilog%20Gotchas/"/>
    <url>/2019/12/18/books/Verilog%20and%20SystemVerilog%20Gotchas/01-Verilog%20and%20SystemVerilog%20Gotchas/</url>
    
    <content type="html"><![CDATA[<p><strong>gotcha 56 verifying asynchronous and synchronous reset ai time zero</strong> </p><p>initial和always块在zero time时候的执行顺序是不确定的。在zero time时，复位（复位沿发生在检测复位的逻辑之前或之后）或者时钟上升沿（上升沿发生在always语句之前或之后）可能出现不确定的执行结果。</p><p>特别时tb和dut之间信号的先后问题。</p><p>对于<strong>异步复位电路</strong>，如下所示，test模块中在0时刻有一个reset_n的下降沿（从x到0可以认作是个下降沿），所以我们期待的执行顺序是，chip  module中always先执行，遇到事件控制阻塞，然后chip module中的initial开始执行，产生一个reset_n的下降沿，此时激活chip中的always块语句。但实际中always和initial的顺序是不确定的。</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/books/Verilog%20and%20SystemVerilog%20Gotchas/56-1.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/books/Verilog%20and%20SystemVerilog%20Gotchas/56-2.png" alt="img"></p><p>异步复位的解决方法：</p><p>一、在initial中reset_n信号采用非阻塞赋值，这样reset_n的非阻塞赋值过程在所有的过程块激活之后才执行。</p><p>二、SV中的program块，program有验证语义，在SV的仿真队列中，先执行design的语句，然后才执行verification语句，所以chipmodule中的always先执行，test program中的initial后执行。</p><p>对于<strong>同步复位电路</strong>：在0时刻有一个时钟上升沿，期望在时钟上升沿之前，chip module中的always和test moduloe中的initial都执行了，这样在出现时钟上升沿的时候，always才会触发，if语句才会有效。</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/books/Verilog%20and%20SystemVerilog%20Gotchas/56-3.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/books/Verilog%20and%20SystemVerilog%20Gotchas/56-4.png" alt="img"></p><p>同步复位解决：</p><p>top module中的clock信号赋值采用非阻塞赋值，等待always 和initial都执行之后才赋值。</p><p>program并不能解决这个同步复位问题。</p><p><strong>gotcha 58</strong> <strong>Evaluation of equality with 4-state values</strong></p><p>全等、全不等是按位比较，也比较x和z。</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/books/Verilog%20and%20SystemVerilog%20Gotchas/58.png" alt="img"></p><p><strong>gotcha 59</strong>  <strong>Event trigger race conditions</strong></p><p>Verilog中的event竞争。</p><p>initial和always在0时刻执行顺序不确定导致，握手触发不能启动。</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/books/Verilog%20and%20SystemVerilog%20Gotchas/59-1.png" alt="img"></p><p>解决：#0 在所有的块语句激活之后再执行。<strong>但是不建议使用#0，会引起其他问题</strong>。</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/books/Verilog%20and%20SystemVerilog%20Gotchas/59-2.png" alt="img"></p><p>SV中的解决方法：</p><p>一、非阻塞的事件触发-&gt;&gt;，在当前仿真事件内延迟delta，等待其他的块语句都执行完了再执行，效果跟#0类似。</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/books/Verilog%20and%20SystemVerilog%20Gotchas/59-3.png" alt="img"></p><p>二、SV中有wait代替@，触发事件在wait语句之前后者之后发生都可以。</p><p>下面例子中，如果initial在always之前发生了，当always的wait语句执行时候，之前触发依旧可见。</p><p>用wait，事件触发在当前仿真事件的所哟阶段都是可见的。</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/books/Verilog%20and%20SystemVerilog%20Gotchas/59-4.png" alt="img"></p><p><strong>gotcha 60 using semaphores</strong></p><p>当get()请求不到所需要的keys的时候，比如请求4个keys，但此时semaphore中只有两个keys，进程会被阻塞，get()操作放到FIFO中。但是如果接下来另一个进程中的get()只请求1个keys，那么这个get()会被允许，这是不应该的。因为第二个get()操作在第一个get()操作之后，如下面的所示：</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/books/Verilog%20and%20SystemVerilog%20Gotchas/60.png" alt="img"></p><p>解决方法是：每个get()操作至请求一个key，这样只要有key available那么FIFO中第一个get()就被执行。</p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>books</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>Verilog and SystemVerilog Gotchas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV——generate constructs</title>
    <link href="/2019/10/22/Verification/SystemVerilog/SV%E2%80%94generate%20constructs/"/>
    <url>/2019/10/22/Verification/SystemVerilog/SV%E2%80%94generate%20constructs/</url>
    
    <content type="html"><![CDATA[<h3 id="0-介绍"><a href="#0-介绍" class="headerlink" title="0. 介绍"></a>0. 介绍</h3><p>​    generate构建是用来例化一个或者多个generate block；generate block可以是module item、一段语句或者嵌套的generate block。但不能有端口声明。</p><p>​    generate 调度是在elaboration阶段，而不是在simulation。generate scheme的结果在simulation之前就确定了。所有在generate scheme阶段的表达式都应该是常量表达式。</p><p>​    可以用generate……endgenerate关键字，当然也可以不用。</p><p>​    generate constructs有两种loop generate constructs 和conditional generate constructs。</p><h3 id="1-loop-generate-constructs"><a href="#1-loop-generate-constructs" class="headerlink" title="1. loop generate constructs"></a>1. loop generate constructs</h3><p>​    在循环生成中，一个generate block被重复生成多次。循环的索引变量应该被声明为<strong>genvar</strong>。</p><blockquote><p>  The genvar is used as an integer during elaboration to evaluate the generate loop and create instances of the generate block, but it does not exist at simulation time. A genvar shall not be referenced anywhere other than in a loop generate scheme.  </p></blockquote><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ol><li>嵌套的循环生成中，不同的generate的genvar变量名不能相同。</li><li>如果generate block被命名，那么名字不能和关键字、其他变量名重合，最好也不要和其他的block name重合。</li></ol><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// A parameterized gray-code–to–binary-code converter module using a loop to generate continuous assignments</span><br><span class="hljs-keyword">module</span> gray2bin1 (bin, gray);<br><span class="hljs-keyword">parameter</span> SIZE = <span class="hljs-number">8</span>; <span class="hljs-comment">// this module is parameterizable</span><br><span class="hljs-keyword">output</span> [SIZE-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] bin;<br><span class="hljs-keyword">input</span> [SIZE-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] gray;<br><span class="hljs-keyword">genvar</span> i;<br><span class="hljs-keyword">generate</span><br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;SIZE; i=i+<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>:bitnum<br>    <span class="hljs-keyword">assign</span> bin[i] = ^gray[SIZE-<span class="hljs-number">1</span>:i];<br>    <span class="hljs-comment">// i refers to the implicitly defined localparam whose</span><br>    <span class="hljs-comment">// value in each instance of the generate block is</span><br>    <span class="hljs-comment">// the value of the genvar when it was elaborated.</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endgenerate</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-keyword">module</span> addergen1 (co, sum, a, b, ci);<br><span class="hljs-keyword">parameter</span> SIZE = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">output</span> [SIZE-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] sum;<br><span class="hljs-keyword">output</span> co;<br><span class="hljs-keyword">input</span> [SIZE-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] a, b;<br><span class="hljs-keyword">input</span> ci;<br><span class="hljs-keyword">wire</span> [SIZE :<span class="hljs-number">0</span>] c;<br><span class="hljs-keyword">genvar</span> i;<br><span class="hljs-keyword">assign</span> c[<span class="hljs-number">0</span>] = ci;<br><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;SIZE; i=i+<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>:bitnum<br>    <span class="hljs-keyword">wire</span> t1, t2, t3;<br>    <span class="hljs-keyword">xor</span> g1 ( t1, a[i], b[i]);<br>    <span class="hljs-keyword">xor</span> g2 ( sum[i], t1, c[i]);<br>    <span class="hljs-keyword">and</span> g3 ( t2, a[i], b[i]);<br>    <span class="hljs-keyword">and</span> g4 ( t3, t1, c[i]);<br>    <span class="hljs-keyword">or</span> g5 ( c[i+<span class="hljs-number">1</span>], t2, t3);<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">assign</span> co = c[SIZE];<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h3 id="2-conditional-generate-constructs"><a href="#2-conditional-generate-constructs" class="headerlink" title="2. conditional generate constructs"></a>2. conditional generate constructs</h3><blockquote><p>  The conditional generate constructs, if-generate and case-generate, select at most one generate block from a set of alternative generate blocks based on constant expressions evaluated during elaboration.  </p></blockquote><p>​        可以通过if–else、case来进行条件判断。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// 通过if--else判断</span><br><span class="hljs-keyword">module</span> multiplier(a,b,product);<br><span class="hljs-keyword">parameter</span> a_width = <span class="hljs-number">8</span>, b_width = <span class="hljs-number">8</span>;<br><span class="hljs-keyword">localparam</span> product_width = a_width+b_width;<br><span class="hljs-comment">// cannot be modified directly with the defparam</span><br><span class="hljs-comment">// statement or the module instance statement #</span><br><span class="hljs-keyword">input</span> [a_width-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] a;<br><span class="hljs-keyword">input</span> [b_width-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] b;<br><span class="hljs-keyword">output</span> [product_width-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] product;<br><span class="hljs-keyword">generate</span><br>    <span class="hljs-keyword">if</span>((a_width &lt; <span class="hljs-number">8</span>) || (b_width &lt; <span class="hljs-number">8</span>)) <span class="hljs-keyword">begin</span>: mult<br>    CLA_multiplier <span class="hljs-variable">#(a_width,b_width) u1(a, b, product)</span>;<br>    <span class="hljs-comment">// instantiate a CLA multiplier</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>: mult<br>    WALLACE_multiplier <span class="hljs-variable">#(a_width,b_width) u1(a, b, product)</span>;<br>    <span class="hljs-comment">// instantiate a Wallace-tree multiplier</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endgenerate</span><br><span class="hljs-comment">// The hierarchical instance name is mult.u1</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-comment">// 通过case判断</span><br><span class="hljs-keyword">generate</span><br>    <span class="hljs-keyword">case</span> (WIDTH)<br>        <span class="hljs-number">1</span>: <span class="hljs-keyword">begin</span>: adder <span class="hljs-comment">// 1-bit adder implementation</span><br>        adder_1bit x1(co, sum, a, b, ci);<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-number">2</span>: <span class="hljs-keyword">begin</span>: adder <span class="hljs-comment">// 2-bit adder implementation</span><br>        adder_2bit x1(co, sum, a, b, ci);<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">begin</span>: adder <span class="hljs-comment">// others - carry look-ahead adder</span><br>            adder_cla <span class="hljs-variable">#(WIDTH) x1(co, sum, a, b, ci)</span>;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">endcase</span><br><span class="hljs-comment">// The hierarchical instance name is adder.x1</span><br><span class="hljs-keyword">endgenerate</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV——automatic</title>
    <link href="/2019/09/27/Verification/SystemVerilog/SV%E2%80%94%E2%80%94automatic%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2019/09/27/Verification/SystemVerilog/SV%E2%80%94%E2%80%94automatic%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p>IEEE 1800 <strong>6.21 Scope and lifetime</strong> </p><h3 id="1-SV中变量存储"><a href="#1-SV中变量存储" class="headerlink" title="1. SV中变量存储"></a>1. SV中变量存储</h3><ol><li>Variables declared <strong>outside</strong> a <strong>module, program, interface, checker, task, or function</strong> are local to the</li></ol><p>compilation unit and <strong>have a static lifetime (exist for the whole simulation).</strong> </p><div class="code-wrapper"><pre><code class="hljs">2. Variables declared **inside** a module, interface, program, or checker, but **outside** a task, process, or function, are local in scope（局部有效） and **have a static lifetime**.  3. Variables declared **inside** a static task, function, or block are local in scope and default to a **static lifetime.** 4. Tasks and functions may be declared as **automatic**. Variables declared in an automatic task, function, or block are local in scope, **default to the lifetime of the call or block（automatic类型的变量的生存周期是函数调用时间或者块语句的生存周期）,** **and are initialized on each entry to the call or block。** 5. An **automatic block** is one in which declarations are automatic by default. Specific variables within an automatic task, function, or block can be explicitly declared as static. Such variables have a static lifetime. </code></pre></div><p>​    上面前三条是一个意思，<strong>变量都是存在静态存储区，如果有多个线程同时调用任务或者函数，任务或函数内地变量是共享的，这样会发生问题。</strong></p><p>​    后面两条是一个意思，变量存在动态存储区，<strong>每次对任务或者函数的调用都会分配动态存储区域来存储变量，任务或者函数执行完，自动释放动态存储区。</strong></p><p>1800中的例子</p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_legal;<br><span class="hljs-keyword">int</span> svar1 = <span class="hljs-number">1</span>; <span class="hljs-comment">// static keyword optional</span><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">3</span>; i++) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">automatic</span> <span class="hljs-keyword">int</span> loop3 = <span class="hljs-number">0</span>; <span class="hljs-comment">// executes every loop</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">3</span>; j++) <span class="hljs-keyword">begin</span><br>        loop3++;<br>        <span class="hljs-built_in">$display</span>(loop3);<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span> <span class="hljs-comment">// prints 1 2 3 1 2 3 1 2 3</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">3</span>; i++) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> loop2 = <span class="hljs-number">0</span>; <span class="hljs-comment">// executes once at time zero</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">3</span>; j++) <span class="hljs-keyword">begin</span><br>            loop2++;<br>            <span class="hljs-built_in">$display</span>(loop2);<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span> <span class="hljs-comment">// prints 1 2 3 4 5 6 7 8 9</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span> : top_legal<br><br><span class="hljs-keyword">module</span> top_illegal; <span class="hljs-comment">// should not compile</span><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">int</span> svar2 = <span class="hljs-number">2</span>; <span class="hljs-comment">// static/automatic needed to show intent</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">3</span>; i++) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">int</span> loop3 = <span class="hljs-number">0</span>; <span class="hljs-comment">// illegal statement </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">3</span>; i++) <span class="hljs-keyword">begin</span><br>            loop3++;<br>            <span class="hljs-built_in">$display</span>(loop3);<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span> : top_illegal<br><span class="hljs-comment">// 其实int loop3=2，不加static也不加automatic输出是 1 2 3 1 2 3 1 2 3；不知道上面为什么说是illegal statement</span><br></code></pre></td></tr></table></figure><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>​    <strong>Class methods</strong> (see Clause 8) and declared <strong>for</strong> <strong>loop</strong> variables (see 12.7.1) are by default <strong>automatic</strong>, </p><p>regardless of the lifetime attribute of the scope in which they are declared. </p><p>​    类方法和for循环中的变量默认类型就是automatic，这应该也就是上面为什么不加automatic也输出1 2 3 1 2 3 1 2 3的原因吧。    </p><p>​    在SV中的方法，如果是ref类型，那么必须是automatic方法。</p>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV——extern virtual function</title>
    <link href="/2019/09/27/Verification/SystemVerilog/SV%E2%80%94%E2%80%94extern%20virtual%20function/"/>
    <url>/2019/09/27/Verification/SystemVerilog/SV%E2%80%94%E2%80%94extern%20virtual%20function/</url>
    
    <content type="html"><![CDATA[<p>如果在class 中对virtual function使用了extern声明，如下：</p><p>class base_test extends uvm_test;</p><p>extern virtual function void build_phase(uvm_phase(phase);</p><p>endclass</p><p>那么要在class之后定义这个virtual function的实体，如下：</p><p>function void build_phase(uvm_phase phae); ….. endfunction</p><p>在virtual function实体中，不能再加virtual 和 extern关键了；加任意一个都会编译报错。</p>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV——override</title>
    <link href="/2019/09/27/Verification/SystemVerilog/SV%E2%80%94%E2%80%94override/"/>
    <url>/2019/09/27/Verification/SystemVerilog/SV%E2%80%94%E2%80%94override/</url>
    
    <content type="html"><![CDATA[<h3 id="0-介绍"><a href="#0-介绍" class="headerlink" title="0. 介绍"></a>0. 介绍</h3><p>SV中引入OPP，也会有类似于C++里的override和overload考虑。</p><h3 id="1-override-重写"><a href="#1-override-重写" class="headerlink" title="1. override 重写"></a>1. override 重写</h3><p>重写有数据成员重写和方法重写，看下面例子</p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// 来源 IEEE1800 8.14节</span><br><span class="hljs-keyword">class</span> Packet;<br>    <span class="hljs-keyword">integer</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">integer</span> get();<br>    get = i;<br>    <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br><span class="hljs-keyword">class</span> LinkedPacket <span class="hljs-keyword">extends</span> Packet;<br>    <span class="hljs-keyword">integer</span> i = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">integer</span> get();<br>    get = -i;<br>    <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br>LinkedPacket lp = <span class="hljs-keyword">new</span>;<br>Packet p = lp;<br>j = p<span class="hljs-variable">.i</span>; <span class="hljs-comment">// j = 1, not 2 // 父类成员</span><br>j = p<span class="hljs-variable">.get</span>(); <span class="hljs-comment">// j = 1, not -1 or –2</span><br></code></pre></td></tr></table></figure><p><strong>从上面看出，父类句柄指向的数据成员是父类的成员。</strong></p><p><strong>如果想通过父类句柄调用子类中重写的成员函数，那么需要将父类中的函数定义成virtual类型。</strong></p><h3 id="2-重载-overload"><a href="#2-重载-overload" class="headerlink" title="2. 重载 overload"></a>2. 重载 overload</h3><p>在SV中好像不支持重载（overload），就是不直接支持方法类型相同，参数不同。</p><p><strong>在下面例子中，SV检查到B中的dis函数与A中的dis函数返回类型不同，会报错。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> A;<br>  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">int</span> dis(<span class="hljs-keyword">string</span> str=<span class="hljs-string">&quot;A&quot;</span>);<br>    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;this is %s&quot;</span>,str);<br>    dis=<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">class</span> B <span class="hljs-keyword">extends</span> A;<br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> dis(); <span class="hljs-comment">// 只有函数名相同</span><br>      <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;this is B&quot;</span>);<br>    <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br>A a;<br>B b;<br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>  b=<span class="hljs-keyword">new</span>;<br>  b<span class="hljs-variable">.dis</span>();<br>    b<span class="hljs-variable">.dis</span>(<span class="hljs-string">&quot;B&quot;</span>); <span class="hljs-comment">//在调用的时候，SV会把B的dis当作A中dis的override来处理，句柄b调用的是B中的dis。</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">// 报错：</span><br>Error-[SV-IRT] Incompatible <span class="hljs-keyword">return</span> types<br>./svt<span class="hljs-variable">.sv</span>, <span class="hljs-number">108</span><br>svt, <span class="hljs-string">&quot;dis&quot;</span><br>  Definition of <span class="hljs-keyword">class</span> <span class="hljs-keyword">function</span> &#x27;A::dis&#x27; does <span class="hljs-keyword">not</span> have the same <span class="hljs-keyword">return</span> <span class="hljs-keyword">type</span> as <br>  mentioned in the declaration at: <span class="hljs-string">&quot;./svt.sv&quot;</span>, <span class="hljs-number">97</span>.<br><br>Error-[TMAFTC] Too many arguments to <span class="hljs-keyword">function</span>/<span class="hljs-keyword">task</span> call<br>./svt<span class="hljs-variable">.sv</span>, <span class="hljs-number">116</span><br><span class="hljs-string">&quot;b.dis(&quot;</span>B<span class="hljs-string">&quot;)&quot;</span><br>  The above <span class="hljs-keyword">function</span>/<span class="hljs-keyword">task</span> call is done <span class="hljs-keyword">with</span> more arguments than needed.<br></code></pre></td></tr></table></figure><h3 id="3-override的条件"><a href="#3-override的条件" class="headerlink" title="3. override的条件"></a>3. override的条件</h3><p>子类想要正确地override父类中的虚函数，需要保证以下四点：</p><ol><li>函数才能重载函数。</li><li>函数名相同</li><li>返回类型相同</li><li>参数列表相同</li></ol><p>子类中要正确重载父类中的虚任务，需要保证以下三点：</p><ol><li>任务才能重载任务。</li><li>任务名相同。</li><li>参数列表相同。</li></ol><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// 任务被函数重载了，会出错</span><br><span class="hljs-keyword">program</span> <span class="hljs-keyword">automatic</span> test;<br>    <span class="hljs-keyword">class</span> A;<br>        <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> dis(<span class="hljs-keyword">string</span> str=<span class="hljs-string">&quot;&quot;</span>);<br>          <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;this is A&quot;</span>);<br>        <span class="hljs-keyword">endtask</span><br>    <span class="hljs-keyword">endclass</span><br><br>    <span class="hljs-keyword">class</span> B <span class="hljs-keyword">extends</span> A;<br>        <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> dis(<span class="hljs-keyword">string</span> str=<span class="hljs-string">&quot;&quot;</span>);<br>          <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;this is B&quot;</span>);<br>        <span class="hljs-keyword">endfunction</span><br>    <span class="hljs-keyword">endclass</span><br>    A a;<br>    B b;<br>    <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>      b=<span class="hljs-keyword">new</span>;<br>      b<span class="hljs-variable">.dis</span>();<br>      a=b;<br>      a<span class="hljs-variable">.dis</span>();<br>      a<span class="hljs-variable">.dis</span>(<span class="hljs-string">&quot;A&quot;</span>);<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endprogram</span><br><span class="hljs-comment">// 报错：</span><br>Error-[SV-ICMO] Illegal <span class="hljs-keyword">class</span> method override<br>./svt<span class="hljs-variable">.sv</span>, <span class="hljs-number">100</span><br>  Virtual <span class="hljs-keyword">task</span> &#x27;dis&#x27; cannot be overridden <span class="hljs-keyword">with</span> a <span class="hljs-keyword">function</span>.<br>  Virtual method declared at <span class="hljs-string">&quot;./svt.sv&quot;</span>, <span class="hljs-number">100</span><br>  Overriden at <span class="hljs-string">&quot;./svt.sv&quot;</span>, <span class="hljs-number">111</span><br></code></pre></td></tr></table></figure><h3 id="4-new可以被override吗"><a href="#4-new可以被override吗" class="headerlink" title="4. new可以被override吗"></a>4. new可以被override吗</h3><p>之前面试被问到new函数可以重载吗？</p><p>在UVM UG1.1 P62页顶部提到”there are limitations on overriding new() in object-oriented language such as System Verilog.”这好像说明了new是可以重载的，但是有一些限制。</p>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV——static</title>
    <link href="/2019/09/27/Verification/SystemVerilog/SV%E2%80%94%E2%80%94static/"/>
    <url>/2019/09/27/Verification/SystemVerilog/SV%E2%80%94%E2%80%94static/</url>
    
    <content type="html"><![CDATA[<h3 id="static-class-property"><a href="#static-class-property" class="headerlink" title="static class property"></a>static class property</h3><p>如果变量需要在不同的对象中<strong>共享</strong>，那么可以把这个变成定义成静态变量。</p><p>静态变量在声明对象句柄的时候就分配内存空间。</p><p>The static class properties can be used without creating an object of that type. </p><figure class="highlight nginx"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">class</span> Packet ;<br><span class="hljs-attribute">static</span> integer fileID = <span class="hljs-variable">$fopen</span>( <span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-string">&quot;r&quot;</span> );<br><span class="hljs-attribute">Packet</span> p;<br><span class="hljs-attribute">c</span> = <span class="hljs-variable">$fgetc</span>( p.fileID );<br></code></pre></td></tr></table></figure><h3 id="static-class-method"><a href="#static-class-method" class="headerlink" title="static class method"></a>static class method</h3><p>​    <strong>A static method has no access to non-static members (class properties or methods),</strong>  but it can directly access static class properties or call static methods of the same class.</p><div class="code-wrapper"><pre><code class="hljs"> Access to non-static members or to the special **this** handle within the body of a static method is illegal and results in a compiler error. </code></pre></div><p>​     <strong>Static methods  cannot be virtual.</strong></p>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV——声明和例化</title>
    <link href="/2019/09/27/Verification/SystemVerilog/SV%E2%80%94%E2%80%94%E5%A3%B0%E6%98%8E%E5%92%8C%E4%BE%8B%E5%8C%96/"/>
    <url>/2019/09/27/Verification/SystemVerilog/SV%E2%80%94%E2%80%94%E5%A3%B0%E6%98%8E%E5%92%8C%E4%BE%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="1-class-constructor-—-new"><a href="#1-class-constructor-—-new" class="headerlink" title="1. class constructor —- new"></a>1. class constructor —- new</h3><p>SV中通过new构造函数来<strong>创建对象</strong>，在创建对象的过程中，可以做一些初始化工作。</p><p>new函数没有返回值，他的返回类型就是赋值表达式中左值的类型。</p><p>如果没有自己定义new函数，那么SV会调用默认的new函数；一个派生类的new函数会先调用父类的new函数。</p><h3 id="2-super"><a href="#2-super" class="headerlink" title="2. super"></a>2. super</h3><p>​    The <strong>super</strong> keyword is used from within a derived class to refer to members, class value parameters, or local value parameters of the base class（super关键字用来引用父类中的成员、参数等）. It is necessary to use <strong>super</strong> to access members, value parameters, or  local value parameters of a base class when those are overridden by the derived class（如果父类中的成员、参数被子类重载了，并且还想在子类中使用重载之前的父类的成员，那么要用super）。</p><p>​    但是super只能用一层，如果super.super.new()这种方式，不行。</p><p>​    A <strong>super</strong>.<strong>new</strong> call shall be the first statement executed in the constructor. This is because the <strong>superclass</strong> </p><p><strong>shall be initialized before the current class</strong> and, if the user code does not provide an initialization, the </p><p>compiler shall insert a call to <strong>super</strong>.<strong>new</strong> automatically. </p><p>​    <strong>super.new()会对父类中定义的成员初始化。</strong></p><h3 id="3-声明和例化"><a href="#3-声明和例化" class="headerlink" title="3. 声明和例化"></a>3. 声明和例化</h3><p><strong>声明是声明一个变量，其中保存类对象的句柄。</strong></p><p><strong>例化是通过构造函数，创建对象，分配内存空间，并将声明的句柄指向这段内存空间。</strong></p><p>​    虽然在SV中可以在声明的时候例化对象，但是不建议如此。一般是在块语句之外声明类对象，在块语句内例化对象；可以控制对象的实例化顺序。</p><h3 id="4-对象解除"><a href="#4-对象解除" class="headerlink" title="4. 对象解除"></a>4. 对象解除</h3><p>在SV中自动管理对象创建时分配的内存。SV会记住指向一段内存的句柄的数目，如果一段内存没有一个句柄指向它，那么它就会被自动释放掉。</p>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV——类型转换</title>
    <link href="/2019/09/27/Verification/SystemVerilog/SV%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2$cast/"/>
    <url>/2019/09/27/Verification/SystemVerilog/SV%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2$cast/</url>
    
    <content type="html"><![CDATA[<h3 id="0-介绍"><a href="#0-介绍" class="headerlink" title="0. 介绍"></a>0. 介绍</h3><p>在SV中类型转换有很多，在这里先将类型转换分成两种，静态类型转换和动态转换。</p><p>静态转换就是用cast operator——单引号（‘）。</p><p>动态转换用$cast。</p><h3 id="1-静态转换-static-cast（’）"><a href="#1-静态转换-static-cast（’）" class="headerlink" title="1. 静态转换 static cast（’）"></a>1. 静态转换 static cast（’）</h3><p>语法如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog">constant_cast ::= <span class="hljs-comment">// from A.8.4(来自1800)</span><br>casting_type &#x27; ( constant_expression )<br></code></pre></td></tr></table></figure><p>​    如果casting_type和表达式类型相同，那么会返回casting_type类型的值给到左值。如果类型不匹配，也会强行转换（string类型也会转换成int类型），但会出现问题：</p><ol><li><p>casting_type是枚举类型，转换可能出界。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;RED,BLUE,GREEN&#125; color_e;<br>color_e color;<br><span class="hljs-keyword">int</span> c;<br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>c=<span class="hljs-number">10</span>;<br>color=color_e&#x27;(c);<br><span class="hljs-keyword">end</span><br><br></code></pre></td></tr></table></figure><p>上面的转换会成功，color的值变成10，但这除了color_e这个枚举类型的界限了。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;RED,BLUE,GREEN&#125; COLOR_E;<br>COLOR_E color;<br><span class="hljs-keyword">int</span> c;<br><span class="hljs-keyword">string</span> str;<br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>  str=<span class="hljs-string">&quot;hh&quot;</span>;<br>  c=<span class="hljs-keyword">int</span>&#x27;(str);<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;c is %0d&quot;</span>,c);<br>  c=<span class="hljs-number">1</span>;<br>  color=COLOR_E&#x27;(c);<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;Color is %d / %s&quot;</span>,color,color<span class="hljs-variable">.name</span>);<br>  c=<span class="hljs-number">3</span>;<br>  color=COLOR_E&#x27;(c);<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;Color is %d / %s&quot;</span>,color,color<span class="hljs-variable">.name</span>);<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">// 输出</span><br>c is <span class="hljs-number">26728</span>     <br>Color is           <span class="hljs-number">1</span> / BLUE<br>Color is           <span class="hljs-number">3</span> / <br></code></pre></td></tr></table></figure><p>从上面输出可以看出string类型转换成了int值；第二个color越界了。</p></li><li><p>casting_type是bit_stream type。</p><p>比特流类型先不整理了，没遇到过，在1800 6.24.3节，如果以后遇到再看吧。</p></li></ol><h3 id="2-动态转换（-cast）"><a href="#2-动态转换（-cast）" class="headerlink" title="2. 动态转换（$cast）"></a>2. 动态转换（$cast）</h3><p><strong>上面static cast不会检查表达式的类型，可能会发生string转换成int，枚举越界等问题。</strong></p><p>动态转换$cast可以作为function，也可以作为task（这个问题地平线一面的时候被问过，$cast是函数还是任务），语法如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">int</span> <span class="hljs-built_in">$cast</span>( singular dest_var, singular source_exp );<br><span class="hljs-keyword">or</span><br><span class="hljs-keyword">task</span> <span class="hljs-built_in">$cast</span>( singular dest_var, singular source_exp );<br></code></pre></td></tr></table></figure><p>​    Use of $cast as either a task or a function determines how invalid assignments are handled.</p><p>​    <strong>When called as a task</strong>, $cast attempts to assign the source expression to the destination variable. If the </p><p>assignment is invalid, <strong>a run-time error occurs, and the destination variable is left unchanged.</strong> </p><p>​    <strong>When called as a function</strong>, $cast attempts to assign the source expression to the destination variable and <strong>returns 1 if the cast is legal. If the cast fails, the function does not make the assignment and returns 0. When called as a function, no run-time error occurs, and the destination variable is left unchanged.</strong> </p><p>​    It is important to note that $cast performs a <strong>run-time check. No type checking is done by the compiler,</strong> except to check that the destination variable and source expression are singulars. </p><p>至于$cast是作为function还是task，主要看$cast使用的语境是否需要返回值。</p><h4 id="cast作为function"><a href="#cast作为function" class="headerlink" title="$cast作为function"></a>$cast作为function</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;RED,BLUE,GREEN&#125; COLOR_E;<br>COLOR_E color;<br><span class="hljs-keyword">int</span> c;<br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>  c=<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">$cast</span>(color,c))<br>    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;cast failed for c=%0d&quot;</span>,c);<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;Color is %d / %s&quot;</span>,color,color<span class="hljs-variable">.name</span>);<br>  c=<span class="hljs-number">3</span>;<br>  <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">$cast</span>(color,c))<br>    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;cast failed for c=%0d&quot;</span>,c);<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;Color is %d / %s&quot;</span>,color,color<span class="hljs-variable">.name</span>);<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">// 输出</span><br>Color is           <span class="hljs-number">1</span> / BLUE<br>cast failed <span class="hljs-keyword">for</span> c=<span class="hljs-number">3</span><br>Color is           <span class="hljs-number">1</span> / BLUE<br></code></pre></td></tr></table></figure><p>第二次$cast失败之后，color的值不变。</p><h4 id="cast作为task"><a href="#cast作为task" class="headerlink" title="$cast作为task"></a>$cast作为task</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;RED,BLUE,GREEN&#125; COLOR_E;<br>COLOR_E color;<br><span class="hljs-keyword">int</span> c;<br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>  c=<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">$cast</span>(color,c))<br>    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;cast failed for c=%0d&quot;</span>,c);<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;Color is %d / %s&quot;</span>,color,color<span class="hljs-variable">.name</span>);<br>  c=<span class="hljs-number">3</span>;<br>    <span class="hljs-built_in">$cast</span>(color,c); <span class="hljs-comment">// 作为任务，没有返回值的语境</span><br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;Color is %d / %s&quot;</span>,color,color<span class="hljs-variable">.name</span>);<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">// 会报错</span><br>Error-[STASKE_DCF] Dynamic cast failed<br>./svt<span class="hljs-variable">.sv</span>, <span class="hljs-number">108</span><br>  Dynamic cast using &#x27;<span class="hljs-built_in">$cast</span>&#x27; failed. The source expression is <span class="hljs-keyword">not</span> yielding a <br>  valid value <span class="hljs-keyword">for</span> the destination variable.<br></code></pre></td></tr></table></figure><p><strong>$cast先进行类型判断，再转化。</strong></p><h3 id="3-其他类型转换"><a href="#3-其他类型转换" class="headerlink" title="3. 其他类型转换"></a>3. 其他类型转换</h3><p>在IEEE 1800的20.5节中，还介绍了一些integer2string或者signed2unsigned的函数</p><p><strong>$itor</strong> converts integer values to real values (for example, 123 becomes 123.0). </p><p><strong>$realtobits</strong> converts values from a <strong>real</strong> type to a 64-bit vector representation of the real number.  </p><p><strong>$bitstoreal</strong> converts a bit pattern created by $realtobits to a value of the <strong>real</strong> type.  </p><p><strong>$shortrealtobits</strong> converts values from a <strong>shortreal</strong> type to the 32-bit vector representation of the real  number.  </p><p><strong>$bitstoshortrea</strong>l converts a bit pattern created by $shortrealtobits to a value of the <strong>shortreal</strong> type</p><p><strong>$signed</strong>—returned value is signed  </p><p><strong>$unsigned</strong>—returned value is unsigned</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> driver (net_r); <br><span class="hljs-keyword">output</span> [<span class="hljs-number">64</span>:<span class="hljs-number">1</span>] net_r; <br><span class="hljs-keyword">real</span> r; <br><span class="hljs-keyword">wire</span> [<span class="hljs-number">64</span>:<span class="hljs-number">1</span>] net_r = <span class="hljs-built_in">$realtobits</span>(r); <br><span class="hljs-keyword">endmodule</span><br><span class="hljs-keyword">module</span> receiver (net_r); <br><span class="hljs-keyword">wire</span> [<span class="hljs-number">64</span>:<span class="hljs-number">1</span>] net_r; <br><span class="hljs-keyword">input</span> [<span class="hljs-number">64</span>:<span class="hljs-number">1</span>] net_r; <br><span class="hljs-keyword">real</span> r; <br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">assign</span> r = <span class="hljs-built_in">$bitstoreal</span>(net_r);<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跨时钟域传递数据实例</title>
    <link href="/2019/09/15/IC/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E5%AE%9E%E4%BE%8B/"/>
    <url>/2019/09/15/IC/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E5%AE%9E%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="0-介绍"><a href="#0-介绍" class="headerlink" title="0. 介绍"></a>0. 介绍</h3><p>　　跨时钟域传递的方法，Cummings的论文（见附录）中讲的很详细，之前自己也详细看过，除了他的论文还从网上看了一些其他人讲的关于跨时钟域的东西，以为自己已经掌握了跨时钟域的基本方法，面试、笔试完全不虚了，但是呢，前几天去某AI芯片公司二面，在跨时钟域问题上露怯，当然，面试过程全程被吊打，早已懵逼。</p><p>　　问题是：有一个APB接口的计数器IP，CPU可以通过写数据，控制计数器技术到5或者10等等任意数，但是写数据和计数器接受数据的时钟是异步的，并且希望在计数器最大值切换的时候，当前计数结束才可以切换，比如最大值为10，计数到6的时候来了一个新值5，必须计数到10之后，才能替换成5，应该怎么实现这个功能，根据APB的接口具体说一下信号都是怎么给的？</p><h3 id="1-方法"><a href="#1-方法" class="headerlink" title="1. 方法"></a>1. 方法</h3><p>　　当时他提示我用握手信号，但我不太敢说，当时又想到通过握手信号来解决，但没有给出让他满意的方案，现在想想CPU可以将写的数据和一bit的valid信号打包成一个数据，最高位是valid信号，其他位是要写的数据，CPU先将要写的数据放到pwdata上，下一个时钟周期再让valid有效，计数器IP采样到写入的数据并保存起来，当前计数结束的时候，加载新的计数值，之后计数器IP通过prdata给CPU发一个应答信号。</p><h3 id="2-分析"><a href="#2-分析" class="headerlink" title="2. 分析"></a>2. 分析</h3><p>　　一开始CPU将数据放到pwdata上，待数据稳定后将pwdata最高位的valid拉高，计数器IP通过两级寄存器采样valid信号，这里可能采样出现亚稳态，采样到0，但这不影响功能，只是会使采样延迟一个周期而已。接着计数器将新的计数值保存下来，待当前计数结束之后加载新的计数值。然后通过prdata将应答传给CPU。</p><p>　　这样的话似乎可以实现所需要的功能。　</p><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>\1. Synthesis and Scripting Techniques for Designing MultiAsynchronous Clock Designs</p><p>\2. Simulation and Synthesis Techniques for Asynchronous FIFO Design</p><p>\3. Simulation and Synthesis Techniques for Asynchronous FIFO Design with Asynchronous Pointer Comparisons</p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>Asynchronous</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>Asynchronous</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DMA</title>
    <link href="/2019/09/14/IC/IC_Architecture/DMA/"/>
    <url>/2019/09/14/IC/IC_Architecture/DMA/</url>
    
    <content type="html"><![CDATA[<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>个人整理，有误无责。</p><h3 id="0-CPU控制的数据传输方式介绍"><a href="#0-CPU控制的数据传输方式介绍" class="headerlink" title="0. CPU控制的数据传输方式介绍"></a>0. CPU控制的数据传输方式介绍</h3><p>由CPU控制的数据传输方式有两种：查询、中断。</p><h4 id="0-1-查询方式"><a href="#0-1-查询方式" class="headerlink" title="0.1 查询方式"></a>0.1 查询方式</h4><p>​    查询方式是由程序控制的，如果CPU中执行的程序需要进行数据传输，CPU查询外设状态，如果外设准备好，那么进行数据传输。</p><h4 id="0-2-中断方式"><a href="#0-2-中断方式" class="headerlink" title="0.2 中断方式"></a>0.2 中断方式</h4><p>​    当外设需要与CPU进行数据交换的时候，外设向CPU发出中断请求，CPU中断当前执行的程序，相应外设的数据传输请求。当外设的数据传输结束后，CPU继续执行被中断的程序.</p><p>上面两种方式，数据都需经过CPU来传递，下面介绍DMA控制的数据传递。</p><h3 id="1-DMA介绍"><a href="#1-DMA介绍" class="headerlink" title="1. DMA介绍"></a>1. DMA介绍</h3><p>​    DMA方式，Direct Memory Access，也称为成组数据传送方式，有时也称为直接内存操作。DMA方式在数据传送过程中，没有保存现场、恢复现场之类的工作。</p><p>​    由于CPU根本不参加传送操作，因此就省去了CPU取指令、取数、送数等操作。内存地址修改、传送字 个数的计数等等，也不是由软件实现，而是用硬件线路直接实现的。所以DMA方式能满足高速I&#x2F;O设备的要求，也有利于CPU效率的发挥。（参考自百度）</p><p>​    </p><h3 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h3><p>​    直接存储器存取(DMA)用来提供在外设和存储器之间或者存储器和存储器之间的高速数据传 输。无须CPU干预，数据可以通过DMA快速地移动，这就节省了CPU的资源来做其他操作。</p><p>​    一个设备如果需要直接通过总线与内存进行数据传送，设备先通过DMA向CPU发送DMA请求（DMA接管总线），CPU接到请求信号后，在当前时钟周期结束后，CPU会根据DMA信号的优先级和请求的先后顺序来相应DMA请求。CPU相应DAM请求后，会让出总线的控制权，让DMA来控制总线。在DMA的管理下，外设和内存直接进行数据交换，不需要CPU的干预，数据传输结束之后，DMA将总线的控制权交给CPU。</p><h3 id="3-DMA传输的特点"><a href="#3-DMA传输的特点" class="headerlink" title="3. DMA传输的特点"></a>3. DMA传输的特点</h3><p>（来自百度百科）</p><p>​    DMA 是所有现代电脑的重要特色，他允许不同速度的硬件装置来沟通，而不需要依于 CPU 的大量中断负载。<strong>否则，CPU 需要从 来源 把每一片段的资料复制到暂存器，然后把他们再次写回到新的地方。在这个时间中，CPU 对于其他的工作来说就无法使用。</strong></p><p>​    DMA 传输将一个内存区从一个装置复制到另外一个， CPU 初始化这个传输动作，传输动作本身是由 DMA控制器来实行和完成。典型的例子就是移动一个外部内存的区块到芯片内部更快的内存去。像是这样的操作并没有让处理器工作拖延，反而可以被重新排程去处理其他的工作。DMA 传输对于高效能嵌入式系统算法和网络是很重要的。</p><p>​    举个例子，PC ISA DMA控制器拥有 8 个 DMA 通道，其中的 7 个通道是可以让 PC 的 CPU 所利用。每一个 DMA 通道有一个 16位元 位址暂存器和一个 16 位元计数暂存器。要初始化资料传输时，装置驱动程式一起设定 DMA 通道的位址和计数暂存器，以及资料传输的方向，读取或写入。然后指示 DMA 硬件开始这个传输动作。当传输结束的时候，装置就会以中断的方式通知 CPU。</p><p>​    但是，DMA传输方式只是减轻了CPU的工作负担；系统总线仍然被占用。<strong>特别是在传输大容量文件时，CPU的占用率可能不到10%，但是用户会觉得运行部分程序时系统变得相当的缓慢。</strong>主要原因就是在运行这些应用程序（特别是一些大型软件），操作系统也需要从系统总线传输大量数据；<strong>故造成过长的等待时间。</strong></p><h3 id="4-基本操作"><a href="#4-基本操作" class="headerlink" title="4. 基本操作"></a>4. 基本操作</h3><ol><li>外设通过DMAC向CPU发送DMA请求</li><li>CPU相应DMA请求，DMA获得总线的控制权</li><li>由DMAC发送存储器的地址，并决定发送数据块的长度。</li><li>执行DMA传输。</li><li>DMA操作结束，把总线的控制权交还给CPU。</li></ol><h3 id="5-总线控制权问题"><a href="#5-总线控制权问题" class="headerlink" title="5. 总线控制权问题"></a>5. 总线控制权问题</h3><p>在DMA控制总线进行数据传输的时候，CPU是不占用总线的，如果此时其他外设或者程序需要CPU做其他一些事情怎么办？这就涉及到总线使用权的问题。</p><h4 id="5-1-停止CPU访问内存"><a href="#5-1-停止CPU访问内存" class="headerlink" title="5.1 停止CPU访问内存"></a>5.1 停止CPU访问内存</h4><p>当外设请求DMA控制发送一段数据的时候，CPU放弃对总线的控制权，直到这一组数据发送完，CPU再接管总线。</p><p>优点：控制简单</p><p>缺点：在DMA访存阶段，会浪费一些内存周期，这是因为内存的存储周期一般是小于IO设备发送两个数据的时间间隔。</p><h4 id="5-2-周期挪用"><a href="#5-2-周期挪用" class="headerlink" title="5.2 周期挪用"></a>5.2 <strong>周期挪用</strong></h4><p>​    （来源于百度百科）</p><p>​    当I&#x2F;O设备没有DMA请求时，CPU按程序要求访问内存；一旦I&#x2F;O设备有DMA请求，则由I&#x2F;O设备挪用一个或几个内存周期。</p><p>I&#x2F;O设备要求DMA传送时可能遇到两种情况：</p><p>（1）此时CPU不需要访内，如CPU正在执行乘法指令。由于乘法指令执行时间较长，此时I&#x2F;O访内与CPU访内没有冲突，即I&#x2F;O设备挪用一二个内存周期对CPU执行程序没有任何影响。</p><p>（2）I&#x2F;O设备要求访内时CPU也要求访内，这就产生了访内冲突，在这种情况下I&#x2F;O设备访内优先，因为I&#x2F;O访内有时间要求，前一个I&#x2F;O数据必须在下一个访内请求到来之前存取完毕。显然，在这种情况下I&#x2F;O设备挪用一二个内存周期，意味着CPU延缓了对指令的执行，或者更明确地说，在CPU执行访内指令的过程中插入DMA请求，挪用了一二个内存周期。</p><p>​    与停止CPU访内的DMA方法比较，周期挪用的方法既实现了I&#x2F;O传送，又较好地发挥了内存和CPU的效率，是一种广泛采用的方法。但是I&#x2F;O设备每一次周期挪用都有申请总线控制权、建立总线控制权和归还总线控制权的过程，所以传送一个字对内存来说要占用一个周期，但对DMA控制器来说一般要2—5个 内存周期（视逻辑线路的延迟而定）。因此，周期挪用的方法适用于I&#x2F;O设备读写周期大于内存存储周期的情况。</p><h4 id="5-3-DMA与CPU交替访内"><a href="#5-3-DMA与CPU交替访内" class="headerlink" title="5.3 DMA与CPU交替访内"></a>5.3 <strong>DMA与CPU交替访内</strong></h4><p>​        如果CPU的工作周期比内存存取周期长很多，此时采用交替访内的方法可以使DMA传送和CPU同时发挥最高的效率。假设CPU工作周期为 1.2μs，内存存取周期小于0.6μs，那么一个CPU周期可分为C1和C2两个分周期，其中C1供DMA控制器访内，C2专供CPU访内。</p><p>​        这种方式不需要总线使用权的申请、建立和归还过程，总线使用权是通过C1和C2分时进行的。CPU和DMA控制器各自有自己的访内地址寄存器、数据寄存 器和读&#x2F;写信号等控制寄存器。在C1周期中，如果DMA控制器有访内请求，可将地址、数据等信号送到总线上。在C2周期中，如CPU有访内请求，同样传送 地址、数据等信号。事实上，对于总线，这是用C1，C2控制的一个多路转换器，这种总线控制权的转移几乎不需要什么时间，所以对DMA传送来讲效率是很高的。</p><h3 id="6-工作过程"><a href="#6-工作过程" class="headerlink" title="6. 工作过程"></a>6. 工作过程</h3><p>DMA的工作过程主要分为三步：预处理阶段、数据传送、传送后处理。</p><h4 id="6-1-预处理阶段"><a href="#6-1-预处理阶段" class="headerlink" title="6.1 预处理阶段"></a><strong>6.1 预处理阶段</strong></h4><p>​    测试设备状态；向DMA控制器的设备地址寄存器中送入设备号，并启动设备；向主存地址计数器中送入欲交换数据的主存起始地址；向字计数器中送入欲交换的数据个数 。</p><p>​    外部设备准备好发送的数据（输入）或上次接收的数据已处理完毕（输出）时，将通知DMA控制器发出DMA请求，申请主存总线。</p><h4 id="6-2-数据传送"><a href="#6-2-数据传送" class="headerlink" title="6.2 数据传送"></a>6.2 数据传送</h4><p>​    DMA的数据传输可以以单字节(或字)为基本单位，对于以数据块为单位的传送(如银盘)，DMA占用总线后的数据输入和输出操作都是通过循环来实现。需要特别之处的是，这一循环也是由DMA控制器(而不是通过CPU执行程序)实现的，即数据传送阶段是完全由DMA(硬件)来控制的。</p><h4 id="6-4-处理"><a href="#6-4-处理" class="headerlink" title="6.4 处理"></a>6.4 处理</h4><p>​    DMA控制器向CPU发送中断请求，CPU执行中断服务程序做DMA结束处理，包括检验送入主存的数据是否正确，测试传送过程中是否出错(错误则转入诊断程序)和决定是否继续使用DMA传送其他数据块等。</p><h4 id="7-为什么DMA传输速度快"><a href="#7-为什么DMA传输速度快" class="headerlink" title="7. 为什么DMA传输速度快"></a>7. 为什么DMA传输速度快</h4><p>​    外设与计算机内存之间的信息交换，可通过程序查询方式和中断方式进行。这两种方式都是在CPU的控制下，通过CPU执行指令来完成的。数据传送方向为外设→CPU→内存。这两种方式每传送一个字节都需要耗用较长时间。在程序查询方式时，CPU要反复测试外设状态，在外设未准备好时，CPU就处于等待状态，直到外设准备好，才进行数据传送。在中断方式下，每实现一次数据传送，CPU都要进行转入中断服务子程序、保护断点、保护现场、恢复现场、返回主程序等操作。显然对于高速的I&#x2F;O设备以及大量数据交换的场合(如软、硬磁盘等)，这两种传送方式就不能满足速度的要求了。对于这些高速外设，如果传送速度太慢，不仅降低传送效率，还会造成数据丢失，导致传送出错。 为此，提出了DMA(直接存储器存取)传输方式。这种传送方式是不经过CPU干预，直接在外设与内存储器之间进行数据传送的方式。实现DMA传送，需要一个专用硬件DMA控制器(DMAC)，在DMA传送期间，CPU要让出对系统总线的控制权，交给DMA控制。总线在DMA的控制下，数据直接在存储器和外设之间传送，而不经过CPU干预，其传送速度大大提高，可接近于存储器的最快存取速度。这种传送方式适用于图像显示、磁盘存取、磁盘间数据传送和高速的数据采集等系统。</p><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://blog.csdn.net/zhejfl/article/details/82555634">DMA之理解</a></p><p><a href="https://baike.baidu.com/item/DMA%E6%96%B9%E5%BC%8F/8666476">百度百科——DMA</a></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM——layer sequence</title>
    <link href="/2019/09/10/Verification/UVM/UVM%E2%80%94%E2%80%94layer%20sequence/"/>
    <url>/2019/09/10/Verification/UVM/UVM%E2%80%94%E2%80%94layer%20sequence/</url>
    
    <content type="html"><![CDATA[<h3 id="0-介绍"><a href="#0-介绍" class="headerlink" title="0. 介绍"></a>0. 介绍</h3><p>当<strong>sequence中有多个不同的transaction的时候</strong>，为了将不同transaction的生成过程分离，分成更小的粒度，便于后面的复用和管理，可以采用Layer sequence，或者说多层sequence。它将一个sequenceA中产生的transactionA交付给另一个sequenceB，transactionA作为sequenceB中transactionB的一部分。</p><h3 id="1-例子"><a href="#1-例子" class="headerlink" title="1. 例子"></a>1. 例子</h3><p>比如有个ip包，ip的内容作为mac包里的pload。</p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> ip_transaction <span class="hljs-keyword">extends</span> uvm_sequence_item;<br>  <br>    <span class="hljs-comment">//ip header</span><br>    <span class="hljs-keyword">rand</span>    <span class="hljs-keyword">bit</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]  version;<span class="hljs-comment">//protocol version</span><br>    <span class="hljs-keyword">rand</span>    <span class="hljs-keyword">bit</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]  ihl;<span class="hljs-comment">// ip header length</span><br>    <span class="hljs-keyword">rand</span>    <span class="hljs-keyword">bit</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]  diff_service; <span class="hljs-comment">// service type, tos(type of service)</span><br>    <span class="hljs-keyword">rand</span>    <span class="hljs-keyword">bit</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] total_len;<span class="hljs-comment">// ip telecom length, include payload, byte</span><br>    <span class="hljs-keyword">rand</span>    <span class="hljs-keyword">bit</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] iden;<span class="hljs-comment">//identification</span><br>    <span class="hljs-keyword">rand</span>    <span class="hljs-keyword">bit</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>]  flags;<span class="hljs-comment">//flags</span><br>    <span class="hljs-keyword">rand</span>    <span class="hljs-keyword">bit</span> [<span class="hljs-number">12</span>:<span class="hljs-number">0</span>] frag_offset;<span class="hljs-comment">//fragment offset</span><br>    <span class="hljs-keyword">rand</span>    <span class="hljs-keyword">bit</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]  ttl;<span class="hljs-comment">// time to live</span><br>    <span class="hljs-keyword">rand</span>    <span class="hljs-keyword">bit</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]  protocol;<span class="hljs-comment">//protocol of data in payload</span><br>    <span class="hljs-keyword">rand</span>    <span class="hljs-keyword">bit</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] header_cks;<span class="hljs-comment">//header checksum</span><br>    <span class="hljs-keyword">rand</span>    <span class="hljs-keyword">bit</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] src_ip; <span class="hljs-comment">//source ip address</span><br>    <span class="hljs-keyword">rand</span>    <span class="hljs-keyword">bit</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] dest_ip;<span class="hljs-comment">//destination ip address</span><br>    <span class="hljs-keyword">rand</span>    <span class="hljs-keyword">bit</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] other_opt[];<span class="hljs-comment">//other options and padding</span><br>    <span class="hljs-keyword">rand</span>    <span class="hljs-keyword">bit</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]  payload[];<span class="hljs-comment">//data</span><br>    ....<br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> mac_transaction <span class="hljs-keyword">extends</span> uvm_sequence_item;<br><br>   <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">47</span>:<span class="hljs-number">0</span>] dmac;<br>   <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">47</span>:<span class="hljs-number">0</span>] smac;<br>   <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] ether_type;<br>   <span class="hljs-keyword">rand</span> <span class="hljs-keyword">byte</span>      pload[];<br>   <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] crc;<br>    ...<br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p>将ip包的内容打包为ma包中pload[]。</p><h3 id="1-关键"><a href="#1-关键" class="headerlink" title="1. 关键"></a>1. 关键</h3><p><strong>layer sequence的实现，关键是如何将ip_transaction交给mac_sequence。</strong></p><p>可以借鉴driver和sequencer的通信，在mac_sequencer中设置一个port，让它链接到ip_sequencer中的seq_item_export，这样ip_sequencer产生的ip_transaction就可以传送给mac_sequencer，在mac_sequence中拿到发送来ip_transaction.</p><h3 id="2-实现步骤"><a href="#2-实现步骤" class="headerlink" title="2. 实现步骤"></a>2. 实现步骤</h3><h4 id="2-1-在mac-sequencer中增加ip-tr-port"><a href="#2-1-在mac-sequencer中增加ip-tr-port" class="headerlink" title="2.1 在mac_sequencer中增加ip_tr_port"></a>2.1 在mac_sequencer中增加ip_tr_port</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> mac_sequencer <span class="hljs-keyword">extends</span> uvm_sequencer<span class="hljs-variable">#(mac_transaction)</span>;<br>  `uvm_component_utils(mac_sequencer);<br><br>    uvm_seq_item_pull_port<span class="hljs-variable">#(ip_transaction)</span> ip_tr_port;<span class="hljs-comment">//定义ip_tr_port</span><br><br>  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name=<span class="hljs-string">&quot;mac_sequencer&quot;</span>,uvm_component parent=<span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name,parent);<br>    ip_tr_port=<span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;ip_tr_port&quot;</span>,<span class="hljs-keyword">this</span>);<br>  <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p>driver中的seq_item_port就是uvm_seq_item_pull_port类型的。</p><h4 id="2-2-在env中将ip-tr-port和ip-sqr的seq-item-export连接"><a href="#2-2-在env中将ip-tr-port和ip-sqr的seq-item-export连接" class="headerlink" title="2.2  在env中将ip_tr_port和ip_sqr的seq_item_export连接"></a>2.2  在env中将ip_tr_port和ip_sqr的seq_item_export连接</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> enviroment <span class="hljs-keyword">extends</span> uvm_env;<br><br>`uvm_component_utils(enviroment);<br><br>ip_sequencer ip_sqr;<br>mac_sequencer sqr;<br>driver drv;<br>...<br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);<br>  <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);<br>  drv<span class="hljs-variable">.seq_item_port</span><span class="hljs-variable">.connect</span>(sqr<span class="hljs-variable">.seq_item_export</span>);<br>    sqr<span class="hljs-variable">.ip_tr_port</span><span class="hljs-variable">.connect</span>(ip_sqr<span class="hljs-variable">.seq_item_export</span>); <span class="hljs-comment">//连接mac_sqr和ip_sqr间的port</span><br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p>将port连接起来才能用get_next_item获取item。</p><h4 id="2-3-mac-sequence中获取ip-transaction"><a href="#2-3-mac-sequence中获取ip-transaction" class="headerlink" title="2.3 mac_sequence中获取ip_transaction"></a>2.3 mac_sequence中获取ip_transaction</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">class</span> ip_sequence;<br><br><span class="hljs-keyword">class</span> mac_sequence <span class="hljs-keyword">extends</span> uvm_sequence<span class="hljs-variable">#(mac_transaction)</span>;<br><br>`uvm_object_utils(mac_sequence);<br>    `uvm_declare_p_sequencer(mac_sequencer);<span class="hljs-comment">//生命p_sequencer</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name=<span class="hljs-string">&quot;mac_sequence&quot;</span>);<br>  <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">task</span> body();<br>  ip_transaction ip_tr;<br>  <span class="hljs-keyword">byte</span> <span class="hljs-keyword">unsigned</span> data_q[];<br>  <span class="hljs-keyword">int</span> data_size;<br>  <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span><br>      p_sequencer<span class="hljs-variable">.ip_tr_port</span><span class="hljs-variable">.get_next_item</span>(ip_tr);<span class="hljs-comment">//从ip_sqr中获取ip_tr</span><br>    `uvm_info(get_type_name(),<span class="hljs-string">&quot;get a ip_tr&quot;</span>,UVM_LOW);<br>    data_size = ip_tr<span class="hljs-variable">.pack_bytes</span>(data_q)/<span class="hljs-number">8</span>;<br>    req=<span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;req&quot;</span>);<br>    <span class="hljs-keyword">assert</span>(req<span class="hljs-variable">.randomize</span>() <span class="hljs-keyword">with</span> &#123;req<span class="hljs-variable">.pload</span><span class="hljs-variable">.size</span>()==data_size;&#125;);<br>    <span class="hljs-keyword">foreach</span>(data_q[i]) <span class="hljs-keyword">begin</span><br>      req<span class="hljs-variable">.pload</span>[i] = data_q[i];<br>    <span class="hljs-keyword">end</span><br>    `uvm_send(req);<br>    `uvm_info(get_type_name(),<span class="hljs-string">&quot;mac_sequence send a item&quot;</span>,UVM_LOW);<br>      p_sequencer<span class="hljs-variable">.ip_tr_port</span><span class="hljs-variable">.item_done</span>();<span class="hljs-comment">//使用完ip_tr，调用item_done()</span><br>  <span class="hljs-keyword">end</span> <br><span class="hljs-keyword">endtask</span><br><br><span class="hljs-keyword">task</span> pre_body();<br><span class="hljs-comment">// reference to Synopsys UVM LAB</span><br>  <span class="hljs-keyword">if</span>(get_parent_sequence()==<span class="hljs-literal">null</span> &amp;&amp; starting_phase!=<span class="hljs-literal">null</span>) <span class="hljs-keyword">begin</span><br>    starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>    `uvm_info(get_type_name(),<span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;%s starting phase raise %s phase&quot;</span>,get_sequence_path(),starting_phase<span class="hljs-variable">.get_name</span>()),UVM_LOW);<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">task</span> post_body();<br>  <span class="hljs-keyword">if</span>(get_parent_sequence()==<span class="hljs-literal">null</span> &amp;&amp; starting_phase!=<span class="hljs-literal">null</span>) <span class="hljs-keyword">begin</span><br>    starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>    `uvm_info(get_type_name(),<span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;%s starting phase drop %s phase&quot;</span>,get_sequence_path(),starting_phase<span class="hljs-variable">.get_name</span>()),UVM_LOW);<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><h4 id="2-4-启动sequence"><a href="#2-4-启动sequence" class="headerlink" title="2.4 启动sequence"></a>2.4 启动sequence</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-keyword">class</span> case0 <span class="hljs-keyword">extends</span> base_case;<br><br>`uvm_component_utils(case0);<br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name=<span class="hljs-string">&quot;case0&quot;</span>,uvm_component parent=<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name,parent);<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>  <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>  uvm_config_db<span class="hljs-variable">#(uvm_object_wrapper)::set(this,&quot;env.ip_sqr.run_phase&quot;,&quot;default_sequence&quot;,ip_sequence::get_type())</span>;<br>  uvm_config_db<span class="hljs-variable">#(uvm_object_wrapper)::set(this,&quot;env.sqr.run_phase&quot;,&quot;default_sequence&quot;,mac_sequence::get_type())</span>;<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><h3 id="3-注意"><a href="#3-注意" class="headerlink" title="3. 注意"></a>3. 注意</h3><p>我们在上面采用的是get_next_item来获取ip_transaction中，《UVM实战》第10.2.3节中建议使用try_next_item，具体原因有点复杂，还没搞明白。</p><h3 id="4-代码示例"><a href="#4-代码示例" class="headerlink" title="4. 代码示例"></a>4. 代码示例</h3><p><a href="https://github.com/east1203/uvm_codes/tree/master/tb3/4.layer_sequence"><strong>代码示例</strong></a></p>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>UVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
      <tag>UVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM-prebody</title>
    <link href="/2019/09/01/Verification/UVM/UVM-prebody/"/>
    <url>/2019/09/01/Verification/UVM/UVM-prebody/</url>
    
    <content type="html"><![CDATA[<p>1.在pre_body中raise_objection()</p><p>2.通过uvm_config_db来获得一些参数、sequencer等</p><p>3.在layered sequencer中，lower sequencer从upper sequencer中得到item。  </p><p>​    upper_seq_item_port.get_next_item(u_item);</p><p>在post_body中，signal the upper sequencer are done.</p><p>driver是最靠近DUT的，要想控制DUT需要将操作加载在driver中，比如如果想要复位DUT，需要在driver中，通过对接口中的reset置零。</p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">interface</span> alu_bfm;<br><span class="hljs-keyword">logic</span> clk;<br><span class="hljs-keyword">logic</span> reset_n;<br><br>    <span class="hljs-keyword">task</span> reset_alu(); <span class="hljs-comment">// 复位dut的任务</span><br>reset_n = <span class="hljs-number">0</span>;<br>@(<span class="hljs-keyword">negedge</span> clk);<br>@(<span class="hljs-keyword">negedge</span> clk);<br>reset_n = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>clk=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">forever</span> #<span class="hljs-number">10</span> clk = ~clk;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endinterface</span><br><br><span class="hljs-keyword">class</span> driver <span class="hljs-keyword">extends</span> uvm_driver<span class="hljs-variable">#(transaction)</span>;<br>....<br><span class="hljs-keyword">task</span> run_phase(uvm_phase phase):<br>        bfm<span class="hljs-variable">.reset_alu</span>(); <span class="hljs-comment">// 复位DUT</span><br>....<br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p>如果在接口中通过在initial中复位，如下</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">interface</span> alu_bfm;<br><span class="hljs-keyword">logic</span> clk;<br><span class="hljs-keyword">logic</span> reset_n;<br><br><span class="hljs-keyword">initial</span> beign<br>reset_n = <span class="hljs-number">0</span>;<br>@(<span class="hljs-keyword">negedge</span> clk);<br>@(<span class="hljs-keyword">negedge</span> clk);<br>reset_n = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endinterface</span><br></code></pre></td></tr></table></figure><p>这样的话，接口中的reset操作和driver中驱动transaction的操作会同时从0时刻开始，那么可能一些transaction就被错过了。</p>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>UVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
      <tag>UVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vim常用操作</title>
    <link href="/2019/08/31/linux/vim%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2019/08/31/linux/vim%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="查找与替换"><a href="#查找与替换" class="headerlink" title="查找与替换"></a>查找与替换</h3><p>**<a href="https://www.cnblogs.com/huxinga/p/7942194.html">参考**</a></p><p><code>:s</code>（substitute）命令用来查找和替换字符串。语法如下：</p><figure class="highlight dust"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">:</span><span class="hljs-template-variable">&#123;作用范围&#125;</span><span class="language-xml">s/</span><span class="hljs-template-variable">&#123;目标&#125;</span><span class="language-xml">/</span><span class="hljs-template-variable">&#123;替换&#125;</span><span class="language-xml">/</span><span class="hljs-template-variable">&#123;替换标志&#125;</span><br></code></pre></td></tr></table></figure><p>例如<code>:%s/foo/bar/g</code>会在全局范围(<code>%</code>)查找<code>foo</code>并替换为<code>bar</code>，所有出现都会被替换（<code>g</code>）</p><h4 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a><strong>作用范围</strong></h4><p>作用范围分为当前行、全文、选区等等。</p><p>当前行：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:s/foo/bar/g</span><br></code></pre></td></tr></table></figure><p>全文：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:%s/foo/bar/g</span><br></code></pre></td></tr></table></figure><p>选区，在Visual模式下选择区域后输入<code>:</code>，Vim即可自动补全为 <code>:&#39;&lt;,&#39;&gt;</code>。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:<span class="hljs-string">&#x27;&lt;,&#x27;</span>&gt;s/foo/bar/g</span><br></code></pre></td></tr></table></figure><p>2-11行：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">:<span class="hljs-number">5</span>,<span class="hljs-number">12</span>s<span class="hljs-regexp">/foo/</span>bar/g<br></code></pre></td></tr></table></figure><p>当前行<code>.</code>与接下来两行<code>+2</code>：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">:.,+<span class="hljs-number">2</span>s<span class="hljs-regexp">/foo/</span>bar/g<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM——Fun with UVM Sequences - Coding and Debugging</title>
    <link href="/2019/08/27/Verification/UVM/UVM%E2%80%94%E2%80%94Fun%20with%20UVM%20Sequences%20-%20Coding%20and%20Debugging/"/>
    <url>/2019/08/27/Verification/UVM/UVM%E2%80%94%E2%80%94Fun%20with%20UVM%20Sequences%20-%20Coding%20and%20Debugging/</url>
    
    <content type="html"><![CDATA[<h3 id="0-介绍"><a href="#0-介绍" class="headerlink" title="0. 介绍"></a>0. 介绍</h3><p>​    今天早上，发现Mentor Verification给我发了一封推送邮件，说有关于验证的最新研究。我是要做验证工程师的男人，看到这，能不打开吗，找了一篇关于UVM sequence的文章—— <a href="https://verificationacademy.com/verification-horizons/june-2019-volume-15-issue-2/fun-with-uvm-sequences-coding-and-debugging?mid=29813506&PC=L&c=2019_08_26_verification_tech_news_aug_201"><strong>Fun with UVM Sequences - Coding and Debugging</strong></a>。哇，这个外国人写得确实不错，一上午拜读，也自己跑了其中的一些东西，顺便也整理了一下这篇文章的东西。原文都是复制的，中文的地方是我自己的理解。</p><h3 id="CREATING-A-SEQUENCE"><a href="#CREATING-A-SEQUENCE" class="headerlink" title="CREATING A SEQUENCE"></a><strong>CREATING A SEQUENCE</strong></h3><p>​    The test below creates a sequence inside a fork&#x2F;join_none. There will be four sequences running in parallel. Each sequence has a LIMIT variable set and starts to run at the end of the fork&#x2F;join_none. Once all of the forks are done, the test completes.</p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-keyword">class</span> test <span class="hljs-keyword">extends</span> uvm_test;<br>  `uvm_component_utils(test)<br> <br>  my_sequence seq;<br>  ...<br>  <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);<br>    phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) <span class="hljs-keyword">begin</span><br>      <span class="hljs-keyword">fork</span><br>        <span class="hljs-keyword">automatic</span> <span class="hljs-keyword">int</span> j = i; <span class="hljs-comment">//automatic自动变量，每隔进程中都不同</span><br>        seq = <span class="hljs-keyword">new</span>(<span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;seq%0d&quot;</span>, j));<br>        seq<span class="hljs-variable">.LIMIT</span> = <span class="hljs-number">25</span> * (j+<span class="hljs-number">1</span>);<br>        seq<span class="hljs-variable">.start</span>(sqr);<br>      <span class="hljs-keyword">join_none</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">wait</span> <span class="hljs-keyword">fork</span>;<br>    phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>  <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><h3 id="RUNNING-A-SEQUENCE-—-CREATING-AND-SENDING-A-SEQUENCE-ITEM"><a href="#RUNNING-A-SEQUENCE-—-CREATING-AND-SENDING-A-SEQUENCE-ITEM" class="headerlink" title="RUNNING A SEQUENCE — CREATING AND SENDING A SEQUENCE ITEM"></a><strong>RUNNING A SEQUENCE — CREATING AND SENDING A SEQUENCE ITEM</strong></h3><p>​    Within the for-loop, a transaction object is constructed by calling new () or using the factory. Then start_item is called to begin the interaction with the sequencer. <strong>At this point the sequencer halts the execution of the sequence until the driver is ready. Once the driver is ready, the sequencer causes ‘start_item’ to return. Once start_item has returned, then this sequence has been granted permission to use the driver. Start_item should really be called “REQUEST_TO_SEND”. Now that the sequence has permission to use the driver, it randomizes the transaction, or sets the data values as needed. This is the so-called “LATE RANDOMIZATION” that is a desirable feature. The transactions should be randomized as close to executing as possible, that way they capture the most recent state information in any constraints.</strong></p><p>​    <strong>sequence执行start_item(tr)，等待driver准备好接受数据，如果driver准备好了，start_item(tr)结束；finish_item(tr)是sequence向driver发送数据，如果driver接受了数据并且执行完，调用了seq_item_port.item_done()，那么finish_item(tr)返回。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-keyword">class</span> my_sequence <span class="hljs-keyword">extends</span> uvm_sequence<span class="hljs-variable">#(transaction)</span>;<br>  `uvm_object_utils(my_sequence)<br> <br>  transaction t;<br>  <span class="hljs-keyword">int</span> LIMIT;<br>  ...<br>  <span class="hljs-keyword">task</span> body();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; LIMIT; i++) <span class="hljs-keyword">begin</span><br>      t = <span class="hljs-keyword">new</span>(“t”);<br>        start_item(t);<span class="hljs-comment">///</span><br>      t<span class="hljs-variable">.data</span> = i+<span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">if</span> (!t<span class="hljs-variable">.randomize</span>())<br>        `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;Randomize FAILED&quot;</span>)<br>          finish_item(t);<span class="hljs-comment">//</span><br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><h3 id="EXECUTING-A-SEQUENCE-ITEM-—-THE-DRIVER"><a href="#EXECUTING-A-SEQUENCE-ITEM-—-THE-DRIVER" class="headerlink" title="EXECUTING A SEQUENCE ITEM — THE DRIVER"></a><strong>EXECUTING A SEQUENCE ITEM — THE DRIVER</strong></h3><p>​    The driver code is relatively simple. It derives from a uvm_driver and contains a run_phase. The run_phase is a thread started automatically by the UVM core. T<strong>he run_phase is implemented as a forever begin-end loop</strong>. In the begin-end block the driver calls seq_item_port.get_next_item (t). This is a task which will cause execution in the sequencer – essentially asking the sequencer for the next transaction that should be executed. <strong>It may be that no transaction is available, in which case this call will block. (There are other non-blocking calls that can be used, but are beyond the scope of this article, and not a recommended usage)</strong>. When the sequencer has a transaction to execute, then the get_next_item call will unblock and return the transaction handle in the task argument list (variable ‘t’ in the example below). Now the driver can execute the transaction.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-keyword">class</span> driver <span class="hljs-keyword">extends</span> uvm_driver<span class="hljs-variable">#(transaction)</span>;<br>  `uvm_component_utils(driver)<br> <br>  transaction t;<br>  ...<br>  <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);<br>      <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span> <span class="hljs-comment">//这里用的是forever，我之前用while(1)</span><br>      seq_item_port<span class="hljs-variable">.get_next_item</span>(t);<br>      `uvm_info(get_type_name(), <br>               <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;Got %s&quot;</span>, t<span class="hljs-variable">.convert2string</span>()), UVM_MEDIUM)<br>      <span class="hljs-variable">#(t.duration)</span>; <span class="hljs-comment">// Execute...</span><br>      seq_item_port<span class="hljs-variable">.item_done</span>();<br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><h3 id="有用-CONTROLLING-OTHER-SEQUENCES"><a href="#有用-CONTROLLING-OTHER-SEQUENCES" class="headerlink" title="有用-CONTROLLING OTHER SEQUENCES"></a><strong>有用-CONTROLLING OTHER SEQUENCES</strong></h3><p>Sequences can have handles to other sequences; after all, a sequence is just a class object with data members, and a “task body()”, which will run as a thread.</p><h4 id="Virtual-Sequences"><a href="#Virtual-Sequences" class="headerlink" title="Virtual Sequences"></a><strong>Virtual Sequences</strong></h4><p>T<strong>he so-called “virtual sequence” – a sequence which may not generate sequence items, but rather starts sequences on other sequencers.</strong> This is a convenient way to create parallel operations from one control point.</p><p>A virtual sequence simply has handles to other sequences and sequencers. It starts them or otherwise manages them. <strong>The virtual sequence may have acquired the sequencer handles by being assigned from above, or by using a configuration database lookup, or other means</strong>. It may have constructed the sequence objects, or have acquired them by similar other means. The virtual sequence is like a puppet master, controlling other sequences.</p><p><strong>这里说可以用config机制来获得sequencer，那么就是说可以在virtual sequence写成如下：</strong></p><p><strong>但我写成下面这样出错：还没解决</strong></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">UVM_FATAL <span class="hljs-comment">@ 0: reporter@</span><span class="hljs-comment">@vseq.seq0 [SEQ] neither the item&#x27;s sequencer nor dedicated sequencer has been supplied to start item in vseq.seq0</span><br></code></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> sequence0 <span class="hljs-keyword">extends</span> uvm_sequence<span class="hljs-variable">#(transaction)</span>;<br>`uvm_object_utils(sequence0);<br><span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name=<span class="hljs-string">&quot;sequence0&quot;</span>);<br>  <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">task</span> body();<br>  transaction tr;<br>  <span class="hljs-keyword">repeat</span>(<span class="hljs-number">5</span>) <span class="hljs-keyword">begin</span><br>    `uvm_do(tr);<br>  <span class="hljs-keyword">end</span> <br><span class="hljs-keyword">endtask</span><br><br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">class</span> vsequence <span class="hljs-keyword">extends</span> uvm_sequence<span class="hljs-variable">#(transaction)</span>;<span class="hljs-comment">//virtual sequence</span><br>`uvm_object_utils(vsequence);<br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name=<span class="hljs-string">&quot;vsequence&quot;</span>);<br>  <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">task</span> pre_body();<br>  <span class="hljs-keyword">if</span>(starting_phase!=<span class="hljs-literal">null</span>)<br>    starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">task</span> body();<br>  sequence0 seq0;<br>  sequencer sqr;<br>  <span class="hljs-keyword">string</span> sqr_name;<br>  <span class="hljs-keyword">if</span>(!uvm_config_db<span class="hljs-variable">#(sequencer)::get(null,get_full_name(),&quot;sqr&quot;,sqr))</span><br>    `uvm_fatal(get_type_name(),<span class="hljs-string">&quot;Failed get sequencer&quot;</span>);<br>    `uvm_info(get_type_name(),<span class="hljs-string">&quot;vsequence start a seq&quot;</span>,UVM_LOW);<br>    `uvm_do_on(seq0,sqr);<br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">task</span> post_body();<br>  <span class="hljs-keyword">if</span>(starting_phase!=<span class="hljs-literal">null</span>)<br>    starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">class</span> case0 <span class="hljs-keyword">extends</span> base_case;<br>`uvm_component_utils(case0);<br><span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name=<span class="hljs-string">&quot;case0&quot;</span>,uvm_component parent=<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name,parent);<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>  <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>  uvm_config_db<span class="hljs-variable">#(sequencer)::set(null,&quot;*&quot;,&quot;sqr&quot;,env.sqr)</span>;<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">task</span> run_phase(uvm_phase phase);<br>  vsequence vseq;<br>  <span class="hljs-keyword">super</span><span class="hljs-variable">.run_phase</span>(phase);<br>  vseq=<span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;vseq&quot;</span>);<br>  vseq<span class="hljs-variable">.starting_phase</span>=phase;<br>    vseq<span class="hljs-variable">.start</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">//virtual sequence 没有sequencer</span><br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p>所以我就改成了另一个方法，在virtual sequence中，<strong>通过top.find(“*.env.sqr”)找到env上的sequencer，使seq在他上面启动，注意find返回类型使uvm_component，需要用cast转换成sequencer类型。</strong></p><p>代码如下，base_test 不变。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> sequence0 <span class="hljs-keyword">extends</span> uvm_sequence<span class="hljs-variable">#(transaction)</span>;<br>`uvm_object_utils(sequence0);<br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name=<span class="hljs-string">&quot;sequence0&quot;</span>);<br>  <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">task</span> body();<br>  transaction tr;<br>  <span class="hljs-keyword">repeat</span>(<span class="hljs-number">5</span>) <span class="hljs-keyword">begin</span><br>    `uvm_do(tr);<br>  <span class="hljs-keyword">end</span> <br><span class="hljs-keyword">endtask</span><br><br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">class</span> vsequence <span class="hljs-keyword">extends</span> uvm_sequence<span class="hljs-variable">#(transaction)</span>;<br>`uvm_object_utils(vsequence);<br>uvm_component component_h;<br>sequencer sequencer_h;<br><span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name=<span class="hljs-string">&quot;vsequence&quot;</span>);<br>  <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>    component_h = uvm_top<span class="hljs-variable">.find</span>(<span class="hljs-string">&quot;*.env.sqr&quot;</span>);<span class="hljs-comment">//找到启动sequencer</span><br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">$cast</span>(sequencer_h,component_h))<span class="hljs-comment">//类型转换</span><br>    `uvm_fatal(get_type_name(),<span class="hljs-string">&quot;cast errror&quot;</span>);<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">task</span> pre_body();<br>  <span class="hljs-keyword">if</span>(starting_phase!=<span class="hljs-literal">null</span>)<br>    starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endtask</span><br><br><span class="hljs-keyword">task</span> body();<br>  sequence0 seq0;<br>    `uvm_do_on(seq0,sequencer_h);<span class="hljs-comment">//启动seq</span><br><span class="hljs-keyword">endtask</span><br><br><span class="hljs-keyword">task</span> post_body();<br>  <span class="hljs-keyword">if</span>(starting_phase!=<span class="hljs-literal">null</span>)<br>    starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endtask</span><br><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p>今天（第二天）我不死心有用config_source_db来试，还是不行，上午看UVM UG的时候发现上面就有给配置sequencer的例子，但是他跟我用的一样，那么我确信确实可以这样配置，然后我又研究了一下，突然想到我的sequencer是有参数的，我是不是也应该加上，试了一下，果然可以，开心，哈哈。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> sequence0::body();<br>  sequence0 seq0;<br>    sequencer<span class="hljs-variable">#(transaction)</span> sequencer_h;<br>    uvm_config_db<span class="hljs-variable">#(sequencer#(transaction))::get(null,get_full_name(),&quot;sqr&quot;,sequencer_h)</span>;<br>  `uvm_info(get_type_name(),<span class="hljs-string">&quot;vsequence start a seq&quot;</span>,UVM_LOW);<br>  `uvm_do_on(seq0,sequencer_h);<br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> case0::connect_phase(uvm_phase phase);<br>  <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);<br>    uvm_config_db<span class="hljs-variable">#(sequencer#(transaction))::set(null,&quot;*&quot;,&quot;sqr&quot;,env.sqr)</span>;<br><span class="hljs-keyword">endfunction</span><br></code></pre></td></tr></table></figure><p>然而，我又理解错了，我之所以这次对并不是因为加了参数，而且这里也不应该给sequencer加参数，它是我自己定义的类，不是个参数类，会报警告，<strong>真正原因是我把set的语句放在的build_phase之后的conncet_phase中，之前我写在case0的build_phase中，至于为什么可以不太明白，难道是因为case0的build先执行？</strong></p><p>前面的代码中，我使用了virtual sequence，但其实不用virtual sequence，直接在sequence启动就可以。</p><p>当然也可以用一个virtual sequencer来传递子sequence的sequencer句柄。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// 2019-08-27</span><br><span class="hljs-keyword">class</span> vsequencer <span class="hljs-keyword">extends</span> uvm_sequencer<span class="hljs-variable">#(transaction)</span>;<br>    sequencerA seqA;<br>    sequencerB seqB;<br><span class="hljs-keyword">endclass</span><br><span class="hljs-keyword">class</span> base_test <span class="hljs-keyword">extends</span> uvm_test;<br>    enviroment env<br>    vsquencer vsqr;<br>    ...<br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);<br>        <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);<br>        vsqr<span class="hljs-variable">.seqA</span>=env<span class="hljs-variable">.i_agtA</span><span class="hljs-variable">.sqr</span>;<br>        vsqr<span class="hljs-variable">.seqB</span>=env<span class="hljs-variable">.i_agtB</span><span class="hljs-variable">.sqr</span>;<br>    <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br><span class="hljs-keyword">class</span> vsequence <span class="hljs-keyword">extends</span> uvm_sequence<span class="hljs-variable">#(transaction)</span><br>    <span class="hljs-keyword">task</span> body()<br>        sequenceA seqA;<br>        sequenceB seqB;<br>        seqA<span class="hljs-variable">.start</span>(p_sequencer<span class="hljs-variable">.seqA</span>);<br>        seqB<span class="hljs-variable">.start</span>(p_sequencer<span class="hljs-variable">.seqB</span>);<br>    <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br><span class="hljs-keyword">class</span> case0 <span class="hljs-keyword">extends</span> base_test;<br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase)<br>        uvm_config_db<span class="hljs-variable">#(uvm_object_wrapper)</span>::set(<span class="hljs-keyword">this</span>,<span class="hljs-string">&quot;vsqr.run_phase&quot;</span>,<br>        <span class="hljs-string">&quot;default_sequence&quot;</span>,vsequence::type_id::get());<br>    <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p>A virtual sequence might look like:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog">sequenceA_t sequenceA;<br>sequenceB_t sequenceB;<br>sequencerA sqrA;<br>sequencerB sqrB; <br> <br><span class="hljs-keyword">task</span> body();<br> sequenceA<span class="hljs-variable">.start</span>(sqrA);<br> sequenceB<span class="hljs-variable">.start</span>(sqrB);<br> …<br></code></pre></td></tr></table></figure><h4 id="WRITING-A-SELF-CHECKING-SEQUENCE"><a href="#WRITING-A-SELF-CHECKING-SEQUENCE" class="headerlink" title="WRITING A SELF-CHECKING SEQUENCE"></a><strong>WRITING A SELF-CHECKING SEQUENCE</strong></h4><p>​    A self-checking sequence is a sequence which causes some activity and then <strong>checks the results</strong> for proper behavior. The simplest self-checking sequence issues a WRITE at an address, then a READ from the same address. Now the data read is compared to the data written. In some ways the sequence becomes the GOLDEN model.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> write_read_sequence <span class="hljs-keyword">extends</span> my_sequence;<br>  `uvm_object_utils(write_read_sequence)<br>  ...<br> <br>  <span class="hljs-keyword">task</span> body();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; LIMIT; i++) <span class="hljs-keyword">begin</span><br>      t = <span class="hljs-keyword">new</span>(<span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;t%0d&quot;</span>, i));<br>      start_item(t);<br>      <span class="hljs-keyword">if</span> (!t<span class="hljs-variable">.randomize</span>())<br>        `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;Randomize FAILED&quot;</span>)<br>        <span class="hljs-comment">// 可以用get_type_name()这里就返回write_read_sequence类名</span><br>      t<span class="hljs-variable">.rw</span> = WRITE;<br>      finish_item(t);<br>    <span class="hljs-keyword">end</span><br> <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; LIMIT; i++) <span class="hljs-keyword">begin</span><br>      t = <span class="hljs-keyword">new</span>(<span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;t%0d&quot;</span>, i));<br>      start_item(t);<br>      <span class="hljs-keyword">if</span> (!t<span class="hljs-variable">.randomize</span>())<br>        `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;Randomize FAILED&quot;</span>)<br>      t<span class="hljs-variable">.rw</span> = READ;<br>      t<span class="hljs-variable">.data</span> = <span class="hljs-number">0</span>;<br>      finish_item(t);<br> <br>      <span class="hljs-comment">// Check</span><br>      <span class="hljs-keyword">if</span> (t<span class="hljs-variable">.addr</span> != t<span class="hljs-variable">.data</span>) <span class="hljs-keyword">begin</span><br>        `uvm_info(get_type_name(), <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;Mismatch. </span><br><span class="hljs-string">           Wrote %0d, Read %0d&quot;</span>, <br>           t<span class="hljs-variable">.addr</span>, t<span class="hljs-variable">.data</span>), UVM_MEDIUM)<br>        `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;Compare FAILED&quot;</span>)<br>      <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><h3 id="WRITING-A-TRAFFIC-GENERATOR-SEQUENCE"><a href="#WRITING-A-TRAFFIC-GENERATOR-SEQUENCE" class="headerlink" title="WRITING A TRAFFIC GENERATOR SEQUENCE"></a><strong>WRITING A TRAFFIC GENERATOR SEQUENCE</strong></h3><p>​    A video traffic generator can be written to generate a stream of background traffic that mimics or models the amount of data a video display might require. There is a minimum bandwidth that is required for video. That calculation will change with the load on the interface or bus, but a simplistic calculation is good enough for this example. The video traffic will generate a “screen” of data 60 times a second. Each screen will have 1920 by 1024 dots. Each dot is represented by a 32 bit word. Using these numbers, the traffic generator must create 471MB per second.</p><p><strong>这算是一个sequence的小例子</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> video <span class="hljs-keyword">extends</span> my_sequence;<br>  `uvm_object_utils(video)<br> <br>  <span class="hljs-keyword">int</span> xpixels = <span class="hljs-number">1920</span>;<br>  <span class="hljs-keyword">int</span> ypixels = <span class="hljs-number">1024</span>;<br>  <span class="hljs-keyword">int</span> screendots;<br>  <span class="hljs-keyword">int</span> rate;<br>  <span class="hljs-keyword">bit</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] addr;<br> <br>  <span class="hljs-keyword">int</span> x;<br>  <span class="hljs-keyword">int</span> y;<br> <br>  video_transaction t;<br> <br>  <span class="hljs-keyword">task</span> body();<br>    screendots = xpixels * ypixels;<br>    rate = <span class="hljs-number">1_000_000_000</span> / (<span class="hljs-number">60</span> * screendots);<br>    <span class="hljs-comment">//周期是1ns，1s内10^9个周期，每隔rate周期发送一个数据。</span><br>    <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span><br>      addr = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (x = <span class="hljs-number">0</span>; x &lt; xpixels; x++) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">for</span> (y = <span class="hljs-number">0</span>; y &lt; ypixels; y++) <span class="hljs-keyword">begin</span><br>          t = <span class="hljs-keyword">new</span>(<span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;t%0d_%0d&quot;</span>, x, y));<br>          start_item(t);<br>          <span class="hljs-keyword">if</span> (!t<span class="hljs-variable">.randomize</span>())<br>            `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;Randomize FAILED&quot;</span>)<br>          t<span class="hljs-variable">.rw</span> = WRITE;<br>          t<span class="hljs-variable">.addr</span> = addr++;<br>          t<span class="hljs-variable">.duration</span> = rate;<br>          finish_item(t);<br>        <span class="hljs-keyword">end</span><br>      <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><h3 id="有用-WRITING-SEQUENCES-THAT-ARE-SYNCHRONIZED-WITH-EACH-OTHER"><a href="#有用-WRITING-SEQUENCES-THAT-ARE-SYNCHRONIZED-WITH-EACH-OTHER" class="headerlink" title="有用-WRITING SEQUENCES THAT ARE SYNCHRONIZED WITH EACH OTHER"></a><strong>有用-WRITING SEQUENCES THAT ARE SYNCHRONIZED WITH EACH OTHER</strong></h3><p>​    Sequences will be used to synchronize other sequences (so called virtual sequences). Often two sequences need to have a relationship between them formalized. For example they cannot enter their critical regions together – they must go single-file. Or they can only run after some common critical region has passed.</p><p><strong>The code below declares two sequences which are to be synchronized (synchro_A_h and synchro_B_h). It also declares a synchronizer.</strong> There is nothing special about these classes – they have simply agreed to use some technique to be synchronized.</p><p><strong>在virtual sequence中通过synchronizer来控制synchro_A和synchro_B。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> vsequence <span class="hljs-keyword">extends</span> uvm_sequence;<br>synchro synchro_A_h;<br> synchro synchro_B_h;<br> synchronizer s;<br> <br> <span class="hljs-keyword">task</span> body();<br>  s = <span class="hljs-keyword">new</span>();<br>  <span class="hljs-comment">//declares two sequences which are to be synchronized</span><br>  synchro_A_h = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;synchroA&quot;</span>);<br>  synchro_B_h = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;synchroB&quot;</span>);<br><br>   <span class="hljs-comment">//The synchronized sequences get a handle to </span><br>   <span class="hljs-comment">//the synchronizer and a starting address.</span><br>  synchro_A_h<span class="hljs-variable">.s</span> = s;<br>  synchro_A_h<span class="hljs-variable">.start_addr</span> = <span class="hljs-number">2</span>;<br>  synchro_B_h<span class="hljs-variable">.s</span> = s;<br>  synchro_B_h<span class="hljs-variable">.start_addr</span> = <span class="hljs-number">2002</span>;<br>  <span class="hljs-comment">//The synchronizer control is rather simple. </span><br>  <span class="hljs-comment">//It just says “GO” for 20 ticks and “STOP” for 100 ticks.</span><br>  <span class="hljs-keyword">fork</span> <span class="hljs-comment">//通过控制s.state来控制两个seq的运行</span><br>     <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span><br>      #<span class="hljs-number">100</span>;<br>      s<span class="hljs-variable">.state</span> = GO;<span class="hljs-comment">//运行seq</span><br>      #<span class="hljs-number">20</span>;<br>      s<span class="hljs-variable">.state</span> = STOP;<span class="hljs-comment">//停止运行</span><br>     <span class="hljs-keyword">end</span><br>   <span class="hljs-keyword">join_none</span><br>   <span class="hljs-comment">//The synchronized sequences are started. </span><br>   <span class="hljs-comment">//They run to completion and then simply get restarted. </span><br>   <span class="hljs-comment">//They run forever.</span><br>   <span class="hljs-keyword">fork</span><span class="hljs-comment">//不停地尝试启动，当s.state为GO的使用产生tr</span><br>     <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span><br>      synchro_A_h<span class="hljs-variable">.start</span>(sqr);<br>     <span class="hljs-keyword">end</span><br>     <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span><br>      synchro_B_h<span class="hljs-variable">.start</span>(sqr);<br>     <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">join_none</span><br>  <span class="hljs-keyword">endtask</span><br>  <span class="hljs-keyword">endclass</span><br><br></code></pre></td></tr></table></figure><p>The simple synchronizer with two states — GO and STOP.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> <span class="hljs-keyword">bit</span> &#123; STOP, GO &#125; synchro_t;<br><br><span class="hljs-keyword">class</span> synchronizer;<br>  synchro_t state;<br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p>The class that uses a synchronizer to NOT execute until told to do so.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> synchro <span class="hljs-keyword">extends</span> my_sequence;<span class="hljs-comment">// 子sequence</span><br>  `uvm_object_utils(synchro)<br> <br>  <span class="hljs-keyword">bit</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] start_addr;<br>  <span class="hljs-keyword">bit</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] addr;<br>  synchronizer s;<br> <br>  synchro_transaction t;<br> <br>    <span class="hljs-keyword">task</span> body(); <span class="hljs-comment">//子sequence中的body任务</span><br>    <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span><br>      addr = start_addr;<br>      <span class="hljs-comment">// Is it safe?</span><br>      <span class="hljs-keyword">while</span> (s<span class="hljs-variable">.state</span> == STOP) <span class="hljs-keyword">begin</span> <span class="hljs-comment">//如果STOP则一直在这里阻塞</span><br>        #<span class="hljs-number">10</span>;<br>        `uvm_info(get_type_name(), <span class="hljs-string">&quot;Waiting...&quot;</span>, UVM_MEDIUM)<br>      <span class="hljs-keyword">end</span><br>      <span class="hljs-comment">//state为GO，跳过阻塞，发送seq</span><br>      t = <span class="hljs-keyword">new</span>(<span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;t%0d&quot;</span>, addr));<br>      start_item(t);<br>      <span class="hljs-keyword">if</span> (!t<span class="hljs-variable">.randomize</span>())<br>        `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;Randomize FAILED&quot;</span>)<br>      t<span class="hljs-variable">.rw</span> = WRITE;<br>      t<span class="hljs-variable">.addr</span> = addr++;<br>      finish_item(t);<br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p>In simulation, the sequence waits until the synchronizer is in the GO state. Once in the GO state, then the synchronized code generates a transaction using new, and then calls start_item&#x2F;finish_item to execute it. After waiting for access to the driver and then executing, the synchronized sequence comes back to the top of the loop and checks the synchronizer state. It will either GO again, or STOP&#x2F;WAIT</p><h3 id="有用-IMPLEMENTING-AN-INTERRUPT-SERVICE-ROUTINE-WITH-SEQUENCES"><a href="#有用-IMPLEMENTING-AN-INTERRUPT-SERVICE-ROUTINE-WITH-SEQUENCES" class="headerlink" title="有用-IMPLEMENTING AN INTERRUPT SERVICE ROUTINE WITH SEQUENCES"></a><strong>有用-IMPLEMENTING AN INTERRUPT SERVICE ROUTINE WITH SEQUENCES</strong></h3><p>Sequences will be used to provide an “<strong>interrupt service routine”</strong>. <strong>Interrupt service routines “sleep” until needed</strong>. This is a unique kind of sequence. In this example implementation it creates an “interrupt service transaction” and does start_item and finish_item. In this way, <strong>it can send that ISR transaction handle to the driver. The driver is then going to hold that handle UNTIL there is an interrupt.</strong></p><p>As part of the drivers’ job of handling the SystemVerilog Interface, it will handle the interrupts. In this case, <strong>handling the interrupt means that some data is put into the “held handle” and then the handle is marked done. Meanwhile, the interrupt service sequence has been waiting for the transaction to be marked DONE</strong>. In some parlance（说法） this is known as ITEM REALLY DONE. In the UVM, there are other mechanisms for handling this kind of thing, but they are unreliable and more complicated than this solution.</p><p><strong>就是说，driver驱动transaction到接口，driver怎么知道DUT执行完了呢，这需要driver从接口中读个数据，返回给sequence，它显示DUT是否执行完，如果执行完那么sequence就可以产生下一个transaction。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> interrupt_transaction <span class="hljs-keyword">extends</span> transaction;<br>  `uvm_object_utils(transaction)<br>  <span class="hljs-keyword">int</span> VALUE;<br>  <span class="hljs-keyword">bit</span> DONE; <span class="hljs-comment">//这个DONE的值是从driver返回的。在sequence中做判断</span><br><span class="hljs-keyword">endclass</span><br> <br><span class="hljs-keyword">class</span> interrupt_sequence <span class="hljs-keyword">extends</span> my_sequence;<br>  `uvm_object_utils(interrupt_sequence)<br> <br>  interrupt_transaction t;<br> <br>  <span class="hljs-keyword">task</span> body();<br>    <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span><br>      t = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;isr_transaction&quot;</span>);<br>      start_item(t);<br>      finish_item(t);<br>      <span class="hljs-keyword">wait</span>(t<span class="hljs-variable">.DONE</span> == <span class="hljs-number">1</span>);<span class="hljs-comment">//t还是指向刚才发送的transaction，</span><br>                          <span class="hljs-comment">//等待中断发生并执行完</span><br>      `uvm_info(get_type_name(), <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;Serviced %0d&quot;</span>,<br>         t<span class="hljs-variable">.VALUE</span>), UVM_MEDIUM)<br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br> <br><span class="hljs-keyword">class</span> driver <span class="hljs-keyword">extends</span> uvm_driver<span class="hljs-variable">#(transaction)</span>;<br>  `uvm_component_utils(driver)<br> <br>  transaction t;<br>  interrupt_transaction isr;<br>  <span class="hljs-keyword">bit</span> done;<br>  <span class="hljs-keyword">int</span> value;<br> <br>  <span class="hljs-keyword">bit</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] mem[<span class="hljs-number">1920</span>*<span class="hljs-number">1024</span>];<br> <br>  <span class="hljs-keyword">task</span> interrupt_service_routine(interrupt_transaction isr_h);<br>    `uvm_info(get_type_name(), <span class="hljs-string">&quot;Setting ISR&quot;</span>, UVM_MEDIUM)<br>    done = <span class="hljs-number">0</span>;<br>    isr_h<span class="hljs-variable">.DONE</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">wait</span>(done == <span class="hljs-number">1</span>); <span class="hljs-comment">//等待中断发生</span><br>    isr_h<span class="hljs-variable">.VALUE</span> = value; <span class="hljs-comment">//中断服务程序运行。</span><br>    isr_h<span class="hljs-variable">.DONE</span> = <span class="hljs-number">1</span>;  <span class="hljs-comment">//运行完，返回DONE，那么sequence中可以发送下一个transaction</span><br>  <span class="hljs-keyword">endtask</span><br> <br>  <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);<br>    <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span><br>      seq_item_port<span class="hljs-variable">.get_next_item</span>(t);<br> <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">$cast</span>(isr, t)) <span class="hljs-keyword">begin</span><span class="hljs-comment">//如果是isr transaction，则进入ISR，ISR是否执行还要看后面的</span><br>             <span class="hljs-comment">//transaction是否触发中断。</span><br>        <span class="hljs-keyword">fork</span>                 <br>          interrupt_service_routine(isr);<span class="hljs-comment">//SIR</span><br>        <span class="hljs-keyword">join_none</span><br>      <span class="hljs-keyword">end</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><span class="hljs-comment">//如果是普通 transaction</span><br>        ... <br>        <span class="hljs-comment">// REGULAR driver processing</span><br>        ...<br>        <span class="hljs-keyword">if</span> (AN INTERRUPT OCCURS) <span class="hljs-keyword">begin</span> <span class="hljs-comment">//如果发生了中断，那么进行一些操作</span><br>          done = <span class="hljs-number">1</span>;                     <span class="hljs-comment">// 并将done置一，上面的ISR就会执行完。</span><br>          value = mem[t<span class="hljs-variable">.addr</span>];<br>        <span class="hljs-keyword">end</span><br>          <span class="hljs-comment">//如果没有发生中断，那么ISR不会执行</span><br>      <span class="hljs-keyword">end</span><br>      seq_item_port<span class="hljs-variable">.item_done</span>();<br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><h3 id="有用-SEQUENCES-WITH-“UTILITY-LIBRARIES”"><a href="#有用-SEQUENCES-WITH-“UTILITY-LIBRARIES”" class="headerlink" title="有用-SEQUENCES WITH “UTILITY LIBRARIES”"></a><strong>有用-SEQUENCES WITH “UTILITY LIBRARIES”</strong></h3><p>Sequence “utility libraries” will be created and used. Utility libraries are simple bits of code that are useful for the sequence writer – helper functions or other abstractions of the verification process.</p><p>The open_door sequence below does just as its name implies. It opens the door to the sequencer and driver. Outside calls can now be made at will using the sequence object handle (seq.read () and seq.write () for example).</p><p><strong>这个很好用，也是一种启动sequence的方式。</strong></p><p><strong>在sequence外，通过sequence句柄调用sequence中发送transaction的任务。</strong></p><p><strong>原理是：之前把发送transaction的语句写在了body中，sequence启动后，自动调用body，所以我们也可以把发送transaction语句写在其他任务中，让body为空。我们在sequence启动后，手动调用这些任务发送transaction。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> open_door <span class="hljs-keyword">extends</span> my_sequence;<br>  `uvm_object_utils(open_door)<br> <br>  read_transaction r;<br>  write_transaction w;<br> <br>  <span class="hljs-keyword">task</span> read(<span class="hljs-keyword">input</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>]addr, <span class="hljs-keyword">output</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>]data);<br>    r = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;r&quot;</span>);<br>    start_item(r);<br>    <span class="hljs-keyword">if</span> (!r<span class="hljs-variable">.randomize</span>())<br>      `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;Randomize FAILED&quot;</span>)<br>    r<span class="hljs-variable">.rw</span> = READ;<br>    r<span class="hljs-variable">.addr</span> = addr;<br>    finish_item(r);<br>    data = r<span class="hljs-variable">.data</span>;<br>  <span class="hljs-keyword">endtask</span><br> <br>  <span class="hljs-keyword">task</span> write(<span class="hljs-keyword">input</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>]addr, <span class="hljs-keyword">input</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>]data);<br>    w = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;w&quot;</span>);<br>    start_item(w);<br>    <span class="hljs-keyword">if</span> (!w<span class="hljs-variable">.randomize</span>())<br>      `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;Randomize FAILED&quot;</span>)<br>    w<span class="hljs-variable">.rw</span> = WRITE;<br>    w<span class="hljs-variable">.addr</span> = addr;<br>    w<span class="hljs-variable">.data</span> = data;<br>    finish_item(w);<br>  <span class="hljs-keyword">endtask</span><br> <br>  <span class="hljs-keyword">task</span> body();<br>    `uvm_info(get_type_name(), <span class="hljs-string">&quot;Starting&quot;</span>, UVM_MEDIUM)<br>    <span class="hljs-keyword">wait</span>(<span class="hljs-number">0</span>);<br>    `uvm_info(get_type_name(), <span class="hljs-string">&quot;Finished&quot;</span>, UVM_MEDIUM)<br>  <span class="hljs-keyword">endtask</span><br>    <span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p>The open_door is constructed and then started using normal means. Then a test program can issue reads and writes simply as in the RED lines below.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs verilog">open_door open_door_h;<br> <br>    open_door_h = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;open_door&quot;</span>);<br>    <span class="hljs-keyword">fork</span><br>      open_door_h<span class="hljs-variable">.start</span>(sqr);<br>      <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">bit</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] rdata;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) <span class="hljs-keyword">begin</span><br>          open_door_h<span class="hljs-variable">.write</span>(i, i+<span class="hljs-number">1</span>);<br>          open_door_h<span class="hljs-variable">.read</span>(i, rdata);<br>          <span class="hljs-keyword">if</span> ( rdata != i+<span class="hljs-number">1</span> ) <span class="hljs-keyword">begin</span><br>            `uvm_info(get_type_name(), <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;Error: Wrote &#x27;%0d&#x27;, Read &#x27;%0d&#x27;&quot;</span>,<br>               i+<span class="hljs-number">1</span>, rdata), UVM_MEDIUM)<br>            <span class="hljs-comment">//`uvm_fatal(get_type_name(), &quot;MISMATCH&quot;);</span><br>          <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br>      <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">join_none</span><br></code></pre></td></tr></table></figure><p>下面是我自己写的，在case中启动sequence，并调用其函数</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> sequence1 <span class="hljs-keyword">extends</span> uvm_sequence<span class="hljs-variable">#(transaction)</span>;<br><br>`uvm_object_utils(sequence1);<br><span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name=<span class="hljs-string">&quot;sequence1&quot;</span>);<br>  <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br><span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">task</span> write();<br>  transaction tr;<br><br>  `uvm_info(get_type_name(),<span class="hljs-string">&quot;write&quot;</span>,UVM_LOW)<br>  `uvm_do(tr);<br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">task</span> read();<br><br>  transaction tr;<br>  `uvm_info(get_type_name(),<span class="hljs-string">&quot;read&quot;</span>,UVM_LOW)<br>  `uvm_do(tr);<br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">task</span> pre_body();<br>  <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>)<br>    starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>  `uvm_info(get_type_name(),<span class="hljs-string">&quot;pre_body&quot;</span>,UVM_LOW)<br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">task</span> body();<br>  `uvm_info(get_type_name(),<span class="hljs-string">&quot;body&quot;</span>,UVM_LOW)<br>  <span class="hljs-keyword">wait</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">task</span> post_body();<br>  `uvm_info(get_type_name(),<span class="hljs-string">&quot;post_body&quot;</span>,UVM_LOW)<br> <span class="hljs-keyword">if</span>(starting_phase!=<span class="hljs-literal">null</span>)<br>    starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br><span class="hljs-comment">//在case中启动启动</span><br><span class="hljs-keyword">class</span> case0 <span class="hljs-keyword">extends</span> base_test;<br>  `uvm_component_utils(case0);<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name=<span class="hljs-string">&quot;case0&quot;</span>,uvm_component parent=<span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name,parent);<br>  <span class="hljs-keyword">endfunction</span><br><br>  <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);<br>  sequence1 seq1;<br>    seq1=<span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;seq1&quot;</span>);<br>  <span class="hljs-keyword">fork</span><br>      <span class="hljs-keyword">begin</span><br>    seq1<span class="hljs-variable">.starting_phase</span> = phase;<br>    seq1<span class="hljs-variable">.start</span>(env0<span class="hljs-variable">.sqr</span>);<br>      <span class="hljs-keyword">end</span><br>      <span class="hljs-keyword">begin</span><br>          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) <span class="hljs-keyword">begin</span><br>              seq1<span class="hljs-variable">.write</span>();<span class="hljs-comment">//手动调用任务发送transaction</span><br>            seq1<span class="hljs-variable">.read</span>();<br>          <span class="hljs-keyword">end</span><br>      <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">join_none</span><br>  <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br><br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-number">27</span>:UVM_INFO seq/sequence1<span class="hljs-variable">.sv</span>(<span class="hljs-number">13</span>) @ <span class="hljs-number">0</span>: uvm_test_top<span class="hljs-variable">.env0</span><span class="hljs-variable">.sqr</span>@@seq1 [sequence1] write<br><span class="hljs-number">28</span>:UVM_INFO seq/sequence1<span class="hljs-variable">.sv</span>(<span class="hljs-number">25</span>) @ <span class="hljs-number">0</span>: uvm_test_top<span class="hljs-variable">.env0</span><span class="hljs-variable">.sqr</span>@@seq1 [sequence1] pre_body<br><span class="hljs-number">29</span>:UVM_INFO seq/sequence1<span class="hljs-variable">.sv</span>(<span class="hljs-number">28</span>) @ <span class="hljs-number">0</span>: uvm_test_top<span class="hljs-variable">.env0</span><span class="hljs-variable">.sqr</span>@@seq1 [sequence1] body<br><span class="hljs-number">54</span>:UVM_INFO seq/sequence1<span class="hljs-variable">.sv</span>(<span class="hljs-number">19</span>) @ <span class="hljs-number">0</span>: uvm_test_top<span class="hljs-variable">.env0</span><span class="hljs-variable">.sqr</span>@@seq1 [sequence1] read<br><span class="hljs-number">79</span>:UVM_INFO seq/sequence1<span class="hljs-variable">.sv</span>(<span class="hljs-number">13</span>) @ <span class="hljs-number">0</span>: uvm_test_top<span class="hljs-variable">.env0</span><span class="hljs-variable">.sqr</span>@@seq1 [sequence1] write<br>....<br><span class="hljs-number">454</span>:UVM_INFO seq/sequence1<span class="hljs-variable">.sv</span>(<span class="hljs-number">19</span>) @ <span class="hljs-number">0</span>: uvm_test_top<span class="hljs-variable">.env0</span><span class="hljs-variable">.sqr</span>@@seq1 [sequence1] read<br><span class="hljs-number">479</span>:UVM_INFO seq/sequence1<span class="hljs-variable">.sv</span>(<span class="hljs-number">13</span>) @ <span class="hljs-number">0</span>: uvm_test_top<span class="hljs-variable">.env0</span><span class="hljs-variable">.sqr</span>@@seq1 [sequence1] write<br><span class="hljs-number">504</span>:UVM_INFO seq/sequence1<span class="hljs-variable">.sv</span>(<span class="hljs-number">19</span>) @ <span class="hljs-number">0</span>: uvm_test_top<span class="hljs-variable">.env0</span><span class="hljs-variable">.sqr</span>@@seq1 [sequence1] read<br><span class="hljs-number">529</span>:UVM_INFO seq/sequence1<span class="hljs-variable">.sv</span>(<span class="hljs-number">33</span>) @ <span class="hljs-number">1000000</span>: uvm_test_top<span class="hljs-variable">.env0</span><span class="hljs-variable">.sqr</span>@@seq1 [sequence1] post_body<br><span class="hljs-number">543</span>:[sequence1]    <span class="hljs-number">23</span><br></code></pre></td></tr></table></figure><h3 id="CALLING-C-CODE-FROM-SEQUENCES"><a href="#CALLING-C-CODE-FROM-SEQUENCES" class="headerlink" title="CALLING C CODE FROM SEQUENCES"></a><strong>CALLING C CODE FROM SEQUENCES</strong></h3><p>这个就跟在SV中调用C一样，通过“DPI-C”，没什么好说的。</p><h3 id="CALLING-SEQUENCES-FROM-C-CODE"><a href="#CALLING-SEQUENCES-FROM-C-CODE" class="headerlink" title="CALLING SEQUENCES FROM C CODE"></a><strong>CALLING SEQUENCES FROM C CODE</strong></h3><p>这个光提了一下没讲。</p><p><strong>REFERENCES</strong></p><p>[1] <a href="https://ieeexplore.ieee.org/document/8299595/citations#citations">SystemVerilog, 1800-2017 - IEEE Standard for SystemVerilog–Unified Hardware Design, Specification, and Verification Language</a></p><p>[2] <a href="https://standards.ieee.org/standard/1800_2-2017.html">UVM LRM: IEEE Standard for Universal Verification Methodology Language Reference Manual</a></p><p><em>All source code is available from the author. Contact</em> <a href="mailto:rich_edelman@mentor.com"><em>rich_edelman@mentor.com</em></a> <em>for access or download from the</em> <a href="https://verificationacademy.com/uvm-sequences_source-code"><em>Verification Academy</em></a><em>.</em></p><p><em>This article was previously presented at DVCon US 2019.</em></p>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>UVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
      <tag>UVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM——ALU生成fabonacci数列</title>
    <link href="/2019/08/25/Verification/UVM/UVM%E2%80%94%E2%80%94ALU%E7%94%9F%E6%88%90fabonacci%E6%95%B0%E5%88%97/"/>
    <url>/2019/08/25/Verification/UVM/UVM%E2%80%94%E2%80%94ALU%E7%94%9F%E6%88%90fabonacci%E6%95%B0%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="0-介绍"><a href="#0-介绍" class="headerlink" title="0. 介绍"></a>0. 介绍</h3><p>之前的这篇文章——<a href="https://east1203.github.io/2019/08/25/Verification/UVM/UVM%E2%80%94%E2%80%94tb0-alu%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/">UVM——tb0-alu验证平台</a>是居于一个ALU搭建的验证平台，现在希望让这个验证平台能够输出斐波那契数列数列（1，1，2，3，5，8…），<strong>利用一种特殊的响应，写一个能够生成斐波那契数列的sequence。</strong></p><h3 id="1-思路"><a href="#1-思路" class="headerlink" title="1.  思路"></a>1.  思路</h3><h4 id="特殊的响应"><a href="#特殊的响应" class="headerlink" title="特殊的响应"></a>特殊的响应</h4><p>`uvm_do语句会将transaction通过sequencer发送给driver，`uvm_do执行完之后，它的第一个参数，也就是刚才发送的transaction指针，它不是null，它指向刚才发送的transaction。我们可以在driver驱动接口的时候，把计算的结果保存在transaction中，返回给sequence，这算是一种另类的响应。</p><h3 id="2-实现方法"><a href="#2-实现方法" class="headerlink" title="2. 实现方法"></a>2. 实现方法</h3><p>​    这样的话，我们可以在transaction类中增加一个变量来保存计算结果，如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-keyword">class</span> transaction <span class="hljs-keyword">extends</span> uvm_sequence_item;<br><br>  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] A;<br>  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] B;<br>  <span class="hljs-keyword">rand</span> operation_t op;<br>  <span class="hljs-keyword">shortint</span> <span class="hljs-keyword">unsigned</span> result;<span class="hljs-comment">//增加的变量，用来保存结果</span><br>    .....<br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p><strong>在driver驱动接口之后，等待加法命令执行完了，我们将计算结果返回给driver驱动的transaction，这个transaction就会传给sequence中的transaction。</strong></p><p><strong>在driver中：</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-keyword">task</span> driver::run_phase(uvm_phase phase);<br><span class="hljs-number">22</span>   <span class="hljs-keyword">super</span><span class="hljs-variable">.run_phase</span>(phase);<br><span class="hljs-number">23</span>   `uvm_info(<span class="hljs-string">&quot;driver&quot;</span>,<span class="hljs-string">&quot;run_phase&quot;</span>,UVM_LOW);<br><span class="hljs-number">24</span>   bfm<span class="hljs-variable">.reset_alu</span>();<br><span class="hljs-number">25</span>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br><span class="hljs-number">26</span>     seq_item_port<span class="hljs-variable">.get_next_item</span>(req);<br><span class="hljs-number">27</span>     <span class="hljs-comment">//req.print();</span><br>    <span class="hljs-number">28</span>     bfm<span class="hljs-variable">.drive_one_pkg</span>(req);<span class="hljs-comment">//接口中的任务</span><br><span class="hljs-number">29</span>     seq_item_port<span class="hljs-variable">.item_done</span>();<br><span class="hljs-number">30</span>   <span class="hljs-keyword">end</span><br><span class="hljs-number">31</span> <span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><p>上面的driver的run phase中，先从sequencer中拿到一个transaction——req；然后调用接口中的任务，将transaction的数据按照一定的时序驱动到接口中；驱动完，调用item_done()。</p><p><strong>接口中的任务：</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">interface</span> alu_bfm;<br>...<br>    <span class="hljs-keyword">task</span> drive_one_pkg(transaction tr); <span class="hljs-comment">//驱动driver拿到的transaction</span><br>    <span class="hljs-keyword">if</span>(tr<span class="hljs-variable">.op</span> == rst_op) <span class="hljs-keyword">begin</span><br>      @(<span class="hljs-keyword">posedge</span> clk);<br>      reset_n = <span class="hljs-number">1&#x27;b0</span>;<br>      start = <span class="hljs-number">1&#x27;b0</span>;<br>      @(<span class="hljs-keyword">posedge</span> clk);<br>#<span class="hljs-number">1</span>;<br>      reset_n = <span class="hljs-number">1&#x27;b1</span>;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      @(<span class="hljs-keyword">negedge</span> clk);<br>      op = tr<span class="hljs-variable">.op</span>;<br>      A = tr<span class="hljs-variable">.A</span>;<br>      B = tr<span class="hljs-variable">.B</span>;<br>      start = <span class="hljs-number">1&#x27;b1</span>;<br>      <span class="hljs-keyword">if</span>(tr<span class="hljs-variable">.op</span> == no_op) <span class="hljs-keyword">begin</span><br>        @(<span class="hljs-keyword">posedge</span> clk);<br>#<span class="hljs-number">1</span>;<br>        start = <span class="hljs-number">1&#x27;b0</span>;<br>      <span class="hljs-keyword">end</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">do</span><br>          @(<span class="hljs-keyword">negedge</span> clk);<span class="hljs-comment">//this is negedge</span><br>        <span class="hljs-keyword">while</span>(done==<span class="hljs-number">0</span>); <span class="hljs-comment">//在这里判断运算执行完</span><br>        tr<span class="hljs-variable">.result</span> = result; <span class="hljs-comment">//将结果返回到transaction</span><br>        start = <span class="hljs-number">1&#x27;b0</span>;<br>      <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">endtask</span><br>...<br><span class="hljs-keyword">endinterface</span><br></code></pre></td></tr></table></figure><h3 id="3-fabonacci-sequence"><a href="#3-fabonacci-sequence" class="headerlink" title="3. fabonacci sequence"></a>3. fabonacci sequence</h3><p>所以我们就可以写一个fabonacci sequence，写法如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-keyword">task</span> pre_body();<br>  <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>)<br>    starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>  `uvm_info(<span class="hljs-string">&quot;sequence0&quot;</span>,<span class="hljs-string">&quot;pre_body&quot;</span>,UVM_LOW)<br><span class="hljs-keyword">endtask</span><br><br>transaction fab_tr;<br><span class="hljs-keyword">task</span> body();<br>  <span class="hljs-keyword">shortint</span> <span class="hljs-keyword">unsigned</span> tmp1,tmp2;<br>    <span class="hljs-comment">// 先发送前两个数，A=1,B=1，约束命令为加法运算。</span><br>  `uvm_do_with(fab_tr,&#123;fab_tr<span class="hljs-variable">.A</span>==<span class="hljs-number">1</span>;fab_tr<span class="hljs-variable">.B</span>==<span class="hljs-number">1</span>;fab_tr<span class="hljs-variable">.op</span>==add_op;&#125;);<br>  tmp1=<span class="hljs-number">1</span>;<br>  tmp2=fab_tr<span class="hljs-variable">.result</span>;<span class="hljs-comment">//计算结果存在变量里，为了在下一次发送sequence时使用。</span><br>  <span class="hljs-keyword">repeat</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">begin</span><br>    `uvm_do_with(fab_tr,&#123;fab_tr<span class="hljs-variable">.A</span>==tmp1;fab_tr<span class="hljs-variable">.B</span>==tmp2;fab_tr<span class="hljs-variable">.op</span>==add_op;&#125;);<br>    tmp1=fab_tr<span class="hljs-variable">.B</span>;<span class="hljs-comment">//这一次发送的B的值，会是下一次发送的A的值</span><br>    tmp2=fab_tr<span class="hljs-variable">.result</span>;<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br><br><span class="hljs-keyword">task</span> post_body();<br>  `uvm_info(<span class="hljs-string">&quot;sequence0&quot;</span>,<span class="hljs-string">&quot;post_body&quot;</span>,UVM_LOW)<br>  <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>)<br>    starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><h3 id="4-打印结果"><a href="#4-打印结果" class="headerlink" title="4. 打印结果"></a>4. 打印结果</h3><p>结果如下，这个log是处理过的，只把需要的信息拿出来了，实际中比较乱。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">33</span>:@ <span class="hljs-number">90000</span> fabonacci sequence is     <span class="hljs-number">2</span><br><span class="hljs-attribute">39</span>:@ <span class="hljs-number">130000</span> fabonacci sequence is     <span class="hljs-number">3</span><br><span class="hljs-attribute">45</span>:@ <span class="hljs-number">170000</span> fabonacci sequence is     <span class="hljs-number">5</span><br><span class="hljs-attribute">51</span>:@ <span class="hljs-number">210000</span> fabonacci sequence is     <span class="hljs-number">8</span><br><span class="hljs-attribute">57</span>:@ <span class="hljs-number">250000</span> fabonacci sequence is    <span class="hljs-number">13</span><br><span class="hljs-attribute">63</span>:@ <span class="hljs-number">290000</span> fabonacci sequence is    <span class="hljs-number">21</span><br><span class="hljs-attribute">69</span>:@ <span class="hljs-number">330000</span> fabonacci sequence is    <span class="hljs-number">34</span><br><span class="hljs-attribute">75</span>:@ <span class="hljs-number">370000</span> fabonacci sequence is    <span class="hljs-number">55</span><br><span class="hljs-attribute">81</span>:@ <span class="hljs-number">410000</span> fabonacci sequence is    <span class="hljs-number">89</span><br><span class="hljs-attribute">87</span>:@ <span class="hljs-number">450000</span> fabonacci sequence is   <span class="hljs-number">144</span><br><span class="hljs-attribute">93</span>:@ <span class="hljs-number">490000</span> fabonacci sequence is   <span class="hljs-number">233</span><br><span class="hljs-attribute">143</span>:@ <span class="hljs-number">530000</span> fabonacci sequence is   <span class="hljs-number">377</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>UVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
      <tag>UVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM——tb0-alu验证平台</title>
    <link href="/2019/08/25/Verification/UVM/UVM%E2%80%94%E2%80%94tb0-alu%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/"/>
    <url>/2019/08/25/Verification/UVM/UVM%E2%80%94%E2%80%94tb0-alu%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>​    09-28 之前遇到的问题解决了，可以生成激励、正确自检和收集覆盖率。</p><p>​    代码 <a href="https://github.com/east1203/uvm_codes/tree/master/tb0_alu/h.add_coverage_modified">h.add_coverage_modified</a></p><h3 id="0-介绍"><a href="#0-介绍" class="headerlink" title="0. 介绍"></a>0. 介绍</h3><p>这几天为了准备面试，基于自己的思路写了一个验证平台，DUT是个ALU。</p><p>这个验证平台是逐步完善的，不断的迭代，最终可以测试ALU的计算，这里介绍的是添加了scoreboard之后可以进行随机激励生成、自检、覆盖率采样的版本。详细代码在链接里。</p><p><a href="https://github.com/east1203/uvm_codes/tree/master/tb0_alu"><strong>代码地址</strong></a>：d.add_coverage文件夹</p><h3 id="1-验证平台组成"><a href="#1-验证平台组成" class="headerlink" title="1. 验证平台组成"></a>1. 验证平台组成</h3><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/08/uvm/tb0.png"></p><p>上图中agent是复用的，通过is_active变量的值来决定要例化哪些组件。</p><p>在接口alu_bfm中进行时钟生成、reset任务、monitor采样、driver驱动等</p><h3 id="2-DUT介绍"><a href="#2-DUT介绍" class="headerlink" title="2.  DUT介绍"></a>2.  DUT介绍</h3><p>这里的ALU用的是<a href="http://note.youdao.com/noteshare?id=7c6d569551ab7cafe69cd26522c8d3c6&sub=54592AC6347448F49C2D2FED004B5488">《UVMPrimer》</a>书中的DUT。</p><p>端口如下：</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/08/uvm/tb1.png"></p><p>操作指令的编码如下：</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/08/uvm/tb2.png"></p><p>其实在生成激励的时候，只生成了add、and、xor指令，其他的通过设置权重，不让他们生成，因为这个验证平台还是稍微优点问题的，以后有机会改一下。</p><p>这样的话它的覆盖率总是会比较低，不过权当作搭建tb的练习了。</p><p>接口的时序：</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/08/uvm/tb3.png"></p><p>​    start信号为高，输入op、A、B有效，DUT在上升沿采样这些数据。当验证平台采样到DUT输出done为高时，说明计算结束，tb将start拉低（可以在下降沿检测done是否为高，如果为高，那么在下一个上升沿start拉低），done信号只持续一个时钟周期。</p><p>覆盖率采集：</p><ol><li>所有操作的输入都是0；</li><li>所有操作的输入都是1；</li><li>reset后执行所有操作；</li><li>执行所有操作后reset；</li><li>连续两个周期执行同一个指令；</li><li>单周期指令与多周期的乘法指令间切换</li></ol><h3 id="3-激励生成"><a href="#3-激励生成" class="headerlink" title="3. 激励生成"></a>3. 激励生成</h3><p>激励是在sequence中生成的。</p><p>在sequence中控制objection，pre_body中raise_objection，post_body中drop_objection。</p><p>也可以控制随机约束。</p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> pre_body();<br>  <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>)<br>    starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>  `uvm_info(<span class="hljs-string">&quot;sequence0&quot;</span>,<span class="hljs-string">&quot;pre_body&quot;</span>,UVM_LOW)<br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">task</span> body();<br>  `uvm_info(<span class="hljs-string">&quot;sequence0&quot;</span>,<span class="hljs-string">&quot;body&quot;</span>,UVM_LOW)<br>  <span class="hljs-keyword">repeat</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">begin</span><br>    <span class="hljs-comment">//`uvm_do(tr);</span><br>    <span class="hljs-comment">//tr=new();</span><br>    `uvm_create(tr);<br>      <span class="hljs-comment">//tr.con_op.constraint_mode(0);//控制随机约束</span><br>    <span class="hljs-comment">//tr.con_data.constraint_mode(0);</span><br>    <span class="hljs-keyword">assert</span>(tr<span class="hljs-variable">.randomize</span>);<br>    `uvm_send(tr);<br>  <span class="hljs-keyword">end</span><br>#<span class="hljs-number">1000</span>;<br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">task</span> post_body();<br>  `uvm_info(<span class="hljs-string">&quot;sequence0&quot;</span>,<span class="hljs-string">&quot;post_body&quot;</span>,UVM_LOW)<br> <span class="hljs-keyword">if</span>(starting_phase!=<span class="hljs-literal">null</span>)<br>    starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><h3 id="4-driver驱动激励到接口"><a href="#4-driver驱动激励到接口" class="headerlink" title="4. driver驱动激励到接口"></a>4. driver驱动激励到接口</h3><p>在接口中定义驱动激励的任务drive_one_pkg，</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> drive_one_pkg(transaction tr);<br>    <span class="hljs-keyword">if</span>(tr<span class="hljs-variable">.op</span> == rst_op) <span class="hljs-keyword">begin</span><span class="hljs-comment">//先判断是否是复位指令</span><br>      @(<span class="hljs-keyword">posedge</span> clk);<br>      reset_n = <span class="hljs-number">1&#x27;b0</span>;<br>      start = <span class="hljs-number">1&#x27;b0</span>;<br>      @(<span class="hljs-keyword">posedge</span> clk);<br>#<span class="hljs-number">1</span>;<br>      reset_n = <span class="hljs-number">1&#x27;b1</span>;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>        @(<span class="hljs-keyword">negedge</span> clk);<span class="hljs-comment">//下降沿将op、A、B驱动到接口</span><br>      op = tr<span class="hljs-variable">.op</span>;<br>      A = tr<span class="hljs-variable">.A</span>;<br>      B = tr<span class="hljs-variable">.B</span>;<br>      start = <span class="hljs-number">1&#x27;b1</span>;<br>        <span class="hljs-keyword">if</span>(tr<span class="hljs-variable">.op</span> == no_op) <span class="hljs-keyword">begin</span> <span class="hljs-comment">// 如果是no_op，不进行操作，那么下一个时钟沿直接将start拉低，</span><br>            @(<span class="hljs-keyword">posedge</span> clk);               <span class="hljs-comment">// 表示不进行计算</span><br>#<span class="hljs-number">1</span>;<br>        start = <span class="hljs-number">1&#x27;b0</span>;<br>      <span class="hljs-keyword">end</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><span class="hljs-comment">//进行计算的指令</span><br>        <span class="hljs-keyword">do</span><br>          @(<span class="hljs-keyword">negedge</span> clk);<span class="hljs-comment">//this is negedge</span><br>        <span class="hljs-keyword">while</span>(done==<span class="hljs-number">0</span>);<span class="hljs-comment">//下降沿时候判断计算是否结束，</span><br>        tr<span class="hljs-variable">.result</span> = result;<span class="hljs-comment">//结束了，将计算结果返回到tr，这个值可以传给sequence，用来控制激励生成。</span><br>        start = <span class="hljs-number">1&#x27;b0</span>;<br>      <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><p>我们在driver的run_phase中通过虚接口调用这个函数就行了。</p><p>driver中，可以在从sequencer取transaction之前，调用接口的reset任务复位DUT。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> driver::run_phase(uvm_phase phase);<br>  <span class="hljs-keyword">super</span><span class="hljs-variable">.run_phase</span>(phase);<br>  `uvm_info(<span class="hljs-string">&quot;driver&quot;</span>,<span class="hljs-string">&quot;run_phase&quot;</span>,UVM_LOW);<br>    bfm<span class="hljs-variable">.reset_alu</span>();<span class="hljs-comment">//reset DUT</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span> <span class="hljs-comment">//循环保证我们可以不断的向sequencer取transaction</span><br>    seq_item_port<span class="hljs-variable">.get_next_item</span>(req);<br>    <span class="hljs-comment">//req.print();</span><br>      bfm<span class="hljs-variable">.drive_one_pkg</span>(req); <span class="hljs-comment">//调用接口的驱动任务</span><br>    seq_item_port<span class="hljs-variable">.item_done</span>();<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><h3 id="5-输入monitor采样接口数据"><a href="#5-输入monitor采样接口数据" class="headerlink" title="5. 输入monitor采样接口数据"></a>5. 输入monitor采样接口数据</h3><p><strong>输入monitor的采样是在接口中进行的，并将采样到的值，通过调用输入monitor的任务，从port传给model。</strong></p><p>在接口中的采样代码如下，<strong>通过always块，在每个时钟沿采样：</strong></p><p>​    <strong>1. 我们需要判断DUT接口上的值是否是有效的输入，通过判断start信号是否为高；</strong></p><p>​    <strong>2. 另一个防止对同一个计算数据（op、A、B）采样了多次，我们需要判断当前的指令是否是新的指令，start下降沿表示一条指令执行完成，那么接下来又采样到start为高，就说明此时是新的指令了。</strong></p><p>接口中的always如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs verilog">command_monitor command_monitor_h;<span class="hljs-comment">//需要传递一个输入monitor的句柄，这样可以让我们在接口中调用</span><br><span class="hljs-comment">// monitor的任务</span><br><br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk ) <span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">bit</span> new_command=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>(!start) <span class="hljs-keyword">begin</span><br>    new_command = <span class="hljs-number">1&#x27;b1</span>;<br>  <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(start) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span>(new_command) <span class="hljs-keyword">begin</span><br>      <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;[collect ****]&quot;</span>);<br>      <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;op is %d&quot;</span>,op);<br>      command_monitor_h<span class="hljs-variable">.collect_one_pkg</span>(A,B,op2enum());<br>      new_command = (op2enum()==no_op); <br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>monitor中的操作：</p><ol><li>将句柄传递给接口</li><li>通过port发送给model</li></ol><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase); <span class="hljs-comment">//将句柄传递给接口</span><br>  bfm<span class="hljs-variable">.command_monitor_h</span>=<span class="hljs-keyword">this</span>;<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">task</span> collect_one_pkg(<span class="hljs-keyword">byte</span> A,<span class="hljs-keyword">byte</span> B,operation_t op);<br>  transaction cmd_mon_tr;<br>  cmd_mon_tr=<span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;tr&quot;</span>);<br>  cmd_mon_tr<span class="hljs-variable">.A</span>=A;<br>  cmd_mon_tr<span class="hljs-variable">.B</span>=B;<br>  cmd_mon_tr<span class="hljs-variable">.op</span>=op;<br>  ap<span class="hljs-variable">.write</span>(cmd_mon_tr);<span class="hljs-comment">//通过port发送给model</span><br>  <span class="hljs-meta">`<span class="hljs-keyword">ifdef</span> CMD_MON_PRINT</span><br>    cmd_mon_tr<span class="hljs-variable">.print</span>();<br>  <span class="hljs-meta">`<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><h3 id="6-参考模型接受输入采样，产生预测输出"><a href="#6-参考模型接受输入采样，产生预测输出" class="headerlink" title="6. 参考模型接受输入采样，产生预测输出"></a>6. 参考模型接受输入采样，产生预测输出</h3><p>我的参考模型使用SV实现的</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> model <span class="hljs-keyword">extends</span> uvm_component;<br><br>`uvm_component_utils(model);<br><br><span class="hljs-keyword">virtual</span> alu_bfm bfm;<br><br>uvm_blocking_get_port<span class="hljs-variable">#(transaction)</span> port;<br>uvm_analysis_port<span class="hljs-variable">#(result_transaction)</span> ap;<br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name=<span class="hljs-string">&quot;modle&quot;</span>,uvm_component parent = <span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name,parent);<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>  <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>  port = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;port&quot;</span>,<span class="hljs-keyword">this</span>);<br>  ap = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;ap&quot;</span>,<span class="hljs-keyword">this</span>);<br>  <span class="hljs-keyword">if</span>(!uvm_config_db<span class="hljs-variable">#(virtual alu_bfm)::get(this,&quot;&quot;,&quot;bfm&quot;,bfm))</span><br>    `uvm_fatal(<span class="hljs-string">&quot;model&quot;</span>,<span class="hljs-string">&quot;Faile get bfm!!!&quot;</span>);<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">task</span> run_phase(uvm_phase phase);<br>  transaction model_get_tr;<br>  result_transaction model_result_tr;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><span class="hljs-comment">//在循环中不停地向输入monitor要数据。</span><br>        port<span class="hljs-variable">.get</span>(model_get_tr);<span class="hljs-comment">//从输入monitor中得到有效数据</span><br>    `uvm_info(<span class="hljs-string">&quot;model&quot;</span>,<span class="hljs-string">&quot;model get transaction!!!&quot;</span>,UVM_LOW);<br>    <span class="hljs-meta">`<span class="hljs-keyword">ifdef</span> MODEL_PRINT</span><br>      `uvm_info(<span class="hljs-string">&quot;model&quot;</span>,<span class="hljs-string">&quot;print model_get_tr&quot;</span>,UVM_LOW);<br>      model_get_tr<span class="hljs-variable">.print</span>();<br>    <span class="hljs-meta">`<span class="hljs-keyword">endif</span></span><br>    model_result_tr = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;model_result_tr&quot;</span>);<br>        @(<span class="hljs-keyword">posedge</span> bfm<span class="hljs-variable">.done</span>);<span class="hljs-comment">//也可以不用这句话，因为我在scoreboard中，将左右的有效预测都存在了一个</span><br>        <span class="hljs-comment">//队列里。</span><br>    <span class="hljs-keyword">case</span>(model_get_tr<span class="hljs-variable">.op</span>)<br>      add_op:model_result_tr<span class="hljs-variable">.result</span>=model_get_tr<span class="hljs-variable">.A</span>+model_get_tr<span class="hljs-variable">.B</span>;<br>      and_op:model_result_tr<span class="hljs-variable">.result</span>=model_get_tr<span class="hljs-variable">.A</span>&amp;model_get_tr<span class="hljs-variable">.B</span>;<br>      xor_op:model_result_tr<span class="hljs-variable">.result</span>=model_get_tr<span class="hljs-variable">.A</span>^model_get_tr<span class="hljs-variable">.B</span>;<br>      mul_op:model_result_tr<span class="hljs-variable">.result</span>=model_get_tr<span class="hljs-variable">.A</span>*model_get_tr<span class="hljs-variable">.B</span>;<br>    <span class="hljs-keyword">endcase</span><br>        ap<span class="hljs-variable">.write</span>(model_result_tr);<span class="hljs-comment">//将产生的预测值发给scoreboard</span><br>    <span class="hljs-meta">`<span class="hljs-keyword">ifdef</span> MODEL_PRINT</span><br>      `uvm_info(<span class="hljs-string">&quot;model&quot;</span>,<span class="hljs-string">&quot;print model_result_tr&quot;</span>,UVM_LOW);<br>      model_result_tr<span class="hljs-variable">.print</span>();<br>    <span class="hljs-meta">`<span class="hljs-keyword">endif</span></span><br>    <br> <span class="hljs-keyword">end</span> <br><span class="hljs-keyword">endtask</span><br><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><h3 id="7-输出monitor采样DUT真实值"><a href="#7-输出monitor采样DUT真实值" class="headerlink" title="7. 输出monitor采样DUT真实值"></a>7. 输出monitor采样DUT真实值</h3><p>输出monitor和输入monitor差不多。</p><p>在接口中采样输出：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Verilog">result_monitor  result_monitor_h;<br><br>  <span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>      <span class="hljs-keyword">if</span>(done)<span class="hljs-comment">//如果done有效就采样，因为done只持续一个周期，不会存在同一个结果采样多次的情况。</span><br>      result_monitor_h<span class="hljs-variable">.collect_one_pkg</span>(result);<br>  <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>monitor中：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> collect_one_pkg(<span class="hljs-keyword">shortint</span> result);<br>  result_transaction result_mon_tr;<br>  result_mon_tr=<span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;result_tr&quot;</span>);<br>  result_mon_tr<span class="hljs-variable">.result</span>=result;<br>  ap<span class="hljs-variable">.write</span>(result_mon_tr);<br>  <span class="hljs-meta">`<span class="hljs-keyword">ifdef</span> RESULT_MON_PRINT</span><br>    `uvm_info(<span class="hljs-string">&quot;result_monitor&quot;</span>,<span class="hljs-string">&quot;print result_mon_tr&quot;</span>,UVM_LOW);<br>    result_mon_tr<span class="hljs-variable">.print</span>();<br>  <span class="hljs-meta">`<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><h3 id="8-scoreboard中比较预测值和真实值"><a href="#8-scoreboard中比较预测值和真实值" class="headerlink" title="8.  scoreboard中比较预测值和真实值"></a>8.  scoreboard中比较预测值和真实值</h3><p>​    <strong>因为参考模型的计算不需要是时钟周期的，所以可以看成拿到输入立马可以计算出预测值，在scoreboard将所哟model发出的预测值先存在一个队列中，当真实值到来的时候，逐次从这个队列中取预测值进行判断就可以了。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> scoreboard <span class="hljs-keyword">extends</span> uvm_scoreboard;<br><br>`uvm_component_utils(scoreboard);<br><br>result_transaction exp_queue[$];<br><br>uvm_blocking_get_port<span class="hljs-variable">#(result_transaction)</span> rly_port;<br>uvm_blocking_get_port<span class="hljs-variable">#(result_transaction)</span> exp_port;<br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name=<span class="hljs-string">&quot;scb&quot;</span>,uvm_component parent=<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name,parent);<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>  <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>  rly_port=<span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;rly_port&quot;</span>,<span class="hljs-keyword">this</span>);<br>  exp_port=<span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;exp_port&quot;</span>,<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">task</span> run_phase(uvm_phase phase);<br>  result_transaction rly_tr;<br>  result_transaction exp_tr;<br>  result_transaction tmp_tr;<br>  <span class="hljs-keyword">bit</span> result;<br>  <span class="hljs-keyword">super</span><span class="hljs-variable">.run_phase</span>(phase);<br>  <span class="hljs-keyword">fork</span><br>      <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><span class="hljs-comment">//这个进程是将model的预测值存在队列中。</span><br>      exp_port<span class="hljs-variable">.get</span>(exp_tr);<br>      exp_queue<span class="hljs-variable">.push_back</span>(exp_tr);<br>      <span class="hljs-meta">`<span class="hljs-keyword">ifdef</span> SCB_PRINT</span><br>        exp_tr<span class="hljs-variable">.print</span>();<br>      <span class="hljs-meta">`<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">end</span><br>      <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><span class="hljs-comment">//当真实值到来的时候，从预测队列中pop一个预测值，与真实值比较</span><br>          rly_port<span class="hljs-variable">.get</span>(rly_tr);<span class="hljs-comment">//得到真实值，否则阻塞。</span><br>      <span class="hljs-meta">`<span class="hljs-keyword">ifdef</span> SCB_PRINT</span><br>        rly_tr<span class="hljs-variable">.print</span>();<br>      <span class="hljs-meta">`<span class="hljs-keyword">endif</span></span><br>          <span class="hljs-keyword">if</span>(exp_queue<span class="hljs-variable">.size</span>()&gt;<span class="hljs-number">0</span>) <span class="hljs-keyword">begin</span><br>              tmp_tr=exp_queue<span class="hljs-variable">.pop_front</span>();<span class="hljs-comment">//从头开始取预测值</span><br>        result=rly_tr<span class="hljs-variable">.compare</span>(tmp_tr);<br>        <span class="hljs-keyword">if</span>(result)<br>          `uvm_info(<span class="hljs-string">&quot;scoreboard&quot;</span>,<span class="hljs-string">&quot;Compare SUCCESSLY!!!&quot;</span>,UVM_LOW);<br>      <span class="hljs-comment">//  else begin</span><br>      <span class="hljs-comment">//    `uvm_error(&quot;scoreboard&quot;,&quot;Compared FAILED!!!&quot;);</span><br>      <span class="hljs-comment">//    tmp_tr.print();</span><br>      <span class="hljs-comment">//    rly_tr.print();</span><br>      <span class="hljs-comment">//  end</span><br>      <span class="hljs-keyword">end</span> <br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>        `uvm_error(<span class="hljs-string">&quot;scoreboard&quot;</span>,<span class="hljs-string">&quot;Get from DUT,while can not get from model&quot;</span>);<br>      <span class="hljs-meta">`<span class="hljs-keyword">ifdef</span> SCB_PRINT</span><br>        rly_tr<span class="hljs-variable">.print</span>();<br>      <span class="hljs-meta">`<span class="hljs-keyword">endif</span></span><br>      <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">join</span><br>  <br><span class="hljs-keyword">endtask</span><br><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><h3 id="9-覆盖率组件"><a href="#9-覆盖率组件" class="headerlink" title="9. 覆盖率组件"></a>9. 覆盖率组件</h3><p>覆盖率是用单独的组件来收集的，输出monitor中的analysis port端口会将采样的数据传给model和coverage。</p><p>​    <strong>我的coverage是继承自uvm_subscripter，这个类中有一个analysis_export的对象，自己写一个write函数，在coverage中定义覆盖组，在这个write函数中采集覆盖组。这样，每次输入monitor通过analysis_port传递数据的时候就会调用coverage中的write函数来采集覆盖率信息。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> coverage <span class="hljs-keyword">extends</span> uvm_subscriber<span class="hljs-variable">#(transaction)</span>;<br>`uvm_component_utils(coverage);<br><br><span class="hljs-keyword">byte</span> <span class="hljs-keyword">unsigned</span> A;<br><span class="hljs-keyword">byte</span> <span class="hljs-keyword">unsigned</span> B;<br><span class="hljs-keyword">bit</span>[<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] op;<br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name=<span class="hljs-string">&quot;coverage&quot;</span>,uvm_component parent=<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name,parent);<br>  data=<span class="hljs-keyword">new</span>();<br>  cmd=<span class="hljs-keyword">new</span>();<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">covergroup</span> data;<br>    all_op:<span class="hljs-keyword">coverpoint</span> op&#123;<br>          <span class="hljs-keyword">ignore_bins</span> all_op=&#123;rst_op,no_op&#125;;<br>           &#125;<br><br>    a_cov:<span class="hljs-keyword">coverpoint</span> A&#123;<br>      <span class="hljs-keyword">bins</span> zeros = &#123;<span class="hljs-number">&#x27;h00</span>&#125;;<br>      <span class="hljs-keyword">bins</span> ones = &#123;<span class="hljs-number">&#x27;hff</span>&#125;;<br>      <span class="hljs-keyword">bins</span> others=&#123;[<span class="hljs-number">&#x27;h01</span>:<span class="hljs-number">&#x27;hfe</span>]&#125;;<br>    &#125;<br><br>    b_cov:<span class="hljs-keyword">coverpoint</span> B&#123;<br>      <span class="hljs-keyword">bins</span> zeros = &#123;<span class="hljs-number">&#x27;h00</span>&#125;;<br>      <span class="hljs-keyword">bins</span> ones = &#123;<span class="hljs-number">&#x27;hff</span>&#125;;<br>      <span class="hljs-keyword">bins</span> others=&#123;[<span class="hljs-number">&#x27;h01</span>:<span class="hljs-number">&#x27;hfe</span>]&#125;;<br>    &#125;<br><br>    a_b_op: <span class="hljs-keyword">cross</span> a_cov,b_cov,all_op&#123;<br>              <span class="hljs-keyword">bins</span> add_00= <span class="hljs-keyword">binsof</span>(all_op) <span class="hljs-keyword">intersect</span> &#123;add_op&#125; &amp;&amp;<br>                (<span class="hljs-keyword">binsof</span>(a_cov<span class="hljs-variable">.zeros</span>) || <span class="hljs-keyword">binsof</span>(b_cov<span class="hljs-variable">.zeros</span>));<br>              <span class="hljs-keyword">bins</span> add_FF= <span class="hljs-keyword">binsof</span>(all_op) <span class="hljs-keyword">intersect</span> &#123;add_op&#125; &amp;&amp;<br>                (<span class="hljs-keyword">binsof</span>(a_cov<span class="hljs-variable">.ones</span>) || <span class="hljs-keyword">binsof</span>(b_cov<span class="hljs-variable">.ones</span>));<br>             <span class="hljs-keyword">bins</span> and_00 = <span class="hljs-keyword">binsof</span>(all_op) <span class="hljs-keyword">intersect</span> &#123;and_op&#125; &amp;&amp;<br>             (<span class="hljs-keyword">binsof</span>(a_cov<span class="hljs-variable">.zeros</span>) || <span class="hljs-keyword">binsof</span>(b_cov<span class="hljs-variable">.zeros</span>));<br>             <span class="hljs-keyword">bins</span> and_FF = <span class="hljs-keyword">binsof</span>(all_op) <span class="hljs-keyword">intersect</span> &#123;and_op&#125; &amp;&amp;<br>             (<span class="hljs-keyword">binsof</span>(a_cov<span class="hljs-variable">.ones</span>) || <span class="hljs-keyword">binsof</span>(b_cov<span class="hljs-variable">.ones</span>));<br>             <span class="hljs-keyword">bins</span> xor_00 = <span class="hljs-keyword">binsof</span>(all_op) <span class="hljs-keyword">intersect</span> &#123;xor_op&#125; &amp;&amp;<br>             (<span class="hljs-keyword">binsof</span>(a_cov<span class="hljs-variable">.zeros</span>) || <span class="hljs-keyword">binsof</span>(b_cov<span class="hljs-variable">.zeros</span>));<br>             <span class="hljs-keyword">bins</span> xor_FF = <span class="hljs-keyword">binsof</span>(all_op) <span class="hljs-keyword">intersect</span> &#123;xor_op&#125; &amp;&amp;<br>             (<span class="hljs-keyword">binsof</span>(a_cov<span class="hljs-variable">.ones</span>) || <span class="hljs-keyword">binsof</span>(b_cov<span class="hljs-variable">.ones</span>));<br>             <span class="hljs-keyword">bins</span> mul_00 = <span class="hljs-keyword">binsof</span>(all_op) <span class="hljs-keyword">intersect</span> &#123;mul_op&#125; &amp;&amp;<br>             (<span class="hljs-keyword">binsof</span>(a_cov<span class="hljs-variable">.zeros</span>) || <span class="hljs-keyword">binsof</span>(b_cov<span class="hljs-variable">.zeros</span>));<br>             <span class="hljs-keyword">bins</span> mul_FF = <span class="hljs-keyword">binsof</span>(all_op) <span class="hljs-keyword">intersect</span> &#123;mul_op&#125; &amp;&amp;<br>             (<span class="hljs-keyword">binsof</span>(a_cov<span class="hljs-variable">.ones</span>) || <span class="hljs-keyword">binsof</span>(b_cov<span class="hljs-variable">.ones</span>)); <br>             <span class="hljs-keyword">ignore_bins</span> others_only=<span class="hljs-keyword">binsof</span>(a_cov<span class="hljs-variable">.others</span>) &amp;&amp; <span class="hljs-keyword">binsof</span>(b_cov<span class="hljs-variable">.others</span>);<br>    &#125;<br><span class="hljs-keyword">endgroup</span><br><br><span class="hljs-keyword">covergroup</span> cmd;<br>    <span class="hljs-keyword">coverpoint</span>(op)&#123;<br>      <span class="hljs-keyword">bins</span> rst2op[]=(rst_op=&gt;[add_op:mul_op]),(rst_op=&gt;no_op);<br>      <span class="hljs-keyword">bins</span> op2rst[]=([add_op:mul_op]=&gt;rst_op),(no_op=&gt;rst_op);<br>      <span class="hljs-keyword">bins</span> op[]=&#123;[add_op:mul_op],no_op,rst_op&#125;;<br>      <span class="hljs-keyword">bins</span> twoops[]=([no_op:mul_op][*<span class="hljs-number">2</span>]);<br>      &#125;<br><span class="hljs-keyword">endgroup</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span>  write(transaction t);<span class="hljs-comment">//重载write函数</span><br>      A=t<span class="hljs-variable">.A</span>;<br>      B=t<span class="hljs-variable">.B</span>;<br>      op=t<span class="hljs-variable">.op</span>;<br>      data<span class="hljs-variable">.sample</span>();<span class="hljs-comment">//采集覆盖率</span><br>      cmd<span class="hljs-variable">.sample</span>();<span class="hljs-comment">//采集覆盖率</span><br><span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><h3 id="10-top-module"><a href="#10-top-module" class="headerlink" title="10.  top module"></a>10.  top module</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top;<br><br><span class="hljs-keyword">import</span> uvm_pkg::*;<br><span class="hljs-keyword">import</span> tb_pkg::*;<br><br><span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;uvm_macros.svh&quot;</span><br><br>alu_bfm bfm();<br>tinyalu DUT(<span class="hljs-variable">.clk</span>(bfm<span class="hljs-variable">.clk</span>),<br>        <span class="hljs-variable">.reset_n</span>(bfm<span class="hljs-variable">.reset_n</span>),<br>        <span class="hljs-variable">.A</span>(bfm<span class="hljs-variable">.A</span>),<br>        <span class="hljs-variable">.B</span>(bfm<span class="hljs-variable">.B</span>),<br>        <span class="hljs-variable">.op</span>(bfm<span class="hljs-variable">.op</span>),<br>        <span class="hljs-variable">.start</span>(bfm<span class="hljs-variable">.start</span>),<br>        <span class="hljs-variable">.result</span>(bfm<span class="hljs-variable">.result</span>),<br>        <span class="hljs-variable">.done</span>(bfm<span class="hljs-variable">.done</span>)<br>        );<br><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>  uvm_config_db<span class="hljs-variable">#(virtual alu_bfm)::set(null,&quot;*&quot;,&quot;bfm&quot;,bfm)</span>; <br>  run_test();<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>  $vcdpluson;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p><strong>注意上面uvm_config_db设置虚接口的语句，一定要写在run_test()语句之前，要不然会出错。</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">UVM_FATAL comp/driver<span class="hljs-selector-class">.sv</span>(<span class="hljs-number">15</span>) @ <span class="hljs-number">0</span>: uvm_test_top<span class="hljs-selector-class">.env</span><span class="hljs-selector-class">.i_agt</span><span class="hljs-selector-class">.drv</span> <span class="hljs-selector-attr">[driver]</span> Failed get bfm!!!<br></code></pre></td></tr></table></figure><h3 id="验证平台运行"><a href="#验证平台运行" class="headerlink" title="验证平台运行"></a>验证平台运行</h3><p>运行的脚本都写在Makefile文件中，运行时执行下面命令就行了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">make<br>make urg<br>make dve<br></code></pre></td></tr></table></figure><p>make：会进行编译仿真，验证平台会生成随机激励、自检</p><p>make urg：会收集覆盖率信息，生成一个both文件，里面存折html格式的覆盖率报告。</p><p>make dve：会启动dve，查看仿真波形</p>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>UVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
      <tag>UVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM——phase objection</title>
    <link href="/2019/08/24/Verification/UVM/UVM%E2%80%94%E2%80%94phase%20objection/"/>
    <url>/2019/08/24/Verification/UVM/UVM%E2%80%94%E2%80%94phase%20objection/</url>
    
    <content type="html"><![CDATA[<h3 id="0-介绍"><a href="#0-介绍" class="headerlink" title="0. 介绍"></a>0. 介绍</h3><p>​    UVM中，component的task phase是消耗仿真时间的，各个components需要在不同层次的task phase中同步信息。UVM中通过objection mechanism来控制phase的执行，通过raise or drop objection来决定phase中事件的开始和停止。</p><h3 id="1-objection控制phase的执行"><a href="#1-objection控制phase的执行" class="headerlink" title="1. objection控制phase的执行"></a>1. objection控制phase的执行</h3><h4 id="1-1-phase中收集到objection"><a href="#1-1-phase中收集到objection" class="headerlink" title="1.1 phase中收集到objection"></a>1.1 phase中收集到objection</h4><p>​    当程序根据real-time phase的执行顺序，进入到某一个real-time phase中时，它会收集此phase提出的所有的objection（每个component都可以raise  objection），当这个phase中所有的objection都被撤销（drop）之后，那么这个phase就执行结束。</p><p>​    比如说进入到main_phase后，driver中 raise objection，monitor的main phase没有raise objection，那么driver和monitor的main phase都会执行。monitor的的main phase的执行受driver的影响，当driver中drop objection之后，monitor的main phase也停止执行。</p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">//// driver中提起objection</span><br><span class="hljs-keyword">task</span> driver::main_phase(uvm_phase phase);<br>phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>.....<span class="hljs-comment">//some activity</span><br>phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endtask</span><br><span class="hljs-comment">//// monitor中不提起objection</span><br><span class="hljs-keyword">task</span> monitor::main_phase(uvm_phase phase);<br>    ....<br><span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><h4 id="1-2-phase没有收集到objection"><a href="#1-2-phase没有收集到objection" class="headerlink" title="1.2 phase没有收集到objection"></a>1.2 phase没有收集到objection</h4><p>​    如果进入某个real-time phase后没有收集到objection，也就是说所有的component的这个real-time phase没有没raise objection，那么不会执行phase。</p><h4 id="1-3-run-phase的执行"><a href="#1-3-run-phase的执行" class="headerlink" title="1.3 run_phase的执行"></a>1.3 run_phase的执行</h4><p>run_phase和real-time phase是并行执行关系，如果在12个real-time phase有任何一个phase提起了objection，那么run_phase都会执行；当然也可以在run_phase中提起objection。</p><p><strong>外国人的代码中一般是在run_phase中进行操作，而且run_phase和main_phase的作用差不多，推荐run_phase。</strong></p><h3 id="2-在sequence中提起objection"><a href="#2-在sequence中提起objection" class="headerlink" title="2. 在sequence中提起objection"></a>2. 在sequence中提起objection</h3><p>​    在验证平台中通常是在sequence 中来控制phase的执行，并且一般是在root sequence（没有parent sequence的sequence），比如嵌套sequence、virtual sequence。</p><h4 id="2-1-设置phase的default-sequence"><a href="#2-1-设置phase的default-sequence" class="headerlink" title="2.1 设置phase的default sequence"></a>2.1 设置phase的default sequence</h4><p>在uvm_sequence中有一个starting_phase成员，它是uvm_phase类型。如果我们通过设置run phase的default sequence来启动一个sequence，那么会默认将run phase的phase传递给这个sequence的starting_phase.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case::build_phase(uvm_phase phase);<br>...<br>uvm_config_db<span class="hljs-variable">#(uvm_object_wrapper)::set(this,&quot;env.i_agt.sqr.run_phase&quot;,&quot;default_sequence&quot;,sequence::type_id::get())</span>;<br>...<br><span class="hljs-keyword">endfunction</span><br></code></pre></td></tr></table></figure><p>sequencer在启动sequence时候会默认做如下操作：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> sequencer::run_phase(uvm_phase phase):<br>...<br>seq<span class="hljs-variable">.starting_phase</span>=phase;<br>seq<span class="hljs-variable">.start</span>(<span class="hljs-keyword">this</span>);<br>...<br><span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><p>这样我们就可以在sequence中控制objection</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> <span class="hljs-keyword">sequence</span> <span class="hljs-keyword">extends</span> uvm_sequence<span class="hljs-variable">#(transaction)</span>;<br>    <span class="hljs-keyword">task</span> pre_body(); <span class="hljs-comment">//重载pre_body</span><br><span class="hljs-keyword">if</span>(starting_phase!=<span class="hljs-literal">null</span>)<br>starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">task</span> body();<br>...<br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">task</span> post_body();<br><span class="hljs-keyword">if</span>(starting_phase!=<span class="hljs-literal">null</span>)<br>starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><h4 id="2-2-直接将task-phase的phase传递给sequence"><a href="#2-2-直接将task-phase的phase传递给sequence" class="headerlink" title="2.2 直接将task phase的phase传递给sequence"></a>2.2 直接将task phase的phase传递给sequence</h4><p>如果我们是用start函数来启动sequence，可以通过直接将phase传递给sequence的starting_phase。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> my_case::run_phase(uvm_phase phase):<br>...<br>seq<span class="hljs-variable">.starting_phase</span> = phase;<br>seq<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.sqr</span>);<br><span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><p><strong>在实际应用中不写seq.starting_phase&#x3D;phase这一句也可以，但是在UVM UG中，写了。</strong></p><h3 id="3-在哪控制objection"><a href="#3-在哪控制objection" class="headerlink" title="3. 在哪控制objection"></a>3. 在哪控制objection</h3><p>可以有两种方法。</p><h4 id="3-1-在sequence中控制"><a href="#3-1-在sequence中控制" class="headerlink" title="3.1 在sequence中控制"></a>3.1 在sequence中控制</h4><p>之前讲的就是在sequence中控制，将phase传递给sequence的starting_phase</p><h4 id="3-2-在scoreboard中控制"><a href="#3-2-在scoreboard中控制" class="headerlink" title="3.2 在scoreboard中控制"></a>3.2 在scoreboard中控制</h4><p>我们控制run phase任务运行的目的是想要正确的发送和接受激励序列。</p><p>​    发送的激励序列一方面传递给了参考模型，一方面传递给了DUT，参考模型产生预测数据，DUT产生真实的输出响应，所以，如果我们将DUT的所有合理的输出都在scoreboard完成了，那么我们的run phase其实就可以结束了。基于这个思想我们可以在scoreboard中控制objection。</p><p>​    如果我们有pkg_num个激励，那么我们可以在scoreboard中收集pkg_num个真实DUT输出就可以raise_objection。这个pkg_num可以通过config_db的get得到。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">task</span> scoreboard::run_phase(uvm_phase phase);<br>...<br>    phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>); <span class="hljs-comment">//提起objection</span><br><span class="hljs-keyword">fork</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>exp_port<span class="hljs-variable">.get</span>(exp_tr); <span class="hljs-comment">//从参考模型中拿到预测值</span><br>exp_queue<span class="hljs-variable">.push_back</span>(tr);<span class="hljs-comment">//将预测值都保存在队列中，为了后面与真实值比较</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">for</span>（<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;pkg_num;i++) <span class="hljs-keyword">begin</span><br>act_port<span class="hljs-variable">.get</span>(act_tr); <span class="hljs-comment">//得到真实值</span><br>tmp_tr=exp_queue<span class="hljs-variable">.pop_front</span>(); <span class="hljs-comment">//逐次与预测值比较</span><br>result=exp_tr<span class="hljs-variable">.compare</span>(tmp_tr);<span class="hljs-comment">//比较</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">join_any</span><span class="hljs-comment">// 注意</span><br>    phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><p>上面用的是fork join_any，fork里面有两个进程，第一个是个while循环会一直执行，所以当第二个进程for循环执行完之后，就会跳出fork，执行phase.drop_objection(this);结束任务。</p><h3 id="4-set-drain-time"><a href="#4-set-drain-time" class="headerlink" title="4. set_drain_time"></a>4. set_drain_time</h3><p> <strong>phase.phase_done.set_drain_time(this,200);</strong> </p><p>​    任何功能模块DUT都有处理延迟，我们发送transaction给DUT的输入到DUT产生输出，这中间会有延迟，如果我们在sequence中发送完最后一个transaction之后，立马drop_objection，那么可能最后发送的几个transaction还没有在DUT中产生输出，也就不会被scoreboard收集到。</p><p>​    为了让task phase在drop_objection后不立马结束，延迟一段时间，等待所有的transaction都在DUT产生输出，我们可以设置set_drain_time。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br>    phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>#<span class="hljs-number">1000</span>;<span class="hljs-comment">//这是1000ns，打印时候是ps为单位</span><br>    phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>  <span class="hljs-keyword">endtask</span><br><br>  <span class="hljs-keyword">task</span> post_main_phase(uvm_phase phase);<br>    phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>      `uvm_info(<span class="hljs-string">&quot;case0&quot;</span>,<span class="hljs-string">&quot;this post_main_phase&quot;</span>,UVM_LOW);  <br>    phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>  <span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">UVM<span class="hljs-number">_</span>INFO <span class="hljs-keyword">case</span>/cases.sv(<span class="hljs-number">31</span>) @ <span class="hljs-number">1000000</span>: uvm<span class="hljs-number">_</span>test<span class="hljs-number">_</span>top [<span class="hljs-keyword">case</span><span class="hljs-number">0</span>] <span class="hljs-keyword">this</span> post<span class="hljs-number">_m</span>ain<span class="hljs-number">_p</span>hase<br></code></pre></td></tr></table></figure><p>延迟1000ns之后调用drop_objection，立马进入post_main_phase.</p><p><strong>如果我们使用了set_drain_time：</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br>    phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>#<span class="hljs-number">1000</span>;<br>    phase<span class="hljs-variable">.phase_done</span><span class="hljs-variable">.set_drain_time</span>(<span class="hljs-keyword">this</span>,<span class="hljs-number">200</span>); <br>    phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>  <span class="hljs-keyword">endtask</span><br><br>  <span class="hljs-keyword">task</span> post_main_phase(uvm_phase phase);<br>    phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>      `uvm_info(<span class="hljs-string">&quot;case0&quot;</span>,<span class="hljs-string">&quot;this post_main_phase&quot;</span>,UVM_LOW);  <br>    phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>  <span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">UVM<span class="hljs-number">_</span>INFO <span class="hljs-keyword">case</span>/cases.sv(<span class="hljs-number">31</span>) @ <span class="hljs-number">1200000</span>: uvm<span class="hljs-number">_</span>test<span class="hljs-number">_</span>top [<span class="hljs-keyword">case</span><span class="hljs-number">0</span>] <span class="hljs-keyword">this</span> post<span class="hljs-number">_m</span>ain<span class="hljs-number">_p</span>hase<br></code></pre></td></tr></table></figure><p>延迟了200ns才进入post_main_phase。</p><p>这里的phase_done是uvm_phase的一个成员，它是uvm_objection类型，我们在调用phase.raise_objection(this)的时候，其实调用的是phase_done.raise_objection(this)。</p>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>UVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
      <tag>UVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV——SV实现blueprint</title>
    <link href="/2019/08/23/Verification/SystemVerilog/SV%E2%80%94SV%E5%AE%9E%E7%8E%B0blueprint/"/>
    <url>/2019/08/23/Verification/SystemVerilog/SV%E2%80%94SV%E5%AE%9E%E7%8E%B0blueprint/</url>
    
    <content type="html"><![CDATA[<h3 id="0-介绍"><a href="#0-介绍" class="headerlink" title="0. 介绍"></a>0. 介绍</h3><p>蓝图模式（blueprint）是“绿皮书”第八章将的一个点，它是通过层次引用，将generator产生的transaction类型改变，这样可以实现错误注入，使generator产生不同类型的transaction（这些transaction都要继承自定义在generator中的transaction）。</p><h3 id="1-框图"><a href="#1-框图" class="headerlink" title="1. 框图"></a>1. 框图</h3><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/08/sv/blueprint.png"></p><p>error_tr继承自blueprint类型，在top层，通过层次引用，将blueprint对象替换成error_tr对象。</p><h3 id="2-trans类型作为blueprint"><a href="#2-trans类型作为blueprint" class="headerlink" title="2. trans类型作为blueprint"></a>2. trans类型作为blueprint</h3><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> trans;<br><br><span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] A;<br><span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] B;<br><span class="hljs-keyword">rand</span> operation_e op;<br><span class="hljs-keyword">string</span> name;<br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name=<span class="hljs-string">&quot;trans&quot;</span>);<br>  <span class="hljs-keyword">this</span><span class="hljs-variable">.name</span>=name;<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">constraint</span> c_data &#123;<br>  A <span class="hljs-keyword">inside</span> &#123;[<span class="hljs-number">10</span>:<span class="hljs-number">20</span>]&#125;;<br>  B <span class="hljs-keyword">inside</span> &#123;[<span class="hljs-number">30</span>:<span class="hljs-number">40</span>]&#125;;<br>&#125;<br><br><span class="hljs-keyword">constraint</span> c_op &#123;<br>  op <span class="hljs-keyword">dist</span> &#123;<br>    add_op:=<span class="hljs-number">1</span>,<br>    and_op:=<span class="hljs-number">1</span>,<br>    xor_op:=<span class="hljs-number">1</span>,<br>    mul_op:=<span class="hljs-number">1</span><br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> print();<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@%0t : %s :&quot;</span>,<span class="hljs-built_in">$time</span>,name);<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@%0t : A is %d&quot;</span>,<span class="hljs-built_in">$time</span>,A);  <br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@%0t : B is %d&quot;</span>,<span class="hljs-built_in">$time</span>,B);  <br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@%0t : op is %3b&quot;</span>,<span class="hljs-built_in">$time</span>,op);<span class="hljs-comment">//enum do not need transform to bit[2:0]</span><br><span class="hljs-keyword">endfunction</span> <br><span class="hljs-comment">// transaction的复制函数</span><br><span class="hljs-keyword">function</span> trans copy();<span class="hljs-comment">//copy is the return</span><br>  copy=<span class="hljs-keyword">new</span>(); <span class="hljs-comment">// new copy first</span><br>  copy<span class="hljs-variable">.A</span>=<span class="hljs-keyword">this</span><span class="hljs-variable">.A</span>;<br>  copy<span class="hljs-variable">.B</span>=<span class="hljs-keyword">this</span><span class="hljs-variable">.B</span>;<br>  copy<span class="hljs-variable">.op</span>=<span class="hljs-keyword">this</span><span class="hljs-variable">.op</span>;<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><h3 id="3-error-trans继承自trans类型"><a href="#3-error-trans继承自trans类型" class="headerlink" title="3. error_trans继承自trans类型"></a>3. error_trans继承自trans类型</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> error_trans <span class="hljs-keyword">extends</span> trans;<br><br><span class="hljs-keyword">constraint</span> c_data &#123;<br>  A <span class="hljs-keyword">inside</span> &#123;[<span class="hljs-number">0</span>:<span class="hljs-number">9</span>]&#125;;<br>  B <span class="hljs-keyword">inside</span> &#123;[<span class="hljs-number">0</span>:<span class="hljs-number">9</span>]&#125;;<br>&#125;<br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p>在error_trans中，我们重载了约束c_data，使得A,B的值在0到9之间。</p><p>我们在后面可以观察它的执行结果</p><h3 id="4-generator中"><a href="#4-generator中" class="headerlink" title="4. generator中"></a>4. generator中</h3><p>通常我们建议在generator中发送transaction的时候写成如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> generator::run();<br>trans tr; <span class="hljs-comment">//定义对象句柄</span><br><span class="hljs-keyword">repeat</span>(<span class="hljs-number">5</span>) <span class="hljs-keyword">begin</span><br>tr=<span class="hljs-keyword">new</span>(); <span class="hljs-comment">//在循环中创建对象，每次发送的对象都不同</span><br>        <span class="hljs-keyword">assert</span>(tr<span class="hljs-variable">.randomize</span>);<br>mlb<span class="hljs-variable">.put</span>(tr);<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><p>但是我们想要通过层次引用替换generator中要发送的transaction，所以我们希望在run之前就已经创建了对象，然后再替换它。</p><p>所以我们要写成如下的形式：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> generator;<br>trans tr;<span class="hljs-comment">// 这里的tr就是blueprint，会在顶层被替换</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>();<br>        tr=<span class="hljs-keyword">new</span>(); <span class="hljs-comment">//创建transaction对象。</span><br><span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">task</span> run();<br><span class="hljs-keyword">assert</span>(tr<span class="hljs-variable">.randomize</span>);<br>        mbl<span class="hljs-variable">.put</span>(tr<span class="hljs-variable">.copy</span>());<span class="hljs-comment">//这里传递的是tr的一个复制</span><br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p>完整的generator如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> generator;<br><br>mailbox<span class="hljs-variable">#(trans)</span> gen_mlb;<br>  trans gen_tr;<span class="hljs-comment">// 这里的gen_tr就是blueprint，会在顶层被替换</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">input</span> mailbox<span class="hljs-variable">#(trans) mlb)</span>;<br>  <span class="hljs-keyword">this</span><span class="hljs-variable">.gen_mlb</span> = mlb;<br>    gen_tr=<span class="hljs-keyword">new</span>(); <span class="hljs-comment">//create gen_tr </span><br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> build;<br>  gen_mlb=<span class="hljs-keyword">new</span>();<br><span class="hljs-keyword">endtask</span><br><br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run;<br>  <span class="hljs-keyword">repeat</span>(<span class="hljs-number">10</span>)<span class="hljs-keyword">begin</span><br><span class="hljs-comment">//    gen_tr=new();</span><br>    <span class="hljs-keyword">assert</span>(gen_tr<span class="hljs-variable">.randomize</span>());<br>    gen_mlb<span class="hljs-variable">.put</span>(gen_tr<span class="hljs-variable">.copy</span>());<span class="hljs-comment">//这里传递的是tr的一个复制</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><h3 id="5-在top层替换blueprint"><a href="#5-在top层替换blueprint" class="headerlink" title="5. 在top层替换blueprint"></a>5. 在top层替换blueprint</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top;<br><br><span class="hljs-keyword">import</span> cb_pkg::*;<br>bp_bfm bfm();<br>enviroment env;<br><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>  env=<span class="hljs-keyword">new</span>(bfm);<br>  env<span class="hljs-variable">.build</span>();<br><br>  <span class="hljs-meta">`<span class="hljs-keyword">ifdef</span> BLUEPRINT</span><br>    <span class="hljs-keyword">begin</span><br>      <span class="hljs-comment">//error_trans replace trans;</span><br>      <span class="hljs-comment">//error_trans&#x27;s A inside [0:9],B inside [0:9]</span><br>      error_trans err_tr; <span class="hljs-comment">//定义error_trans</span><br>      err_tr=<span class="hljs-keyword">new</span>();<br>      env<span class="hljs-variable">.gen</span><span class="hljs-variable">.gen_tr</span>=err_tr; <span class="hljs-comment">//hierarchy reference  层次引用替换generator中的gen_tr</span><br>      <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@ %0t : **** BLUEPRINT ****&quot;</span>,<span class="hljs-built_in">$time</span>);<br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-meta">`<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-meta">`<span class="hljs-keyword">ifdef</span> CALLBACK</span><br>  <span class="hljs-keyword">begin</span><br>    user_cb ucb;<br>    ucb=<span class="hljs-keyword">new</span>();<br>    env<span class="hljs-variable">.drv</span><span class="hljs-variable">.cb_queue</span><span class="hljs-variable">.push_back</span>(ucb);<br>  <span class="hljs-keyword">end</span><br>  <span class="hljs-meta">`<span class="hljs-keyword">endif</span></span><br>  env<span class="hljs-variable">.run</span>();<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h3 id="6-观察结果"><a href="#6-观察结果" class="headerlink" title="6. 观察结果"></a>6. 观察结果</h3><p>如果我们定义了宏BLUEPRINT，那么就会进行blueprint替换，结果如下，可以看到A，B的取值范围在0到9之间。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ada">@ <span class="hljs-number">0</span> : **** <span class="hljs-type">BLUEPRINT</span> ****<br>@ <span class="hljs-number">0</span> : <span class="hljs-type">driver</span> one pkg!!!<br>@<span class="hljs-number">0</span> : <span class="hljs-type">trans</span> :<br>@0 : <span class="hljs-type">A</span> <span class="hljs-keyword">is</span>   <span class="hljs-number">7</span><br>@<span class="hljs-number">0</span> : <span class="hljs-type">B</span> <span class="hljs-keyword">is</span>   <span class="hljs-number">9</span><br>@<span class="hljs-number">0</span> : <span class="hljs-type">op</span> <span class="hljs-keyword">is</span> <span class="hljs-number">011</span><br>@ <span class="hljs-number">10000</span> : <span class="hljs-type">driver</span> one pkg!!!<br>@<span class="hljs-number">10000</span> : <span class="hljs-type">trans</span> :<br>@10000 : <span class="hljs-type">A</span> <span class="hljs-keyword">is</span>   <span class="hljs-number">6</span><br>@<span class="hljs-number">10000</span> : <span class="hljs-type">B</span> <span class="hljs-keyword">is</span>   <span class="hljs-number">7</span><br>@<span class="hljs-number">10000</span> : <span class="hljs-type">op</span> <span class="hljs-keyword">is</span> <span class="hljs-number">011</span><br></code></pre></td></tr></table></figure><p>如果我们将宏BLUEPRINT注销，会看到A的值在10到20之间，B的值在30到40之间。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ada">@ <span class="hljs-number">0</span> : <span class="hljs-type">driver</span> one pkg!!!<br>@<span class="hljs-number">0</span> : <span class="hljs-type">trans</span> :<br>@0 : <span class="hljs-type">A</span> <span class="hljs-keyword">is</span>  <span class="hljs-number">19</span><br>@<span class="hljs-number">0</span> : <span class="hljs-type">B</span> <span class="hljs-keyword">is</span>  <span class="hljs-number">33</span><br>@<span class="hljs-number">0</span> : <span class="hljs-type">op</span> <span class="hljs-keyword">is</span> <span class="hljs-number">001</span><br>@ <span class="hljs-number">10000</span> : <span class="hljs-type">driver</span> one pkg!!!<br>@<span class="hljs-number">10000</span> : <span class="hljs-type">trans</span> :<br>@10000 : <span class="hljs-type">A</span> <span class="hljs-keyword">is</span>  <span class="hljs-number">14</span><br>@<span class="hljs-number">10000</span> : <span class="hljs-type">B</span> <span class="hljs-keyword">is</span>  <span class="hljs-number">39</span><br>@<span class="hljs-number">10000</span> : <span class="hljs-type">op</span> <span class="hljs-keyword">is</span> <span class="hljs-number">011</span><br></code></pre></td></tr></table></figure><h3 id="7-代码详情"><a href="#7-代码详情" class="headerlink" title="7. 代码详情"></a>7. 代码详情</h3><p><a href="https://github.com/east1203/sv/tree/master/sv3.blueprint"><strong>代码</strong></a></p>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV——SV实现callback</title>
    <link href="/2019/08/23/Verification/SystemVerilog/SV%E2%80%94SV%E5%AE%9E%E7%8E%B0callback/"/>
    <url>/2019/08/23/Verification/SystemVerilog/SV%E2%80%94SV%E5%AE%9E%E7%8E%B0callback/</url>
    
    <content type="html"><![CDATA[<h3 id="0-介绍"><a href="#0-介绍" class="headerlink" title="0. 介绍"></a>0. 介绍</h3><p><strong>用SV实现回调的功能。</strong></p><p>回调思路可以让我们<strong>在top层向验证平台注入代码</strong>到我们预留的“钩子”（hook）中，实现一些功能，比如：在driver回调可以实现错误注入，收集激励到scoreboard中，收集覆盖率等。</p><p>这篇文章介绍在driver中回调，实现对driver驱动的transaction的控制，可以产生不同的激励，比如错误激励。</p><h3 id="1-结构图"><a href="#1-结构图" class="headerlink" title="1. 结构图"></a>1. 结构图</h3><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/08/sv/callback.png"></p><p>driver中有一个回调的“钩子”——是一个driver_cb类型的队列，在顶层将扩展driver_cb得到user_cb，在user_cb中重载一些回调函数，并将user_cb对象注入到这个队列里，就可以注入回调代码。</p><p><strong>本文中，driver将transaction驱动到接口，外面没有DUT。</strong></p><h3 id="2-文件结构"><a href="#2-文件结构" class="headerlink" title="2. 文件结构"></a>2. 文件结构</h3><figure class="highlight q"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs q">[classes]:<br>  trans.<span class="hljs-built_in">sv</span><br>  driver_cb.<span class="hljs-built_in">sv</span><br>  driver.<span class="hljs-built_in">sv</span><br>  generator.<span class="hljs-built_in">sv</span><br>  enviroment.<span class="hljs-built_in">sv</span><br>  user_cb.<span class="hljs-built_in">sv</span><br>cb_pkg.<span class="hljs-built_in">sv</span><br>top.<span class="hljs-built_in">sv</span><br>Makefile<br>filelist<br>bp_bfm.<span class="hljs-built_in">sv</span><br></code></pre></td></tr></table></figure><h3 id="3-transaction"><a href="#3-transaction" class="headerlink" title="3. transaction"></a>3. transaction</h3><p>我们的transaction如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> trans;<br><br><span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] A;<br><span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] B;<br><span class="hljs-keyword">rand</span> operation_e op;<br><span class="hljs-keyword">string</span> name;<br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name=<span class="hljs-string">&quot;trans&quot;</span>);<br>  <span class="hljs-keyword">this</span><span class="hljs-variable">.name</span>=name;<br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">constraint</span> c_data &#123;<br>    A <span class="hljs-keyword">inside</span> &#123;[<span class="hljs-number">10</span>:<span class="hljs-number">20</span>]&#125;; <span class="hljs-comment">//A的范围是10到20</span><br>  B <span class="hljs-keyword">inside</span> &#123;[<span class="hljs-number">30</span>:<span class="hljs-number">40</span>]&#125;;<br>&#125;<br><br><span class="hljs-keyword">constraint</span> c_op &#123;<br>  op <span class="hljs-keyword">dist</span> &#123;<br>    add_op:=<span class="hljs-number">1</span>,<br>    and_op:=<span class="hljs-number">1</span>,<br>    xor_op:=<span class="hljs-number">1</span>,<br>    mul_op:=<span class="hljs-number">1</span><br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">function</span> print();<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@%0t : %s :&quot;</span>,<span class="hljs-built_in">$time</span>,name);<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@%0t : A is %d&quot;</span>,<span class="hljs-built_in">$time</span>,A);  <br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@%0t : B is %d&quot;</span>,<span class="hljs-built_in">$time</span>,B);  <br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@%0t : op is %3b&quot;</span>,<span class="hljs-built_in">$time</span>,op);<span class="hljs-comment">//enum do not need transform to bit[2:0]</span><br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p><strong>其中约束A的值的范围是10到20，我们在回调中会将其改成0到9.</strong></p><h3 id="4-回调基类"><a href="#4-回调基类" class="headerlink" title="4. 回调基类"></a>4. 回调基类</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> driver_cb;<br>    <br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> pre_cb(<span class="hljs-keyword">ref</span> trans tr); <span class="hljs-comment">//空的虚函数</span><br><span class="hljs-comment">//do nothings</span><br><span class="hljs-keyword">endtask</span><br><br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> post_cb();<br><span class="hljs-comment">//do nothings</span><br><span class="hljs-keyword">endtask</span><br><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p>在回调基类中声明的回调函数是虚函数，不做任何事，用户自己定义回调类（继承自回调基类），利用OOP中的多态概念实现父类指针调用子类函数。</p><h3 id="5-驱动器driver"><a href="#5-驱动器driver" class="headerlink" title="5. 驱动器driver"></a>5. 驱动器driver</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> driver;<br>    driver_cb cb_queue[$]; <span class="hljs-comment">// 回调基类</span><br>    trans driver_tr;<br>    mailbox<span class="hljs-variable">#(trans)</span> gen2drv; <span class="hljs-comment">// 用来和generator进行通信，传递transaction</span><br><br><span class="hljs-keyword">virtual</span> bp_bfm bfm; <span class="hljs-comment">//虚接口，通过new函数得到真实的接口</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">input</span> mailbox<span class="hljs-variable">#(trans) mlb,virtual bp_bfm bfm)</span>;<br>  <span class="hljs-keyword">this</span><span class="hljs-variable">.gen2drv</span>=mlb; <span class="hljs-comment">// 传递mailbox</span><br>  <span class="hljs-keyword">this</span><span class="hljs-variable">.bfm</span>=bfm; <span class="hljs-comment">//传递接口</span><br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run();<br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>      gen2drv<span class="hljs-variable">.get</span>(driver_tr); <span class="hljs-comment">// 从generator得到transaction</span><br>      <span class="hljs-keyword">foreach</span>(cb_queue[i]) cb_queue[i]<span class="hljs-variable">.pre_cb</span>(driver_tr); <span class="hljs-comment">// 回调钩子</span><br>      drive_one_pkg(driver_tr); <span class="hljs-comment">//驱动transaction到接口，也就dut</span><br>      <span class="hljs-keyword">foreach</span>(cb_queue[i]) cb_queue[i]<span class="hljs-variable">.post_cb</span>(); <span class="hljs-comment">//回调钩子</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br><br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> drive_one_pkg(trans tr);<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@ %0t : driver one pkg!!!&quot;</span>,<span class="hljs-built_in">$time</span>);<br>  tr<span class="hljs-variable">.print</span>();<br>  @(<span class="hljs-keyword">posedge</span> bfm<span class="hljs-variable">.clk</span>);<br>  bfm<span class="hljs-variable">.A</span> = tr<span class="hljs-variable">.A</span>;<br>  bfm<span class="hljs-variable">.B</span> = tr<span class="hljs-variable">.B</span>;<br>  bfm<span class="hljs-variable">.op</span> = tr<span class="hljs-variable">.op</span>;<br><span class="hljs-keyword">endtask</span><br><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><h3 id="6-用户自定义回调类"><a href="#6-用户自定义回调类" class="headerlink" title="6. 用户自定义回调类"></a>6. 用户自定义回调类</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> user_cb <span class="hljs-keyword">extends</span> driver_cb;<br><br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> pre_cb(<span class="hljs-keyword">ref</span> trans tr);<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@ %0t : modified A value!!!&quot;</span>,<span class="hljs-built_in">$time</span>);<br>    tr<span class="hljs-variable">.A</span> = $urandom_range(<span class="hljs-number">0</span>,<span class="hljs-number">9</span>); <span class="hljs-comment">//在重载的回调函数中，将A的值改为0到9的随机值，</span><br>    <span class="hljs-comment">//在transaction类中，A的值是10到20</span><br><span class="hljs-keyword">endtask</span><br><br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> post_cb();<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@ %0t : calling post_cb!!!&quot;</span>,<span class="hljs-built_in">$time</span>);<br><span class="hljs-keyword">endtask</span><br><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p>user_cb继承自driver_cb，并且重载其中的回调函数。</p><h3 id="7-top层注入回调类"><a href="#7-top层注入回调类" class="headerlink" title="7. top层注入回调类"></a>7. top层注入回调类</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;bp_bfm.sv&quot;</span><br><span class="hljs-keyword">module</span> top;<br><span class="hljs-keyword">import</span> cb_pkg::*;<br><br>bp_bfm bfm();<br>enviroment env;<br><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>  env=<span class="hljs-keyword">new</span>(bfm);<br>  env<span class="hljs-variable">.build</span>();<br>  <span class="hljs-keyword">begin</span><br>    user_cb ucb; <span class="hljs-comment">//定义回调类对象</span><br>    ucb=<span class="hljs-keyword">new</span>();<br>      env<span class="hljs-variable">.drv</span><span class="hljs-variable">.cb_queue</span><span class="hljs-variable">.push_back</span>(ucb); <span class="hljs-comment">//将回调对象注入到driver中的回调队列中。</span><br>  <span class="hljs-keyword">end</span><br>  env<span class="hljs-variable">.run</span>();<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h3 id="8-仿真结果"><a href="#8-仿真结果" class="headerlink" title="8. 仿真结果"></a>8. 仿真结果</h3><p>在下面打印值中可以看到，A的值在0到9之间，说明回调起作用了。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ada">@ <span class="hljs-number">40000</span> : <span class="hljs-type">modified</span> A value!!!<br>@ <span class="hljs-number">40000</span> : <span class="hljs-type">driver</span> one pkg!!!<br>@<span class="hljs-number">40000</span> : <span class="hljs-type">trans</span> :<br>@40000 : <span class="hljs-type">A</span> <span class="hljs-keyword">is</span>   <span class="hljs-number">9</span><br>@<span class="hljs-number">40000</span> : <span class="hljs-type">B</span> <span class="hljs-keyword">is</span>  <span class="hljs-number">32</span><br>@<span class="hljs-number">40000</span> : <span class="hljs-type">op</span> <span class="hljs-keyword">is</span> <span class="hljs-number">010</span><br>@ <span class="hljs-number">50000</span> : <span class="hljs-type">calling</span> post_cb!!!<br>@ <span class="hljs-number">50000</span> : <span class="hljs-type">modified</span> A value!!!<br>@ <span class="hljs-number">50000</span> : <span class="hljs-type">driver</span> one pkg!!!<br>@<span class="hljs-number">50000</span> : <span class="hljs-type">trans</span> :<br>@50000 : <span class="hljs-type">A</span> <span class="hljs-keyword">is</span>   <span class="hljs-number">8</span><br>@<span class="hljs-number">50000</span> : <span class="hljs-type">B</span> <span class="hljs-keyword">is</span>  <span class="hljs-number">37</span><br>@<span class="hljs-number">50000</span> : <span class="hljs-type">op</span> <span class="hljs-keyword">is</span> <span class="hljs-number">011</span><br>@ <span class="hljs-number">70000</span> : <span class="hljs-type">calling</span> post_cb!!!<br></code></pre></td></tr></table></figure><p>仿真结果如下：</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/08/sv/callback1.png"></p><h3 id="9-代码"><a href="#9-代码" class="headerlink" title="9. 代码"></a>9. 代码</h3><p>完整代码查看 》》》》 <a href="https://github.com/east1203/sv/tree/master/sv1_drive_to_interface"><strong>代码</strong></a></p>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell中的grep</title>
    <link href="/2019/08/19/linux/shell%E4%B8%AD%E7%9A%84grep/"/>
    <url>/2019/08/19/linux/shell%E4%B8%AD%E7%9A%84grep/</url>
    
    <content type="html"><![CDATA[<p><strong>grep主要用来进行字符串数据对比，然后将符合用户需要的字符串打印出来。</strong></p><h3 id="1-查找特定字符串"><a href="#1-查找特定字符串" class="headerlink" title="1. 查找特定字符串"></a>1. 查找特定字符串</h3><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">grep -n [-A] [-B] &quot;要查找的字符串&quot; --color=auto filename<br></code></pre></td></tr></table></figure><table><thead><tr><th>option</th><th>description</th></tr></thead><tbody><tr><td>-n</td><td>显示行在文件中的行号</td></tr><tr><td>-A</td><td>后面跟数字，所匹配行之后的几行也会打印</td></tr><tr><td>-B</td><td>后面跟数字，所匹配行之前的几行也会打印</td></tr><tr><td>–color</td><td>颜色标注</td></tr></tbody></table><h3 id="2-反向选择，没有特定字符串的行"><a href="#2-反向选择，没有特定字符串的行" class="headerlink" title="2. 反向选择，没有特定字符串的行"></a>2. 反向选择，没有特定字符串的行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -nv [-A] [-B] &quot;要查找的字符串&quot; --color=auto filename<br></code></pre></td></tr></table></figure><p>加上 -v选项即可</p><h3 id="3-字符串中可以使用正则匹配"><a href="#3-字符串中可以使用正则匹配" class="headerlink" title="3. 字符串中可以使用正则匹配"></a>3. 字符串中可以使用正则匹配</h3><p>在参数 “要查找的字符串” 中可以使用正则匹配来匹配需要的行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -n &quot;^the&quot; filename<br></code></pre></td></tr></table></figure><p>上面匹配以 “the”开头的行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -n &quot;^$&quot; filename <br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示空白行</span><br></code></pre></td></tr></table></figure><h3 id="4-与管道命令-一起用从文件中搜索关键字"><a href="#4-与管道命令-一起用从文件中搜索关键字" class="headerlink" title="4. 与管道命令|一起用从文件中搜索关键字"></a>4. 与管道命令|一起用从文件中搜索关键字</h3><p>比如有个文件log</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs subunit">//log<br>Command: ./simv -cm line+tgl+fsm+cond -l sim.log<br>Chronologic VCS simulator copyright 1991<span class="hljs-string">-2014</span><br>Contains Synopsys proprietary information.<br>Compiler version I<span class="hljs-string">-2014</span>.03; Runtime version I<span class="hljs-string">-2014</span>.03;  Aug 23 22:22 2019<br>VCD+ Writer I<span class="hljs-string">-2014</span>.03 Copyright (c) 1991<span class="hljs-string">-2014</span> by Synopsys Inc.<br>$finish at simulation time                    0<br>           V C S   S i m u l a t i o n   R e p o r t <br><span class="hljs-keyword">Time:</span> 0 ps<br>CPU Time:      0.650 seconds;       Data structure size:   0.0Mb<br>Fri Aug 23 22:22:57 2019<br></code></pre></td></tr></table></figure><p>我们想要看看这个文件中包含Command关键字的行，可以在命令行shell中输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">more log | grep Command<br></code></pre></td></tr></table></figure><p>接着命令行打印出文件log中包含Command的行：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">Command: ./simv -<span class="hljs-keyword">cm</span> <span class="hljs-built_in">line</span>+tgl+fsm+cond -<span class="hljs-keyword">l</span> <span class="hljs-keyword">sim</span>.<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell中的sed</title>
    <link href="/2019/08/19/linux/shell%E4%B8%AD%E7%9A%84sed/"/>
    <url>/2019/08/19/linux/shell%E4%B8%AD%E7%9A%84sed/</url>
    
    <content type="html"><![CDATA[<p><strong>中兴面试被提问到：在vim中删除包含特定字符串的行。当时说不会，后来想了想可以用sed或者perl里的匹配替换。</strong></p><h3 id="0-sed"><a href="#0-sed" class="headerlink" title="0. sed"></a>0. sed</h3><p>sed是个管道命令，可以对数据进行替换、删除、新增、选取特定行等功能。</p><h3 id="1-命令格式"><a href="#1-命令格式" class="headerlink" title="1. 命令格式"></a>1. 命令格式</h3><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">sed -ndfr [动作]<br></code></pre></td></tr></table></figure><h4 id="1-1-参数"><a href="#1-1-参数" class="headerlink" title="1.1 参数"></a>1.1 参数</h4><table><thead><tr><th>参数</th><th></th></tr></thead><tbody><tr><td>-n</td><td>只有被sed处理的行才会打印出来</td></tr><tr><td>-e</td><td>直接在命令行上输入sed命令，如果和-i参数配合用会保存源文件。</td></tr><tr><td>-f</td><td>将sed动作写在文件内，-f filename可以执行filename文件中的动作</td></tr><tr><td>-i</td><td>如果不加-i，sed的命令不会改变源文件，如果加上，会改变源文件</td></tr></tbody></table><h4 id="1-2-动作说明"><a href="#1-2-动作说明" class="headerlink" title="1.2 动作说明"></a>1.2 动作说明</h4><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">‘<span class="hljs-comment">[n1]</span><span class="hljs-comment">[,n2]</span> function&#x27;<br></code></pre></td></tr></table></figure><p>动作要写在单引号或双引号内；</p><p>n1，n2可以没有，他们代表动作在哪些行进行，如果是”2,5”表示动作在第二行到第五行之间进行。</p><table><thead><tr><th>function</th><th></th></tr></thead><tbody><tr><td>d</td><td>删除这些行</td></tr><tr><td>a</td><td>新增，插入在行之后</td></tr><tr><td>i</td><td>插入，插入在行之前</td></tr><tr><td>c</td><td>行替换</td></tr><tr><td>p</td><td>将某些行打印出，通常和-n一起用</td></tr><tr><td>s</td><td>替换，可以进行正则匹配</td></tr></tbody></table><h3 id="2-使用sed"><a href="#2-使用sed" class="headerlink" title="2. 使用sed"></a>2. 使用sed</h3><p>存在文件a，内容如下</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">this</span> <span class="hljs-number">1</span> line<br><span class="hljs-keyword">this</span> <span class="hljs-number">2</span> line<br><span class="hljs-keyword">this</span> <span class="hljs-number">3</span> line<br><span class="hljs-keyword">this</span> <span class="hljs-number">4</span> line<br><span class="hljs-keyword">this</span> <span class="hljs-number">5</span> line<br><span class="hljs-keyword">this</span> <span class="hljs-number">5</span> line<br></code></pre></td></tr></table></figure><h4 id="2-1-删除-d-——删除这些行"><a href="#2-1-删除-d-——删除这些行" class="headerlink" title="2.1 删除 d ——删除这些行"></a>2.1 删除 d ——删除这些行</h4><p>删除1到2行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed -e &quot;1,2d&quot; a<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">this</span> <span class="hljs-number">3</span> line<br><span class="hljs-keyword">this</span> <span class="hljs-number">4</span> line<br><span class="hljs-keyword">this</span> <span class="hljs-number">5</span> line<br><span class="hljs-keyword">this</span> <span class="hljs-number">5</span> line<br></code></pre></td></tr></table></figure><h4 id="2-2-新增-a——插入在行之后"><a href="#2-2-新增-a——插入在行之后" class="headerlink" title="2.2 新增 a——插入在行之后"></a>2.2 新增 a——插入在行之后</h4><p>分别在1到3行后插入一行</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">sed -e <span class="hljs-string">&quot;1,3a after line&quot;</span> <span class="hljs-keyword">a</span><br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">this</span> <span class="hljs-number">1</span> line<br>after line<br><span class="hljs-keyword">this</span> <span class="hljs-number">2</span> line<br>after line<br><span class="hljs-keyword">this</span> <span class="hljs-number">3</span> line<br>after line<br><span class="hljs-keyword">this</span> <span class="hljs-number">4</span> line<br><span class="hljs-keyword">this</span> <span class="hljs-number">5</span> line<br><span class="hljs-keyword">this</span> <span class="hljs-number">5</span> line<br></code></pre></td></tr></table></figure><h4 id="2-3-插入-i——插入在行之前"><a href="#2-3-插入-i——插入在行之前" class="headerlink" title="2.3 插入 i——插入在行之前"></a>2.3 插入 i——插入在行之前</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed -e &quot;1,3i before line&quot; a<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino">before line<br><span class="hljs-keyword">this</span> <span class="hljs-number">1</span> line<br>before line<br><span class="hljs-keyword">this</span> <span class="hljs-number">2</span> line<br>before line<br><span class="hljs-keyword">this</span> <span class="hljs-number">3</span> line<br><span class="hljs-keyword">this</span> <span class="hljs-number">4</span> line<br><span class="hljs-keyword">this</span> <span class="hljs-number">5</span> line<br><span class="hljs-keyword">this</span> <span class="hljs-number">5</span> line<br></code></pre></td></tr></table></figure><h4 id="2-4-行替换-c"><a href="#2-4-行替换-c" class="headerlink" title="2.4 行替换 c"></a>2.4 行替换 c</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed -e &quot;1,3c display&quot; a<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino">display<br><span class="hljs-keyword">this</span> <span class="hljs-number">4</span> line<br><span class="hljs-keyword">this</span> <span class="hljs-number">5</span> line<br><span class="hljs-keyword">this</span> <span class="hljs-number">5</span> line<br></code></pre></td></tr></table></figure><h4 id="2-5-打印某些行-p——将某些行打印出，通常和-n一起用"><a href="#2-5-打印某些行-p——将某些行打印出，通常和-n一起用" class="headerlink" title="2.5 打印某些行 p——将某些行打印出，通常和-n一起用"></a>2.5 打印某些行 p——将某些行打印出，通常和-n一起用</h4><p>只将1到3行打印出来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed -d &quot;1,3p&quot; a<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">this</span> <span class="hljs-number">1</span> line<br><span class="hljs-keyword">this</span> <span class="hljs-number">2</span> line<br><span class="hljs-keyword">this</span> <span class="hljs-number">3</span> line<br></code></pre></td></tr></table></figure><h4 id="2-6-正则匹配替换-s"><a href="#2-6-正则匹配替换-s" class="headerlink" title="2.6 正则匹配替换 s"></a>2.6 正则匹配替换 s</h4><p>将所有的this替换成大写THIS</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed -e &quot;s/this/THIS/g&quot; a<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">THIS</span> <span class="hljs-number">1</span> line<br><span class="hljs-attribute">THIS</span> <span class="hljs-number">2</span> line<br><span class="hljs-attribute">THIS</span> <span class="hljs-number">3</span> line<br><span class="hljs-attribute">THIS</span> <span class="hljs-number">4</span> line<br><span class="hljs-attribute">THIS</span> <span class="hljs-number">5</span> line<br><span class="hljs-attribute">THIS</span> <span class="hljs-number">5</span> line<br></code></pre></td></tr></table></figure><h3 id="3-使用sed修改文件内容"><a href="#3-使用sed修改文件内容" class="headerlink" title="3. 使用sed修改文件内容"></a>3. 使用sed修改文件内容</h3><p>上面讲的用法，sed不会改变源文件。如果想要改变源文件就要加-i参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed -ie &quot;s/this/THIS/g&quot; a<br></code></pre></td></tr></table></figure><p>a文件变成：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">THIS</span> <span class="hljs-number">1</span> line<br><span class="hljs-attribute">THIS</span> <span class="hljs-number">2</span> line<br><span class="hljs-attribute">THIS</span> <span class="hljs-number">3</span> line<br><span class="hljs-attribute">THIS</span> <span class="hljs-number">4</span> line<br><span class="hljs-attribute">THIS</span> <span class="hljs-number">5</span> line<br><span class="hljs-attribute">THIS</span> <span class="hljs-number">5</span> line<br></code></pre></td></tr></table></figure><p><strong>并且生成了一个文件ae，其中保存原来的a文件的内容，如果不加-e参数，则不生成这个文件，只修改a的内容。</strong></p><p>-i也可以与其他的动作d\a等等用，用法一样，只是会改变源文件。</p><p><strong>如果同时用-ie会生成新的文件保存源文件内容。</strong></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM——sequence（一）</title>
    <link href="/2019/08/08/Verification/UVM/UVM%E2%80%94%E2%80%94sequence%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2019/08/08/Verification/UVM/UVM%E2%80%94%E2%80%94sequence%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>在UVM中，将激励生成和测试平台分开，使平台只编译一次，但可以运行多个激励，要实现这一点需要sequence机制、factory机制和config_db机制。</p><p>在不同的测试用例中，将不同的sequence设置成sequencer的main_phase中的default_sequence。当sequencer执行到main_phase时，发现有default_sequence，就启动sequence。</p><h3 id="1-sequence的启动"><a href="#1-sequence的启动" class="headerlink" title="1. sequence的启动"></a>1. sequence的启动</h3><p><strong>1）方法一</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog">my_sequence seq0;<br>seq0 = my_sequence::type_id::create(<span class="hljs-string">&quot;seq0&quot;</span>);<br>uvm_config_db<span class="hljs-variable">#(uvm_sequence_base)::set(this,&quot;env.i_agt.sqr.main_phase&quot;,&quot;default_sequence&quot;,seq0)</span>;<br></code></pre></td></tr></table></figure><p><strong>2）方法二</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">uvm_config_db<span class="hljs-variable">#(uvm_object_wrapper)::set(this,&quot;env.i_agt.sqr.main_phase&quot;,&quot;default_sequence&quot;,my_sequence::type_id::get())</span>;<br></code></pre></td></tr></table></figure><p><strong>3）方法三</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog">my_sequence seq0;<br>seq0 = my_sequence::type_id::create(<span class="hljs-string">&quot;seq0&quot;</span>);<br>seq0<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.sqr</span>);<br></code></pre></td></tr></table></figure><h3 id="2-sequence相关的宏"><a href="#2-sequence相关的宏" class="headerlink" title="2. sequence相关的宏"></a>2. sequence相关的宏</h3><p><strong>1）&#96;uvm_do系列</strong></p><p>在sequence类中的body任务里调用&#96;uvm_do系列的宏，<strong>用来指定在那个sequencer中发送transaction。</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">`<span class="hljs-built_in">uvm_do</span>(SEQ_OR_ITEM)<br>`<span class="hljs-built_in">uvm_do_pri</span>(SEQ_OR_ITEM, PRIORITY)<br>`<span class="hljs-built_in">uvm_do_with</span>(SEQ_OR_ITEM, CONSTRAINTS)<br>`<span class="hljs-built_in">uvm_do_pri_with</span>(SEQ_OR_ITEM, PRIORITY, CONSTRAINTS)<br>`<span class="hljs-built_in">uvm_do_on</span>(SEQ_OR_ITEM, SEQR)<br>`<span class="hljs-built_in">uvm_do_on_pri</span>(SEQ_OR_ITEM, SEQR, PRIORITY)<br>`<span class="hljs-built_in">uvm_do_on_with</span>(SEQ_OR_ITEM, SEQR, CONSTRAINTS)<br>`<span class="hljs-built_in">uvm_do_on_pri_with</span>(SEQ_OR_ITEM, SEQR, PRIORITY, CONSTRAINTS)<br></code></pre></td></tr></table></figure><p><strong>在UVM中uvm_do的其他七个宏都是从是从&#96;uvm_do_on_pri_with产生的</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">define</span> uvm_do(SEQ_OR_ITME) \</span><br>`uvm_do_on_pri_with(SEQ_OR_ITEM,m_sequencer,-<span class="hljs-number">1</span>,&#123;&#125;)<br></code></pre></td></tr></table></figure><p>下面是一个&#96;uvm_do_with的例子：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> crc_seq <span class="hljs-keyword">extends</span> uvm_sequence<span class="hljs-variable">#(my_transaction)</span>;<br>   `uvm_object_utils(crc_seq)<br>   <span class="hljs-keyword">function</span>  <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name= <span class="hljs-string">&quot;crc_seq&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>   <span class="hljs-keyword">endfunction</span> <br>   <br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      my_transaction tr;<br>      `uvm_do_with(tr, &#123;tr<span class="hljs-variable">.crc_err</span> == <span class="hljs-number">1</span>;<br>                        tr<span class="hljs-variable">.dmac</span> == <span class="hljs-number">48&#x27;h980F</span>;&#125;)<br>   <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p><strong>2）&#96;uvm_send系列</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">`<span class="hljs-built_in">uvm_send</span>(SEQ_OR_ITEM)<br>`<span class="hljs-built_in">uvm_send_pri</span>(SEQ_OR_ITEM, PRIORITY)<br>`<span class="hljs-built_in">uvm_rand_send</span>(SEQ_OR_ITEM)<br>`<span class="hljs-built_in">uvm_rand_send_pri</span>(SEQ_OR_ITEM, PRIORITY)<br>`<span class="hljs-built_in">uvm_rand_send_with</span>(SEQ_OR_ITEM, CONSTRAINTS)<br>`<span class="hljs-built_in">uvm_rand_send_pri_with</span>(SEQ_OR_ITEM, PRIORITY, CONSTRAINTS)<br></code></pre></td></tr></table></figure><p>在使用`uvm_send之前，transaction必须是已经创建好了的，可以用`uvm_create宏来创建，</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">int</span> p_sz;<br>      my_transaction m_trans;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>         num++;<br>          `uvm_create(m_trans)  <span class="hljs-comment">//创建transaction</span><br>         <span class="hljs-keyword">assert</span>(m_trans<span class="hljs-variable">.randomize</span>());<br>         p_sz = m_trans<span class="hljs-variable">.pload</span><span class="hljs-variable">.size</span>();<br>         &#123;m_trans<span class="hljs-variable">.pload</span>[p_sz - <span class="hljs-number">4</span>], <br>          m_trans<span class="hljs-variable">.pload</span>[p_sz - <span class="hljs-number">3</span>], <br>          m_trans<span class="hljs-variable">.pload</span>[p_sz - <span class="hljs-number">2</span>], <br>          m_trans<span class="hljs-variable">.pload</span>[p_sz - <span class="hljs-number">1</span>]&#125; <br>          = num; <br>          `uvm_send(m_trans) <span class="hljs-comment">//发送transaction</span><br>      <span class="hljs-keyword">end</span><br>      #<span class="hljs-number">100</span>;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><h3 id="3-sequence相关函数"><a href="#3-sequence相关函数" class="headerlink" title="3. sequence相关函数"></a>3. sequence相关函数</h3><p><strong>1）start_item和finish_item</strong></p><p><strong>用这两个函数来代替&#96;uvm_do系列的宏，来控制transaction的发送。但是要求transaction是已经创建好了的。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> start_item (uvm_sequence_item item,<span class="hljs-keyword">int</span> set_priority = -<span class="hljs-number">1</span>,<br>uvm_sequencer_base sequencer = <span class="hljs-literal">null</span>)<br>    <span class="hljs-comment">///Randomization may be done between start_item and finish_item to ensure late generation</span><br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> finish_item (uvm_sequence_item item,<span class="hljs-keyword">int</span> set_priority = -<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      my_transaction tr;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>          tr = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;tr&quot;</span>); <span class="hljs-comment">// 先将transaction创建好。</span><br>          <span class="hljs-keyword">assert</span>(tr<span class="hljs-variable">.randomize</span>() <span class="hljs-keyword">with</span> &#123;tr<span class="hljs-variable">.pload</span><span class="hljs-variable">.size</span> == <span class="hljs-number">200</span>;&#125;);<span class="hljs-comment">//随机化也可以在两个函数之间</span><br>          start_item(tr); <span class="hljs-comment">// 等待sequencer能够接受transaction，否则阻塞</span><br>          finish_item(tr); <span class="hljs-comment">// 等待driver调用itme_done()，否则阻塞。表明一个transaction发送完，可以收集运行结果。</span><br>      <span class="hljs-keyword">end</span><br>      #<span class="hljs-number">100</span>;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><p><strong>2）pre_do、mid_do和post_do</strong></p><p>&#96;uvm_do系列的宏封装了很多命令：</p><p><strong>如果&#96;uvm_do中的参数是uvm_sequence_item：</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Verilog">`uvm_create(item)<br>sequencer<span class="hljs-variable">.wait_for_grant</span>(prior) (<span class="hljs-keyword">task</span>)<br><span class="hljs-keyword">this</span><span class="hljs-variable">.pre_do</span>(<span class="hljs-number">1</span>)                  (<span class="hljs-keyword">task</span>) <span class="hljs-comment">// start_item</span><br>item<span class="hljs-variable">.randomize</span>()<br><span class="hljs-keyword">this</span><span class="hljs-variable">.mid_do</span>(item)               (func)<span class="hljs-comment">//finish_item</span><br>sequencer<span class="hljs-variable">.send_request</span>(item)    (func)<br>sequencer<span class="hljs-variable">.wait_for_item_done</span>()  (<span class="hljs-keyword">task</span>)<br><span class="hljs-keyword">this</span><span class="hljs-variable">.post_do</span>(item)              (func) <span class="hljs-comment">//finish_item</span><br></code></pre></td></tr></table></figure><p>pre_do是start_item返回前执行的最后一行代码；mid_do是finish_item最开始，post_do是finish_item最后一行代码。</p><p><strong>如果&#96;uvm_do中的参数是uvm_sequence：</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs VERILOG">`uvm_create(sub_seq)<br>sub_seq<span class="hljs-variable">.randomize</span>()<span class="hljs-comment">//也进行随机化，在sequence也可以定义rand变量</span><br>sub_seq<span class="hljs-variable">.pre_start</span>()         (<span class="hljs-keyword">task</span>)<br><span class="hljs-keyword">this</span><span class="hljs-variable">.pre_do</span>(<span class="hljs-number">0</span>)              (<span class="hljs-keyword">task</span>)<br><span class="hljs-keyword">this</span><span class="hljs-variable">.mid_do</span>(sub_seq)        (func)<br>sub_seq<span class="hljs-variable">.body</span>()              (<span class="hljs-keyword">task</span>)<br><span class="hljs-keyword">this</span><span class="hljs-variable">.post_do</span>(sub_seq)       (func)<br>sub_seq<span class="hljs-variable">.post_start</span>()        (<span class="hljs-keyword">task</span>)<br></code></pre></td></tr></table></figure><h3 id="4-sequence的仲裁机制"><a href="#4-sequence的仲裁机制" class="headerlink" title="4. sequence的仲裁机制"></a>4. sequence的仲裁机制</h3><h4 id="4-1-在同一个sequencer上同时启动多个sequence"><a href="#4-1-在同一个sequencer上同时启动多个sequence" class="headerlink" title="4.1 在同一个sequencer上同时启动多个sequence"></a>4.1 在同一个sequencer上同时启动多个sequence</h4><p>如果在同一个sequencer上同时启动多个sequence，UVM通过优先级来仲裁先发送哪个transaction或者先启动哪个sequence。</p><p><strong>1）transaction的优先级</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> my_case0::main_phase(uvm_phase phase);<br>   sequence0 seq0;<br>   sequence1 seq1;<br><br>   seq0 = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;seq0&quot;</span>);<br>   seq0<span class="hljs-variable">.starting_phase</span> = phase;<br>   seq1 = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;seq1&quot;</span>);<br>   seq1<span class="hljs-variable">.starting_phase</span> = phase;<br>    env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.sqr</span><span class="hljs-variable">.set_arbitration</span>(SEQ_ARB_STRICT_FIFO);  <span class="hljs-comment">//仲裁算法</span><br>   <span class="hljs-keyword">fork</span> <span class="hljs-comment">// 并行启动sequence</span><br>      seq0<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.sqr</span>);<br>      seq1<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.sqr</span>);<br>   <span class="hljs-keyword">join</span><br><span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><p>transaction的优先级在&#96;uvm_pri_do宏中指定：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Verilog">`uvm_do_pri(m_trans, <span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><p><strong>除此之外还需要设置sequencer的仲裁算法：</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> set_arbitration(SEQ_ARB_TYPE val) <span class="hljs-comment">//原型</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>仲裁算法</th><th>描述</th></tr></thead><tbody><tr><td>SEQ_ARB_FIFO</td><td>Requests are granted in FIFO order (default)</td></tr><tr><td>SEQ_ARB_WEIGHTED</td><td>Requests are granted randomly by weight</td></tr><tr><td>SEQ_ARB_RANDOM</td><td>Requests are granted randomly</td></tr><tr><td>SEQ_ARB_STRICT_FIFO</td><td>Requests at highest priority granted in fifo order</td></tr><tr><td>SEQ_ARB_STRICT_RANDOM</td><td>Requests at highest priority granted in randomly</td></tr><tr><td>SEQ_ARB_USER</td><td>Arbitration is delegated to the user-defined function, user_priority_arbitration.  That function will specify the next sequence to grant.</td></tr></tbody></table><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.sqr</span><span class="hljs-variable">.set_arbitration</span>(SEQ_ARB_STRICT_FIFO);  <span class="hljs-comment">//仲裁算法</span><br></code></pre></td></tr></table></figure><p><strong>2）sequence的优先级</strong></p><p>sequence也有优先级，在start任务中指定：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> start (uvm_sequencer_base sequencer,  <br>uvm_sequence_base parent_sequence = <span class="hljs-literal">null</span>,<br><span class="hljs-keyword">int</span> this_priority = -<span class="hljs-number">1</span>,<br><span class="hljs-keyword">bit</span> call_pre_post = <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-keyword">class</span> sequence0 <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>   my_transaction m_trans;<br><br>   <span class="hljs-keyword">function</span>  <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name= <span class="hljs-string">&quot;sequence0&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>   <span class="hljs-keyword">endfunction</span> <br>   <br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>       <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <span class="hljs-comment">//sequence中控制objection</span><br>         starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">5</span>) <span class="hljs-keyword">begin</span><br>         `uvm_do(m_trans)<br>         `uvm_info(<span class="hljs-string">&quot;sequence0&quot;</span>, <span class="hljs-string">&quot;send one transaction&quot;</span>, UVM_MEDIUM)<br>      <span class="hljs-keyword">end</span><br>      #<span class="hljs-number">100</span>;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endtask</span><br><br>   `uvm_object_utils(sequence0)<br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">task</span> my_case0::main_phase(uvm_phase phase);<br>   sequence0 seq0;<br>   sequence1 seq1;<br><br>   seq0 = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;seq0&quot;</span>);<br>   seq0<span class="hljs-variable">.starting_phase</span> = phase;<span class="hljs-comment">//将phase传给seq0的starting_phase</span><br>   seq1 = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;seq1&quot;</span>);<br>   seq1<span class="hljs-variable">.starting_phase</span> = phase;<span class="hljs-comment">//手动启动sequence时需要给starting_phase赋值</span><br>   env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.sqr</span><span class="hljs-variable">.set_arbitration</span>(SEQ_ARB_STRICT_FIFO);<br>   <span class="hljs-keyword">fork</span><br>       seq0<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.sqr</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">100</span>); <span class="hljs-comment">//指定优先级</span><br>      seq1<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.sqr</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">200</span>);<br>   <span class="hljs-keyword">join</span><br><span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><p>在start中指定了sequence优先级，就不需要在&#96;uvm_do宏中指定transaction的优先级了。上面的设定中，seq1的优先级高，seq1中的transaction都发送完才会发送seq0中的transaction。</p><h4 id="4-2-sequencer的lock"><a href="#4-2-sequencer的lock" class="headerlink" title="4.2 sequencer的lock"></a>4.2 sequencer的lock</h4><h4 id="4-3-sequencer的grab"><a href="#4-3-sequencer的grab" class="headerlink" title="4.3 sequencer的grab"></a>4.3 sequencer的grab</h4><h4 id="4-4-sequence的有效性"><a href="#4-4-sequence的有效性" class="headerlink" title="4.4 sequence的有效性"></a>4.4 sequence的有效性</h4><p>sequencer在仲裁sequence时会查看sequence的有效性。查看Is_relevant函数的返回结果，如果为1，有效，为0，无效。<strong>所以可以通过重载is_relevant函数来控制sequence，使它无效。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-keyword">class</span> sequence0 <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>   my_transaction m_trans;<br>   <span class="hljs-keyword">int</span> num;<br>   <span class="hljs-keyword">bit</span> has_delayed;<br>    <br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">bit</span> is_relevant(); <span class="hljs-comment">//重载is_relevant</span><br>        <span class="hljs-keyword">if</span>((num &gt;= <span class="hljs-number">3</span>)&amp;&amp;(!has_delayed)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//如果条件成立则sequence无效，停止产生transaction。</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p>当sequencer发现其上启动的所有的sequence都无效的时候会调用wait_for_relevant并等待sequence（查看is_relevant的返回结果）有效。可以重载wait_for_relevant使无效的sequence有效。</p><p>如果sequence无效了，那么它需要等待其他有效的sequence都执行完，sequencer才会调用wait_for_relevant，所以sequence的无效是自己控制的，重新有效却受其他sequence控制。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> sequence0 <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>   my_transaction m_trans;<br>   <span class="hljs-keyword">int</span> num;<br>   <span class="hljs-keyword">bit</span> has_delayed;<br>    <br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">bit</span> is_relevant();<br>      <span class="hljs-keyword">if</span>((num &gt;= <span class="hljs-number">3</span>)&amp;&amp;(!has_delayed)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> wait_for_relevant();<br>      #<span class="hljs-number">10000</span>; <span class="hljs-comment">// 10000ns后，is_relevant中的判断条件无效，is_relevant返回1，sequence重新有效</span><br>      has_delayed = <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">endtask</span><br>   <span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p><strong>is_relevant、wait_for_relevant一般成对重载。</strong></p><h3 id="5-sequence进阶"><a href="#5-sequence进阶" class="headerlink" title="5. sequence进阶"></a>5. sequence进阶</h3><h4 id="5-1-嵌套sequence"><a href="#5-1-嵌套sequence" class="headerlink" title="5.1 嵌套sequence"></a>5.1 嵌套sequence</h4><p>sequence中不但可以发送transaction，也可以启动不同的sequence。可以启动不同sequence的sequence就是嵌套sequence，被嵌套的sequence和嵌套sequence在同一个sequencer中启动。</p><p>嵌套sequence不产生transaction，它只是调度sequence。</p><p><strong>被嵌套的sequence中产生的transaction可以被同一个sequencer发送。这是嵌套的前提条件。这些transaction需要虚sequencer支持的transaction类型相同或者派生自这个类型。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">class</span> crc_seq <span class="hljs-keyword">extends</span> uvm_sequence<span class="hljs-variable">#(my_transaction)</span>;<br>   `uvm_object_utils(crc_seq)<br>   <span class="hljs-keyword">function</span>  <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name= <span class="hljs-string">&quot;crc_seq&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>   <span class="hljs-keyword">endfunction</span> <br>   <br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body(); <span class="hljs-comment">//不控制objection</span><br>      my_transaction tr;<br>      `uvm_do_with(tr, &#123;tr<span class="hljs-variable">.crc_err</span> == <span class="hljs-number">1</span>;<br>                        tr<span class="hljs-variable">.dmac</span> == <span class="hljs-number">48&#x27;h980F</span>;&#125;)<br>   <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-keyword">class</span> case0_sequence <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>   my_transaction m_trans;<br>    ...<br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      crc_seq cseq;<br>      long_seq lseq;<br>       <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <span class="hljs-comment">//在嵌套sequence中控制objection</span><br>         starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>          `uvm_do(cseq)<span class="hljs-comment">//先启动cseq，再启动lseq</span><br>         `uvm_do(lseq)<br>      <span class="hljs-keyword">end</span><br>      #<span class="hljs-number">100</span>;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endtask</span><br><br>   `uvm_object_utils(case0_sequence)<br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p>也可以用start函数启动sequence：</p><p><strong>其中m_sequencer是启动sequence的sequencer。它是uvm_sequencer_base类型。它是uvm_sequence_item中的私有变量。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>     crc_seq cseq;<br>     long_seq lseq;<br>     <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>        starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>     <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>        cseq = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;cseq&quot;</span>);<br>         cseq<span class="hljs-variable">.start</span>(m_sequencer);<span class="hljs-comment">//启动sequence的sequencer</span><br>        lseq = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;lseq&quot;</span>);<br>        lseq<span class="hljs-variable">.start</span>(m_sequencer);<br>     <span class="hljs-keyword">end</span><br>     #<span class="hljs-number">100</span>;<br>     <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>        starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>  <span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><h4 id="5-2-sequence中也可以使用rand变量"><a href="#5-2-sequence中也可以使用rand变量" class="headerlink" title="5.2 sequence中也可以使用rand变量"></a>5.2 sequence中也可以使用rand变量</h4><p>&#96;uvm_do宏在启动sequence时也对他进行随机化。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-keyword">class</span> long_seq <span class="hljs-keyword">extends</span> uvm_sequence<span class="hljs-variable">#(my_transaction)</span>;<br>    <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">47</span>:<span class="hljs-number">0</span>] ldmac;  <span class="hljs-comment">//随机变量，它的名字不能和transaction类中的变量名重复。</span><br>   `uvm_object_utils(long_seq)<br>...<br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      my_transaction tr;<br>      `uvm_do_with(tr, &#123;tr<span class="hljs-variable">.crc_err</span> == <span class="hljs-number">0</span>;<br>                        tr<span class="hljs-variable">.pload</span><span class="hljs-variable">.size</span>() == <span class="hljs-number">1500</span>;<br>                        tr<span class="hljs-variable">.dmac</span> == ldmac;&#125;)<br>      tr<span class="hljs-variable">.print</span>();<br>   <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br><span class="hljs-keyword">class</span> case0_sequence <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>   my_transaction m_trans;<br>...<br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      long_seq lseq;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>          `uvm_do_with(lseq, &#123;lseq<span class="hljs-variable">.ldmac</span> == <span class="hljs-number">48&#x27;hFFFF</span>;&#125;)<span class="hljs-comment">//在启动lseq时对其随机化。</span><br>      <span class="hljs-keyword">end</span><br>      #<span class="hljs-number">100</span>;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endtask</span><br><br>   `uvm_object_utils(case0_sequence)<br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><h4 id="5-3-transaction的类型匹配"><a href="#5-3-transaction的类型匹配" class="headerlink" title="5.3 transaction的类型匹配"></a>5.3 transaction的类型匹配</h4><p>一个sequencer只能产生一种transaction，如果sequence在此sequencer上启动，那么sequence中产生的transaction必须是sequencer支持的类型或者派生自这个类型。</p><p>如果想要在sequencer产生完全不同的transaction，可以将sequencer的类型参数定义为uvm_sequence_item。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_sequencer <span class="hljs-keyword">extends</span> uvm_sequencer<span class="hljs-variable">#(uvm_sequence_item)</span><br><span class="hljs-keyword">class</span> my_driver <span class="hljs-keyword">extends</span> uvm_driver<span class="hljs-variable">#(uvm_sequence_item)</span><br></code></pre></td></tr></table></figure><p>需要在my_driver中用$cast函数将uvm_sequence_item类型转换成my_transaction 类型。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">class</span> my_driver <span class="hljs-keyword">extends</span> uvm_driver<span class="hljs-variable">#(uvm_sequence_item)</span>; <span class="hljs-comment">//uvm_sequence_item</span><br><span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br>   my_transaction m_tr;<span class="hljs-comment">//两种不同的transaction，在driver中判断传过来哪种transaction</span><br>   your_transaction y_tr;<br>   vif<span class="hljs-variable">.data</span> &lt;= <span class="hljs-number">8&#x27;b0</span>;<br>   vif<span class="hljs-variable">.valid</span> &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>   <span class="hljs-keyword">while</span>(!vif<span class="hljs-variable">.rst_n</span>)<br>      @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>      seq_item_port<span class="hljs-variable">.get_next_item</span>(req);<br>       <span class="hljs-keyword">if</span>(<span class="hljs-built_in">$cast</span>(m_tr, req)) <span class="hljs-keyword">begin</span><span class="hljs-comment">//如果req是my_transaction类型那么转化到m_tr</span><br>          drive_my_transaction(m_tr);<br>         `uvm_info(<span class="hljs-string">&quot;driver&quot;</span>, <span class="hljs-string">&quot;receive a transaction whose type is my_transaction&quot;</span>, UVM_MEDIUM)<br>      <span class="hljs-keyword">end</span><br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">$cast</span>(y_tr, req)) <span class="hljs-keyword">begin</span><span class="hljs-comment">//如果req是your_transaction类型那么转化到y_tr</span><br>         drive_your_transaction(y_tr);<br>         `uvm_info(<span class="hljs-string">&quot;driver&quot;</span>, <span class="hljs-string">&quot;receive a transaction whose type is your_transaction&quot;</span>, UVM_MEDIUM)<br>      <span class="hljs-keyword">end</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>         `uvm_error(<span class="hljs-string">&quot;driver&quot;</span>, <span class="hljs-string">&quot;receive a transaction whose type is unknown&quot;</span>)<br>      <span class="hljs-keyword">end</span><br>      seq_item_port<span class="hljs-variable">.item_done</span>();<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><h4 id="5-4p-sequencer变量"><a href="#5-4p-sequencer变量" class="headerlink" title="5.4p_sequencer变量"></a>5.4p_sequencer变量</h4><p>之前的m_sequencer是uvm_sequencer_base类型，p_sequencer是真正发送sequence的sequencer类型。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-keyword">class</span> case0_sequence <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>   my_transaction m_trans;<br>   `uvm_object_utils(case0_sequence)<br>    `uvm_declare_p_sequencer(my_sequencer) <span class="hljs-comment">//声明sequencer的类型</span><br>...   <br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>          <span class="hljs-comment">// 使用p_sequencer中的参数。</span><br>         `uvm_do_with(m_trans, &#123;m_trans<span class="hljs-variable">.dmac</span> == p_sequencer<span class="hljs-variable">.dmac</span>;<br>                                m_trans<span class="hljs-variable">.smac</span> == p_sequencer<span class="hljs-variable">.smac</span>;&#125;)<br>      <span class="hljs-keyword">end</span><br>      #<span class="hljs-number">100</span>;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endtask</span><br><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p><strong>p_sequencer主要用来指定virtual sequencer中的真正的sequencer。</strong></p><p>​            </p>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>UVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
      <tag>UVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM——sequence（二）</title>
    <link href="/2019/08/08/Verification/UVM/UVM%E2%80%94%E2%80%94sequence%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2019/08/08/Verification/UVM/UVM%E2%80%94%E2%80%94sequence%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="6-virtual-sequence"><a href="#6-virtual-sequence" class="headerlink" title="6. virtual sequence"></a>6. virtual sequence</h3><p>​    如果被嵌套的sequence需要在不同的sequencer中启动，也就是需要<strong>sequence之间同步</strong>，那么此时的嵌套sequence就是virtual sequence。它不产生transaction，只是控制其它sequence产生transaction发送给不同的sequencer，这就是为什么是virtual。</p><p>​    virtual sequence可以在启动的时候不需要sequencer，把它设成null，这也是它被称为virtual的另一个原因。</p><h4 id="6-1-sequence通过find函数拿到启动sequencer"><a href="#6-1-sequence通过find函数拿到启动sequencer" class="headerlink" title="6.1 sequence通过find函数拿到启动sequencer"></a>6.1 sequence通过find函数拿到启动sequencer</h4><p>​    virtual sequence中的sequence需要拿到启动的sequencer，这可以通过<strong>uvm_top的find函数</strong>，<strong>find函数通过传入component实例的名字可以返回这个实例的句柄，find函数返回uvm_component类型，需要转化哼真正的sequencer类型</strong>，这样就拿到了每个要启动的sequencer。</p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-keyword">class</span> runall_sequence <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(uvm_sequence_item)</span>;<span class="hljs-comment">// virtual sequence</span><br>   `uvm_object_utils(runall_sequence);<br><br>   <span class="hljs-keyword">protected</span> reset_sequence reset;<br>   <span class="hljs-keyword">protected</span> maxmult_sequence maxmult;<br>   <span class="hljs-keyword">protected</span> random_sequence random;<br>   <span class="hljs-keyword">protected</span> sequencer sequencer_h;<br>   <span class="hljs-keyword">protected</span> uvm_component uvm_component_h;<span class="hljs-comment">//find函数返回uvm_component类型</span><br>   <br> <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;runall_sequence&quot;</span>);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>    <br>     uvm_component_h =  uvm_top<span class="hljs-variable">.find</span>(<span class="hljs-string">&quot;*.env_h.sequencer_h&quot;</span>);<span class="hljs-comment">// 拿到启动的sequencer</span><br>     <span class="hljs-comment">// sequencer_h是env中的sequencer</span><br><br>    <span class="hljs-keyword">if</span> (uvm_component_h == <span class="hljs-literal">null</span>)<br>     `uvm_fatal(<span class="hljs-string">&quot;RUNALL SEQUENCE&quot;</span>, <span class="hljs-string">&quot;Failed to get the sequencer&quot;</span>)<br><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">$cast</span>(sequencer_h, uvm_component_h))<span class="hljs-comment">//将sequence_h转化成sequencer类型</span><br>      `uvm_fatal(<span class="hljs-string">&quot;RUNALL SEQUENCE&quot;</span>, <span class="hljs-string">&quot;Failed to cast from uvm_component_h.&quot;</span>)<br>     <br>    reset = reset_sequence::type_id::create(<span class="hljs-string">&quot;reset&quot;</span>);<br>    maxmult = maxmult_sequence::type_id::create(<span class="hljs-string">&quot;maxmult&quot;</span>);<br>    random = random_sequence::type_id::create(<span class="hljs-string">&quot;random&quot;</span>);<br> <span class="hljs-keyword">endfunction</span> : <span class="hljs-keyword">new</span><br><br> <span class="hljs-keyword">task</span> body();<br>     reset<span class="hljs-variable">.start</span>(sequencer_h);<span class="hljs-comment">//在sequencer上启动sequence</span><br>    maxmult<span class="hljs-variable">.start</span>(sequencer_h);<br>    random<span class="hljs-variable">.start</span>(sequencer_h);<br> <span class="hljs-keyword">endtask</span> : body<br>   <br><span class="hljs-keyword">endclass</span> : runall_sequence<br></code></pre></td></tr></table></figure><p>virtual sequence的启动，因为上面通过find，每个sequence都拿到了sequencer，所以virtual sequence不需要指定sequencer。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">class</span> full_test <span class="hljs-keyword">extends</span> tinyalu_base_test;<br>   `uvm_component_utils(full_test);<br>   <br>   runall_sequence runall_seq;<span class="hljs-comment">//定义virtual sequence</span><br><br>   <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);<br>      runall_seq = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;runall_seq&quot;</span>);<br>      phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>       runall_seq<span class="hljs-variable">.start</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">//启动virtual sequence，不需要指定sequencer</span><br>      phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endtask</span> : run_phase<br><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span> (<span class="hljs-keyword">string</span> name, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name,parent);<br>   <span class="hljs-keyword">endfunction</span> : <span class="hljs-keyword">new</span><br><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><h4 id="6-2-通过virtual-sequencer指定每个sequence的sequencer"><a href="#6-2-通过virtual-sequencer指定每个sequence的sequencer" class="headerlink" title="6.2 通过virtual sequencer指定每个sequence的sequencer"></a>6.2 通过virtual sequencer指定每个sequence的sequencer</h4><p>除了上面的find函数，还可以通过virtual sequencer指定每个sequence的sequencer。</p><p><strong>virtual sequencer中保存多个sequencer的句柄，指向真正要发送transaction的sequencer。</strong></p><p>virtual sequencer是对不同sequencer的封装，本身不发送transaction，主要让程序看起来舒服，容易理解——virtual sequence在virtual sequencer上启动，virtual sequence中的sequence在virtual sequencer中的sequencer启动。</p><p><strong>Virtual sequencer 有三个属性：</strong></p><p>(1)Virtual sequencer控制其他的sequencer</p><p>(2)Virtual sequencer并不和任何driver相连</p><p>(3)Virtual sequencer本身并不处理item</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-comment">//定义virtualsequencer</span><br><span class="hljs-keyword">class</span> my_vsqr <span class="hljs-keyword">extends</span> uvm_sequencer;<span class="hljs-comment">//不需要指定要发送的transaction类型</span><br>  <br>   my_sequencer p_sqr0;<br>   my_sequencer p_sqr1;<br>   <br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);<br>   <span class="hljs-keyword">endfunction</span> <br>   <br>   `uvm_component_utils(my_vsqr)<br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">//定义virtual sequence</span><br><span class="hljs-keyword">class</span> case0_vseq <span class="hljs-keyword">extends</span> uvm_sequence;<span class="hljs-comment">//不需要指定要发送的transaction类型</span><br>   `uvm_object_utils(case0_vseq)<br>   `uvm_declare_p_sequencer(my_vsqr) <br>...<br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      my_transaction tr;<br>      read_file_seq seq0;<br>      drv1_seq seq1;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>      `uvm_do_on_with(tr, p_sequencer<span class="hljs-variable">.p_sqr0</span>, &#123;tr<span class="hljs-variable">.pload</span><span class="hljs-variable">.size</span> == <span class="hljs-number">1500</span>;&#125;)<br>      `uvm_info(<span class="hljs-string">&quot;vseq&quot;</span>, <span class="hljs-string">&quot;send one longest packet on p_sequencer.p_sqr0&quot;</span>, UVM_MEDIUM)<br>      seq0 = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;seq0&quot;</span>);<br>      seq0<span class="hljs-variable">.file_name</span> = <span class="hljs-string">&quot;data.txt&quot;</span>;<br>      seq1 = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;seq1&quot;</span>);<br>      <span class="hljs-keyword">fork</span><br>          seq0<span class="hljs-variable">.start</span>(p_sequencer<span class="hljs-variable">.p_sqr0</span>);<span class="hljs-comment">//在sqr0上启动seq0</span><br>         seq1<span class="hljs-variable">.start</span>(p_sequencer<span class="hljs-variable">.p_sqr1</span>);<br>      <span class="hljs-keyword">join</span> <br>      #<span class="hljs-number">100</span>;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-comment">// 在virtual sequencer上启动virtual sequence</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case0::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br><br>   uvm_config_db<span class="hljs-variable">#(uvm_object_wrapper)</span>::set(<span class="hljs-keyword">this</span>, <br>                                           <span class="hljs-string">&quot;v_sqr.main_phase&quot;</span>, <br>                                           <span class="hljs-string">&quot;default_sequence&quot;</span>, <br>                                           case0_vseq::type_id::get());<br><span class="hljs-keyword">endfunction</span><br></code></pre></td></tr></table></figure><h4 id="6-3-只在virtual-sequence中控制objection"><a href="#6-3-只在virtual-sequence中控制objection" class="headerlink" title="6.3 只在virtual sequence中控制objection"></a>6.3 只在virtual sequence中控制objection</h4><p>上一节中只在virtual sequence中控制objection。</p><p>virtual sequence不仅调度transaction，也对objection进行调度，避免层层查找在哪里调度了objection。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-comment">//非virtual sequence不控制objection</span><br><span class="hljs-keyword">class</span> drv1_seq <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>   my_transaction m_trans;<br>   `uvm_object_utils(drv1_seq)<br><br>   <span class="hljs-keyword">function</span>  <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name= <span class="hljs-string">&quot;drv1_seq&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>   <span class="hljs-keyword">endfunction</span> <br>   <br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<span class="hljs-comment">//不控制objection</span><br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>         `uvm_do(m_trans)<br>         `uvm_info(<span class="hljs-string">&quot;drv1_seq&quot;</span>, <span class="hljs-string">&quot;send one transaction&quot;</span>, UVM_MEDIUM)<br>      <span class="hljs-keyword">end</span><br>   <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p>除了手工启动（start函数)时需要给starting_phase赋值外，只有将sequence作为sequencer的某动态运行的phase的default_sequence时，starting_phase才不为null。如果将某sequence作为uvm_do宏的参数，那么此sequence的starting_phase为null。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-comment">// 手工给starting_phase赋值</span><br><span class="hljs-keyword">task</span> my_case0::main_phase(uvm_phase phase);<br>   sequence0 seq0;<br>   sequence1 seq1;<br><br>   seq0 = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;seq0&quot;</span>);<br>   seq0<span class="hljs-variable">.starting_phase</span> = phase;<span class="hljs-comment">//将phase传给seq0的starting_phase</span><br>   seq1 = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;seq1&quot;</span>);<br>   seq1<span class="hljs-variable">.starting_phase</span> = phase;<span class="hljs-comment">//手动启动sequence时需要给starting_phase赋值</span><br>   env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.sqr</span><span class="hljs-variable">.set_arbitration</span>(SEQ_ARB_STRICT_FIFO);<br>   <span class="hljs-keyword">fork</span><br>       seq0<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.sqr</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">100</span>); <span class="hljs-comment">//指定优先级</span><br>      seq1<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.sqr</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">200</span>);<br>   <span class="hljs-keyword">join</span><br><span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><h4 id="6-4-在sequence慎用fork-join-none"><a href="#6-4-在sequence慎用fork-join-none" class="headerlink" title="6.4 在sequence慎用fork join_none"></a>6.4 在sequence慎用fork join_none</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> vseq <span class="hljs-keyword">extends</span> uvm_sequence;<br>my_sequence seq[<span class="hljs-number">4</span>];<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>           <span class="hljs-keyword">fork</span><br>               <span class="hljs-keyword">automatic</span> <span class="hljs-keyword">int</span> j=i;<br>               `uvm_do_on(seq[j],p_sequencer<span class="hljs-variable">.p_sqr</span>[j]);<br>           <span class="hljs-keyword">join_none</span><br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p>上面例子中在fork join_none中并行调用&#96;uvm_do，将for展开其实如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> vseq <span class="hljs-keyword">extends</span> uvm_sequence;<br>my_sequence seq[<span class="hljs-number">4</span>];<br>     <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>        <span class="hljs-keyword">fork</span><br>          uvm_do_on(seq[<span class="hljs-number">0</span>],p_sequencer<span class="hljs-variable">.p_sqr</span>[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">join_none</span><br>        <span class="hljs-keyword">fork</span><br>          uvm_do_on(seq[<span class="hljs-number">1</span>],p_sequencer<span class="hljs-variable">.p_sqr</span>[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">join_none</span><br>        <span class="hljs-keyword">fork</span><br>          uvm_do_on(seq[<span class="hljs-number">2</span>],p_sequencer<span class="hljs-variable">.p_sqr</span>[<span class="hljs-number">2</span>]);<br>        <span class="hljs-keyword">join_none</span><br>        <span class="hljs-keyword">fork</span><br>          uvm_do_on(seq[<span class="hljs-number">3</span>],p_sequencer<span class="hljs-variable">.p_sqr</span>[<span class="hljs-number">3</span>]);<br>        <span class="hljs-keyword">join_none</span><br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p>当着四个进行都调用了，body任务就执行完了，sequence就执行完了，系统会杀死这个sequence，清空之前占据的内存，也会杀死启动的进程，那么这几个进程还没执行完就被杀死，所以sequence根本没有执行。</p><p><strong>解决方法：</strong>wait fork</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> vseq <span class="hljs-keyword">extends</span> uvm_sequence;<br>my_sequence seq[<span class="hljs-number">4</span>];<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>           <span class="hljs-keyword">fork</span><br>               <span class="hljs-keyword">automatic</span> <span class="hljs-keyword">int</span> j=i;<br>               `uvm_do_on(seq[j],p_sequencer<span class="hljs-variable">.p_sqr</span>[j]);<br>           <span class="hljs-keyword">join_none</span><br>        <span class="hljs-keyword">wait</span> <span class="hljs-keyword">fork</span>;   <span class="hljs-comment">//等待当前层次上的fork执行完。   </span><br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-keyword">class</span> vseq <span class="hljs-keyword">extends</span> uvm_sequence;<br>my_sequence seq[<span class="hljs-number">4</span>];<br>     <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>        <span class="hljs-keyword">fork</span><br>          uvm_do_on(seq[<span class="hljs-number">0</span>],p_sequencer<span class="hljs-variable">.p_sqr</span>[<span class="hljs-number">0</span>]);<br>          uvm_do_on(seq[<span class="hljs-number">1</span>],p_sequencer<span class="hljs-variable">.p_sqr</span>[<span class="hljs-number">1</span>]);<br>          uvm_do_on(seq[<span class="hljs-number">2</span>],p_sequencer<span class="hljs-variable">.p_sqr</span>[<span class="hljs-number">2</span>]);<br>          uvm_do_on(seq[<span class="hljs-number">3</span>],p_sequencer<span class="hljs-variable">.p_sqr</span>[<span class="hljs-number">3</span>]);<br>        <span class="hljs-keyword">join</span> <span class="hljs-comment">//执行完 fork join才会往下执行</span><br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><h3 id="7-在sequence中使用config-db"><a href="#7-在sequence中使用config-db" class="headerlink" title="7. 在sequence中使用config_db"></a>7. 在sequence中使用config_db</h3><h4 id="7-1-在sequence中获得参数"><a href="#7-1-在sequence中获得参数" class="headerlink" title="7.1 在sequence中获得参数"></a>7.1 在sequence中获得参数</h4><p><strong>UVM中使用get_full_name()可以获得对象的层次路径。</strong>比如在一个sequence中调用这个函数，返回：</p><p><strong>uvm_test_top.env.i_agt.sqr.seq0</strong></p><p><strong>启动这个sequence的sequencer路径和这个sequence实例化时的名字</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-comment">// case中设置sequence中的参数</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> my_case0::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br><span class="hljs-comment">// 设置sequence中的参数，用通配符</span><br>   uvm_config_db<span class="hljs-variable">#(int)::set(this, &quot;env.i_agt.sqr.*&quot;, &quot;count&quot;, 9)</span>;<br><br>   uvm_config_db<span class="hljs-variable">#(uvm_object_wrapper)</span>::set(<span class="hljs-keyword">this</span>, <br>                                           <span class="hljs-string">&quot;env.i_agt.sqr.main_phase&quot;</span>, <br>                                           <span class="hljs-string">&quot;default_sequence&quot;</span>, <br>                                           case0_sequence::type_id::get());<br><span class="hljs-keyword">endfunction</span><br></code></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-comment">// 在sequence的pre_body中取得参数</span><br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> case0_sequence::pre_body();<br>      <span class="hljs-keyword">if</span>(uvm_config_db<span class="hljs-variable">#(int)::get(null, get_full_name(), &quot;count&quot;, count))</span><br>         `uvm_info(<span class="hljs-string">&quot;seq0&quot;</span>, <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;get count value %0d via config_db&quot;</span>, count), UVM_MEDIUM)<br>      <span class="hljs-keyword">else</span><br>         `uvm_error(<span class="hljs-string">&quot;seq0&quot;</span>, <span class="hljs-string">&quot;can&#x27;t get count value!&quot;</span>) <br>   <span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><h4 id="7-2-在sequence中设置参数"><a href="#7-2-在sequence中设置参数" class="headerlink" title="7.2 在sequence中设置参数"></a>7.2 在sequence中设置参数</h4><p>在sequence可以向component设置参数；也可以向sequence中设置参数。</p><p>sequence是动态运行的，它什么时候要设置参数不固定，component需要知道什么时候sequence设置了参数，这通过<strong>wait_modified</strong>任务实现。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">//设置参数</span><br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> case0_vseq::body();<br>      my_transaction tr;<br>      drv0_seq seq0;<br>      drv1_seq seq1;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>      <span class="hljs-keyword">fork</span><br>         `uvm_do_on(seq0, p_sequencer<span class="hljs-variable">.p_sqr0</span>);<br>         `uvm_do_on(seq1, p_sequencer<span class="hljs-variable">.p_sqr1</span>);<br>         <span class="hljs-keyword">begin</span><br>            #<span class="hljs-number">10000</span>;<br>             uvm_config_db<span class="hljs-variable">#(bit)::set(uvm_root::get(), &quot;uvm_test_top.env0.scb&quot;, &quot;cmp_en&quot;, 0)</span>;<span class="hljs-comment">//向scb中设置参数</span><br>            #<span class="hljs-number">10000</span>;<br>            uvm_config_db<span class="hljs-variable">#(bit)::set(uvm_root::get(), &quot;uvm_test_top.env0.scb&quot;, &quot;cmp_en&quot;, 1)</span>;<br>         <span class="hljs-keyword">end</span><br>      <span class="hljs-keyword">join</span> <br>      #<span class="hljs-number">100</span>;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-comment">// scb中取得参数</span><br><span class="hljs-keyword">task</span> my_scoreboard::main_phase(uvm_phase phase);<br>   my_transaction  get_expect,  get_actual, tmp_tran;<br>   <span class="hljs-keyword">bit</span> result;<br>   <span class="hljs-keyword">bit</span> cmp_en = <span class="hljs-number">1&#x27;b1</span>;<br> <br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.main_phase</span>(phase);<br>   <span class="hljs-keyword">fork</span><br>      <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>          <span class="hljs-comment">// 等待cmp_en改变，否则阻塞</span><br>         uvm_config_db<span class="hljs-variable">#(bit)::wait_modified(this, &quot;&quot;, &quot;cmp_en&quot;)</span>;<br>         <span class="hljs-keyword">void</span>&#x27;(uvm_config_db<span class="hljs-variable">#(bit)::get(this, &quot;&quot;, &quot;cmp_en&quot;, cmp_en))</span>; <br>         `uvm_info(<span class="hljs-string">&quot;my_scoreboard&quot;</span>, <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;cmp_en value modified, the new value is %0d&quot;</span>, cmp_en), UVM_LOW)<br>      <span class="hljs-keyword">end</span><br>     ...<br>   <span class="hljs-keyword">join</span><br><span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><p>sequence宏的wait_modified类似：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs verilog"> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> drv0_seq::body();<br>      <span class="hljs-keyword">bit</span> send_en = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">fork</span><br>         <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>            uvm_config_db<span class="hljs-variable">#(bit)::wait_modified(null, get_full_name(), &quot;send_en&quot;)</span>;<br>            <span class="hljs-keyword">void</span>&#x27;(uvm_config_db<span class="hljs-variable">#(bit)::get(null, get_full_name, &quot;send_en&quot;, send_en))</span>; <br>            `uvm_info(<span class="hljs-string">&quot;drv0_seq&quot;</span>, <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;send_en value modified, the new value is %0d&quot;</span>, send_en), UVM_LOW)<br>         <span class="hljs-keyword">end</span><br>      <span class="hljs-keyword">join_none</span><br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>         `uvm_do(m_trans)<br>      <span class="hljs-keyword">end</span><br>   <span class="hljs-keyword">endtask</span><br><span class="hljs-comment">//在virtual sequence中启动这个sequence</span><br></code></pre></td></tr></table></figure><h3 id="8-sequence的响应"><a href="#8-sequence的响应" class="headerlink" title="8. sequence的响应"></a>8. sequence的响应</h3><p>UVM中的sequence机制提供了sequence-&gt;sequencer-&gt;driver的数据传输机制，有时sequence也需要知道driver的响应，进而sequence调整产生的transaction。</p><h4 id="8-1-put-response和get-response"><a href="#8-1-put-response和get-response" class="headerlink" title="8.1 put_response和get_response"></a>8.1 put_response和get_response</h4><p><strong>rsp是UVM中定义的变量。</strong></p><p><strong>在sequence中get  response：</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// 在sequence获得response</span><br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>          `uvm_do(m_trans)<span class="hljs-comment">//发送transaction</span><br>          get_response(rsp);<span class="hljs-comment">//发送完tr后获得响应</span><br>         `uvm_info(<span class="hljs-string">&quot;seq&quot;</span>, <span class="hljs-string">&quot;get one response&quot;</span>, UVM_MEDIUM)<br>         rsp<span class="hljs-variable">.print</span>();<span class="hljs-comment">//对相应进行处理</span><br>      <span class="hljs-keyword">end</span><br>      #<span class="hljs-number">100</span>;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><p><strong>在driver中put response：</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-comment">// 在driver中返回响应</span><br><span class="hljs-keyword">task</span> my_driver::main_phase(uvm_phase phase);<br>   vif<span class="hljs-variable">.data</span> &lt;= <span class="hljs-number">8&#x27;b0</span>;<br>   vif<span class="hljs-variable">.valid</span> &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>   <span class="hljs-keyword">while</span>(!vif<span class="hljs-variable">.rst_n</span>)<br>      @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>      seq_item_port<span class="hljs-variable">.get_next_item</span>(req);<br>      drive_one_pkt(req);<br>       rsp = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;rsp&quot;</span>);<span class="hljs-comment">//驱动完tr后，put response</span><br>       rsp<span class="hljs-variable">.set_id_info</span>(req);<span class="hljs-comment">//设置id，将req与rsp对应</span><br>       seq_item_port<span class="hljs-variable">.put_response</span>(rsp);<span class="hljs-comment">//返回response</span><br>       seq_item_port<span class="hljs-variable">.item_done</span>();<span class="hljs-comment">//最后调用item_done告诉sqr我发送完一个tr了，你可以发送下一个tr给我了</span><br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><p><strong>设置了id才知道哪个响应传给哪个sequence。</strong></p><p><strong>还可以直接在item_done中返回响应：</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-comment">// 在driver中返回响应</span><br><span class="hljs-keyword">task</span> my_driver::main_phase(uvm_phase phase);<br>   vif<span class="hljs-variable">.data</span> &lt;= <span class="hljs-number">8&#x27;b0</span>;<br>   vif<span class="hljs-variable">.valid</span> &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>   <span class="hljs-keyword">while</span>(!vif<span class="hljs-variable">.rst_n</span>)<br>      @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>      seq_item_port<span class="hljs-variable">.get_next_item</span>(req);<br>      drive_one_pkt(req);<br>      rsp = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;rsp&quot;</span>);<br>       rsp<span class="hljs-variable">.set_id_info</span>(req);<span class="hljs-comment">//设置id，将req与rsp对应</span><br>       seq_item_port<span class="hljs-variable">.item_done</span>(rsp);<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><p><strong>调用get_response(rsp)的时候，如果response_queue中没有响应，会阻塞在哪里，不能继续发送transaction。</strong></p><h4 id="8-2-response-handler和另类response"><a href="#8-2-response-handler和另类response" class="headerlink" title="8.2 response handler和另类response"></a>8.2 response handler和另类response</h4><p>上面提到的get_response阻塞问题，主要是因为发送transaction和get_response在同一个进程中，</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs VERILOG">`uvm_do(m_trans)<span class="hljs-comment">//发送transaction</span><br> get_response(rsp);<span class="hljs-comment">//获得响应</span><br></code></pre></td></tr></table></figure><p>如果分开就可以解决阻塞问题，需要使用response_handler：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-keyword">class</span> case0_sequence <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(my_transaction)</span>;<br>   my_transaction m_trans;<br>...<br>   <br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> pre_body();<br>       use_response_handler(<span class="hljs-number">1</span>);<span class="hljs-comment">//打开response_handler</span><br>   <span class="hljs-keyword">endtask</span><br>  <span class="hljs-comment">//重载response_handler函数</span><br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> response_handler(uvm_sequence_item response);<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">$cast</span>(rsp, response))<span class="hljs-comment">//类型转换成my_transaction类型</span><br>         `uvm_error(<span class="hljs-string">&quot;seq&quot;</span>, <span class="hljs-string">&quot;can&#x27;t cast&quot;</span>)<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>         `uvm_info(<span class="hljs-string">&quot;seq&quot;</span>, <span class="hljs-string">&quot;get one response&quot;</span>, UVM_MEDIUM)<br>          rsp<span class="hljs-variable">.print</span>(); <span class="hljs-comment">//对响应进行处理</span><br>      <span class="hljs-keyword">end</span><br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>          `uvm_do(m_trans)<span class="hljs-comment">//body中只发送transaction</span><br>      <span class="hljs-keyword">end</span><br>      #<span class="hljs-number">100</span>;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endtask</span><br><br>   `uvm_object_utils(case0_sequence)<br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><h4 id="8-3-另类的响应"><a href="#8-3-另类的响应" class="headerlink" title="8.3 另类的响应"></a>8.3 另类的响应</h4><p><strong>uvm_do执行完后，它的第一个参数不是空指针，而是指向刚刚发送到driver的transaction；可以在driver将需要返回的信息传给这个transaction中，在sequence中调用完&#96;uvm_do之后获取transaction中的信息。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">//driver中返回信息到transaction</span><br><span class="hljs-keyword">task</span> my_driver::main_phase(uvm_phase phase);<br>   vif<span class="hljs-variable">.data</span> &lt;= <span class="hljs-number">8&#x27;b0</span>;<br>   vif<span class="hljs-variable">.valid</span> &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>   <span class="hljs-keyword">while</span>(!vif<span class="hljs-variable">.rst_n</span>)<br>      @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>      seq_item_port<span class="hljs-variable">.get_next_item</span>(req);<br>      drive_one_pkt(req);<br>      req<span class="hljs-variable">.frm_drv</span> = <span class="hljs-string">&quot;this is information from driver&quot;</span>;<span class="hljs-comment">//将信息存到穿过来的transaction中。</span><br>      seq_item_port<span class="hljs-variable">.item_done</span>();<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">//在sequence获得driver返回的信息。</span><br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> case0_sequence::body();<br>     <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>        starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>     <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>        `uvm_do(m_trans)<br>        `uvm_info(<span class="hljs-string">&quot;seq&quot;</span>, <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;get information from driver: %0s&quot;</span>, m_trans<span class="hljs-variable">.frm_drv</span>), UVM_MEDIUM)<span class="hljs-comment">//获得driver返回的信息</span><br>     <span class="hljs-keyword">end</span><br>     #<span class="hljs-number">100</span>;<br>     <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>        starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>  <span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><h3 id="9-sequence-library"><a href="#9-sequence-library" class="headerlink" title="9. sequence library"></a>9. sequence library</h3><p>根据特定算法随机选择注册在其中的sequence，并在body中执行这些sequence。</p><h3 id="10-补充一种启动sequence的方法"><a href="#10-补充一种启动sequence的方法" class="headerlink" title="10. 补充一种启动sequence的方法"></a>10. 补充一种启动sequence的方法</h3><p><strong>在sequence外，通过sequence句柄调用sequence中发送transaction的任务。</strong></p><p><strong>原理是：之前把发送transaction的语句写在了body中，sequence启动后，自动调用body，所以我们也可以把发送transaction语句写在其他任务中，让body为空。我们在sequence启动后，手动调用这些任务发送transaction。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> sequence1 <span class="hljs-keyword">extends</span> uvm_sequence<span class="hljs-variable">#(transaction)</span>;<br><br>`uvm_object_utils(sequence1);<br><span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name=<span class="hljs-string">&quot;sequence1&quot;</span>);<br>  <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br><span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">task</span> write();<br>  transaction tr;<br>  `uvm_info(get_type_name(),<span class="hljs-string">&quot;write&quot;</span>,UVM_LOW)<br>  `uvm_do(tr);<br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">task</span> read();<br>  transaction tr;<br>  `uvm_info(get_type_name(),<span class="hljs-string">&quot;read&quot;</span>,UVM_LOW)<br>  `uvm_do(tr);<br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">task</span> pre_body();<br>  <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>)<br>    starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>  `uvm_info(get_type_name(),<span class="hljs-string">&quot;pre_body&quot;</span>,UVM_LOW)<br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">task</span> body();<br>  `uvm_info(get_type_name(),<span class="hljs-string">&quot;body&quot;</span>,UVM_LOW)<br>  <span class="hljs-keyword">wait</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">task</span> post_body();<br>  `uvm_info(get_type_name(),<span class="hljs-string">&quot;post_body&quot;</span>,UVM_LOW)<br> <span class="hljs-keyword">if</span>(starting_phase!=<span class="hljs-literal">null</span>)<br>    starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br><span class="hljs-comment">//在case中启动启动</span><br><span class="hljs-keyword">class</span> case0 <span class="hljs-keyword">extends</span> base_test;<br>  `uvm_component_utils(case0);<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name=<span class="hljs-string">&quot;case0&quot;</span>,uvm_component parent=<span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name,parent);<br>  <span class="hljs-keyword">endfunction</span><br><br>  <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);<br>  sequence1 seq1;<br>    seq1=<span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;seq1&quot;</span>);<br>  <span class="hljs-keyword">fork</span><br>      <span class="hljs-keyword">begin</span><br>    seq1<span class="hljs-variable">.starting_phase</span> = phase;<br>    seq1<span class="hljs-variable">.start</span>(env0<span class="hljs-variable">.sqr</span>);<br>      <span class="hljs-keyword">end</span><br>      <span class="hljs-keyword">begin</span><br>          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) <span class="hljs-keyword">begin</span><br>            seq1<span class="hljs-variable">.write</span>();<br>            seq1<span class="hljs-variable">.read</span>();<br>          <span class="hljs-keyword">end</span><br>      <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">join_none</span><br>  <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">27</span>:UVM_INFO seq/sequence1<span class="hljs-selector-class">.sv</span>(<span class="hljs-number">13</span>) @ <span class="hljs-number">0</span>: uvm_test_top<span class="hljs-selector-class">.env0</span>.sqr@@seq1 <span class="hljs-selector-attr">[sequence1]</span> write<br><span class="hljs-number">28</span>:UVM_INFO seq/sequence1<span class="hljs-selector-class">.sv</span>(<span class="hljs-number">25</span>) @ <span class="hljs-number">0</span>: uvm_test_top<span class="hljs-selector-class">.env0</span>.sqr@@seq1 <span class="hljs-selector-attr">[sequence1]</span> pre_body<br><span class="hljs-number">29</span>:UVM_INFO seq/sequence1<span class="hljs-selector-class">.sv</span>(<span class="hljs-number">28</span>) @ <span class="hljs-number">0</span>: uvm_test_top<span class="hljs-selector-class">.env0</span>.sqr@@seq1 <span class="hljs-selector-attr">[sequence1]</span> <span class="hljs-selector-tag">body</span><br><span class="hljs-number">54</span>:UVM_INFO seq/sequence1<span class="hljs-selector-class">.sv</span>(<span class="hljs-number">19</span>) @ <span class="hljs-number">0</span>: uvm_test_top<span class="hljs-selector-class">.env0</span>.sqr@@seq1 <span class="hljs-selector-attr">[sequence1]</span> read<br><span class="hljs-number">79</span>:UVM_INFO seq/sequence1<span class="hljs-selector-class">.sv</span>(<span class="hljs-number">13</span>) @ <span class="hljs-number">0</span>: uvm_test_top<span class="hljs-selector-class">.env0</span>.sqr@@seq1 <span class="hljs-selector-attr">[sequence1]</span> write<br>....<br><span class="hljs-number">454</span>:UVM_INFO seq/sequence1<span class="hljs-selector-class">.sv</span>(<span class="hljs-number">19</span>) @ <span class="hljs-number">0</span>: uvm_test_top<span class="hljs-selector-class">.env0</span>.sqr@@seq1 <span class="hljs-selector-attr">[sequence1]</span> read<br><span class="hljs-number">479</span>:UVM_INFO seq/sequence1<span class="hljs-selector-class">.sv</span>(<span class="hljs-number">13</span>) @ <span class="hljs-number">0</span>: uvm_test_top<span class="hljs-selector-class">.env0</span>.sqr@@seq1 <span class="hljs-selector-attr">[sequence1]</span> write<br><span class="hljs-number">504</span>:UVM_INFO seq/sequence1<span class="hljs-selector-class">.sv</span>(<span class="hljs-number">19</span>) @ <span class="hljs-number">0</span>: uvm_test_top<span class="hljs-selector-class">.env0</span>.sqr@@seq1 <span class="hljs-selector-attr">[sequence1]</span> read<br><span class="hljs-number">529</span>:UVM_INFO seq/sequence1<span class="hljs-selector-class">.sv</span>(<span class="hljs-number">33</span>) @ <span class="hljs-number">1000000</span>: uvm_test_top<span class="hljs-selector-class">.env0</span>.sqr@@seq1 <span class="hljs-selector-attr">[sequence1]</span> post_body<br><span class="hljs-number">543</span>:<span class="hljs-selector-attr">[sequence1]</span>    <span class="hljs-number">23</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>UVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
      <tag>UVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Verilog——文件读写</title>
    <link href="/2019/08/07/Verilog/Verilog%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"/>
    <url>/2019/08/07/Verilog/Verilog%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h3 id="1-读取文件"><a href="#1-读取文件" class="headerlink" title="1. 读取文件"></a>1. 读取文件</h3><p>读取文件是之前在CSDN中整理的，<a href="https://blog.csdn.net/m0_38037810/article/details/79598647"><strong>链接</strong></a></p><p><strong>$readmemb和$readmemh</strong>用来从文件中读取数据到存储器中。</p><p><strong>读取的内容只包括：空白位置（空格、换行、制表格(tab和form-feeds),注释行、二进制或十六进制的数字。</strong></p><p>数字中不能包含位宽说明和格式说明，其中readmemb要求每个数字是二进制数，readmemh要求每个数字必须是十六进制数字。数字中不定值x或X，高阻值z或Z，和下划线(_)的使用方法和代表意义与一般Verilog HDL程序中的用法一致。</p><h4 id="在Verilog语法中，一共有以下六种用法："><a href="#在Verilog语法中，一共有以下六种用法：" class="headerlink" title="在Verilog语法中，一共有以下六种用法："></a>在Verilog语法中，一共有以下六种用法：</h4><p>（1）$readmemb(“&lt;数据文件名&gt;”,&lt;存储器名&gt;);</p><p>（2）$readmemb(“&lt;数据文件名&gt;”,&lt;存储器名&gt;,&lt;起始地址&gt;);</p><p>（3）$readmemb(“&lt;数据文件名&gt;”,&lt;存储器名&gt;,&lt;起始地址&gt;,&lt;终止地址&gt;);</p><p>（4）$readmemh(“&lt;数据文件名&gt;”,&lt;存储器名&gt;);</p><p>（5）$readmemh(“&lt;数据文件名&gt;”,&lt;存储器名&gt;,&lt;起始地址&gt;);</p><p>（6）$readmemh(“&lt;数据文件名&gt;”,&lt;存储器名&gt;,&lt;起始地址&gt;,&lt;终止地址&gt;);</p><h5 id="（1）-readmemb的使用"><a href="#（1）-readmemb的使用" class="headerlink" title="（1）$readmemb的使用"></a><strong>（1）$readmemb的使用</strong></h5><p>先在Verilog代码目录下准备一个文件file1.txt,存入数据：</p><p>1111 1010 0101 1x1z 1_1_ 1_111    </p><p>或者</p><p>1111</p><p>1010 </p><p>0101 </p><p>1x1z </p><p>1_1_ </p><p>1_111</p><p>存在一行每个用空格隔开，跟分行存，输出结果是一样的，但是若在一行中不用空格隔开会出错，编译器会试图把一整行数据存在一个存储单元（下面程序中，4bit为一个存储单元）中。</p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">timescale</span> 10ns/1ns</span><br><span class="hljs-keyword">module</span> test;<br><span class="hljs-keyword">reg</span>[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] memory[<span class="hljs-number">0</span>:<span class="hljs-number">7</span>];<span class="hljs-comment">//申请八个四位的存储单元</span><br><span class="hljs-keyword">reg</span>[<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] n;<br><span class="hljs-keyword">initial</span><br><span class="hljs-keyword">begin</span><br><span class="hljs-built_in">$readmemb</span>(<span class="hljs-string">&quot;file1.txt&quot;</span>,memory); <span class="hljs-comment">//读取file1.txt中的数字到memory</span><br><span class="hljs-keyword">for</span>(n=<span class="hljs-number">0</span>;n&lt;=<span class="hljs-number">7</span>;n=n+<span class="hljs-number">1</span>)   <span class="hljs-comment">//把八个存储单元的数字都读取出来，若存的数不到八个单元输出x态，程序结果中会看到</span><br><span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;%b&quot;</span>,memory[n]);<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># 1111</span><br><span class="hljs-meta"># 1010</span><br><span class="hljs-meta"># 0101</span><br><span class="hljs-meta"># 1x1z              不定态和高阻态输出依旧为不定态和高阻态</span><br><span class="hljs-meta"># 0011              文件中村的是1_1_，空格当没有</span><br><span class="hljs-meta"># 1111               空格当没有</span><br><span class="hljs-meta"># xxxx                文件中只有六个数据，剩下两个输出为不定态x</span><br><span class="hljs-meta"># xxxx</span><br></code></pre></td></tr></table></figure><h5 id="（2）-readmemh的使用"><a href="#（2）-readmemh的使用" class="headerlink" title="（2）$readmemh的使用"></a><strong>（2）$readmemh的使用</strong></h5><p>准一个文件file2.txt，存入：</p><p>1234 5678 9012</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><br><span class="hljs-meta">`<span class="hljs-keyword">timescale</span> 10ns/1ns</span><br><span class="hljs-keyword">module</span> test;<br><span class="hljs-keyword">reg</span> set;<br><span class="hljs-keyword">reg</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] memory[<span class="hljs-number">0</span>:<span class="hljs-number">7</span>];    <span class="hljs-comment">//注意这里每个存储单元的长度为16位，因为每个数字是四位十六进制数，换算成二进制数是16位</span><br><span class="hljs-keyword">reg</span>[<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] n;<br><span class="hljs-keyword">initial</span><br><span class="hljs-keyword">begin</span><br><span class="hljs-built_in">$readmemh</span>(<span class="hljs-string">&quot;file2.txt&quot;</span>,memory);<br><span class="hljs-keyword">for</span>(n=<span class="hljs-number">0</span>;n&lt;=<span class="hljs-number">7</span>;n=n+<span class="hljs-number">1</span>)<br><span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;%h&quot;</span>,memory[n]);<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span>  <br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># 1234</span><br><span class="hljs-meta"># 5678</span><br><span class="hljs-meta"># 9012</span><br><span class="hljs-meta"># xxxx</span><br><span class="hljs-meta"># xxxx</span><br><span class="hljs-meta"># xxxx</span><br><span class="hljs-meta"># xxxx</span><br><span class="hljs-meta"># xxxx</span><br></code></pre></td></tr></table></figure><h3 id="2-写入文件"><a href="#2-写入文件" class="headerlink" title="2. 写入文件"></a>2. 写入文件</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">integer</span> Write_Out_File;<br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>Write_Out_File = fopen(<span class="hljs-string">&quot;Write_Out_File.txt&quot;</span>);<br><span class="hljs-built_in">$fdisplay</span>(Write_Out_File,<span class="hljs-string">&quot;@%0t : this is a test!&quot;</span>,<span class="hljs-built_in">$time</span>);<br><span class="hljs-built_in">$fclose</span>(Write_Out_File);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>Verilog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Verilog——分频器</title>
    <link href="/2019/08/06/Verilog/Verilog%E2%80%94%E2%80%94%E5%88%86%E9%A2%91%E5%99%A8/"/>
    <url>/2019/08/06/Verilog/Verilog%E2%80%94%E2%80%94%E5%88%86%E9%A2%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>在面试比试中经常出现的奇数时钟分频电路。</strong></p><h3 id="1-不用时钟下降沿触发的3分频电路"><a href="#1-不用时钟下降沿触发的3分频电路" class="headerlink" title="1. 不用时钟下降沿触发的3分频电路"></a>1. 不用时钟下降沿触发的3分频电路</h3><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> ClockDiv(  <span class="hljs-comment">// 3 分频</span><br>    <span class="hljs-keyword">input</span> clk_i,<br>    <span class="hljs-keyword">input</span> rst_n,<br>    <span class="hljs-keyword">output</span>  clk_o<br>    );<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] cnt;<br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk_i <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rst_n) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span>(rst_n == <span class="hljs-number">1&#x27;b0</span>) cnt&lt;=<span class="hljs-number">&#x27;b0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">2</span>) cnt &lt;= <span class="hljs-number">&#x27;b0</span>;   <span class="hljs-comment">// 计数到2</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>        cnt &lt;= cnt + <span class="hljs-number">1&#x27;b1</span>;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">assign</span> clk_o = (cnt&lt;<span class="hljs-number">1</span> ) || (cnt==<span class="hljs-number">1</span> &amp;&amp; clk_i); <span class="hljs-comment">// 第一个时钟里clk_o为高，第二个时钟前半部分clk_o为高，后半部分为低。  </span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h3 id="2-不用时钟下降沿触发的任意奇数分频电路"><a href="#2-不用时钟下降沿触发的任意奇数分频电路" class="headerlink" title="2. 不用时钟下降沿触发的任意奇数分频电路"></a>2. 不用时钟下降沿触发的任意奇数分频电路</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> ClockDiv(<br>    <span class="hljs-keyword">input</span> clk_i,<br>    <span class="hljs-keyword">input</span> rst_n,<br>    <span class="hljs-keyword">output</span>  clk_o<br>    );<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] cnt;<br><span class="hljs-keyword">parameter</span> DIV = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">localparam</span> MID = (DIV-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk_i <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rst_n) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span>(rst_n == <span class="hljs-number">1&#x27;b0</span>) cnt&lt;=<span class="hljs-number">&#x27;b0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cnt == (DIV-<span class="hljs-number">1</span>)) cnt &lt;= <span class="hljs-number">&#x27;b0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>        cnt &lt;= cnt + <span class="hljs-number">1&#x27;b1</span>;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">assign</span> clk_o = (cnt&lt;MID ) || (cnt==MID &amp;&amp; clk_i);   <br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">module</span> tb(<br><br>    );<br>   <span class="hljs-keyword">reg</span> clk_i,rst_n;<br>   <span class="hljs-keyword">wire</span> clk_o;<br>    <span class="hljs-keyword">wire</span> clk5;<br>   <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    clk_i &lt;= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">forever</span> #<span class="hljs-number">10</span> clk_i &lt;= ~clk_i;<br>   <span class="hljs-keyword">end</span> <br>   <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    rst_n = <span class="hljs-number">1</span>;<br>    @(<span class="hljs-keyword">posedge</span> clk_i) rst_n = <span class="hljs-number">0</span>;<br>    @(<span class="hljs-keyword">posedge</span> clk_i) rst_n = <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">end</span><br>    ClockDiv div3(<br>         clk_i,<br>         rst_n,<br>          clk_o<br>        );<br>    ClockDiv <span class="hljs-variable">#(.DIV(5)) div5(.clk_i(clk_i),.rst_n(rst_n),.clk_o(clk5))</span>;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/08/verilog/div.png"></p><h3 id="3-下降沿触发的3分频"><a href="#3-下降沿触发的3分频" class="headerlink" title="3. 下降沿触发的3分频"></a>3. 下降沿触发的3分频</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> ClockDiv(<span class="hljs-keyword">input</span> clk_i,<span class="hljs-keyword">input</span> rst_n,<span class="hljs-keyword">output</span> clk_o);<br><span class="hljs-keyword">reg</span> ck1;<br><span class="hljs-keyword">reg</span>[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] state;<br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk_i <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rst_n) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span>(rst_n == <span class="hljs-number">1&#x27;b0</span>) state &lt;= <span class="hljs-number">2&#x27;b00</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">case</span>(state)<br>        <span class="hljs-number">2&#x27;b00</span>: state&lt;=<span class="hljs-number">2&#x27;b01</span>;<br>        <span class="hljs-number">2&#x27;b01</span>: state&lt;=<span class="hljs-number">2&#x27;b11</span>;<br>        <span class="hljs-number">2&#x27;b11</span>: state&lt;=<span class="hljs-number">2&#x27;b00</span>;<br>        <span class="hljs-keyword">default</span>:state&lt;=<span class="hljs-number">2&#x27;b00</span>;<br>        <span class="hljs-keyword">endcase</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">negedge</span> clk_i <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rst_n) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span>(rst_n == <span class="hljs-number">1&#x27;b0</span>) ck1&lt;=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> ck1 &lt;= state[<span class="hljs-number">0</span>];  <span class="hljs-comment">//ck1相比state[0]延迟半个周期</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">assign</span> clk_o = state[<span class="hljs-number">0</span>] &amp; ck1;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/08/verilog/div2.png"></p>]]></content>
    
    
    <categories>
      
      <category>Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>Verilog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM——callback机制</title>
    <link href="/2019/07/30/Verification/UVM/UVM%E2%80%94%E2%80%94callback%E6%9C%BA%E5%88%B6/"/>
    <url>/2019/07/30/Verification/UVM/UVM%E2%80%94%E2%80%94callback%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.verificationguide.com/p/uvm-callback.html">UVM_CALLBACK—VerificationGuide网站</a></p><p>《UVM实战1》</p><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><h4 id="Where-callbacks-can-be-implemented"><a href="#Where-callbacks-can-be-implemented" class="headerlink" title="Where callbacks can be implemented?"></a>Where callbacks can be implemented?</h4><p>Callbacks can be implemented in an object or component.</p><h4 id="What-are-the-benefits-of-callback"><a href="#What-are-the-benefits-of-callback" class="headerlink" title="What are the benefits of callback?"></a>What are the benefits of callback?</h4><p>Different flavors of the component can be obtained by customizing the empty callback methods.</p><h4 id="About-UVM-Callbacks"><a href="#About-UVM-Callbacks" class="headerlink" title="About UVM Callbacks"></a>About UVM Callbacks</h4><p>UVM provides a set of classes, methods, and macros to implement the callbacks.</p><p>Only the required callback methods are explained here. refer to <a href="https://www.verificationguide.com/p/uvm-callback-classes-methods-macros.html">UVM Callback Classes</a> for UVM Callback classes, methods, and macros.</p><h3 id="2-callback"><a href="#2-callback" class="headerlink" title="2. callback"></a>2. callback</h3><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/07/callback/callback1.png"></p><p>callback中的机制分成三步：</p><ul><li>Adding callback support</li><li>Implementing the callback methods</li><li>Using callback</li></ul><h4 id="2-1-Adding-callback-support"><a href="#2-1-Adding-callback-support" class="headerlink" title="2.1  Adding callback support"></a>2.1  Adding callback support</h4><p><strong>自定义callback类，继承自uvm_callback；在callback类中，自定义要回调的虚函数。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> driver_callback <span class="hljs-keyword">extends</span> uvm_callback;   <br>  `uvm_object_utils(driver_callback)   <br>  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;driver_callback&quot;</span>);<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>  <span class="hljs-keyword">endfunction</span><br>  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> pre_drive; <span class="hljs-keyword">endtask</span><br>  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> post_drive; <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p><strong>用宏&#96;uvm_register_do将callback类注册到将要被使用到的component类。</strong></p><p><strong>将回调钩子（callback hook）放到要使用callback的object或者component类中。</strong>（或许只能放在component中）</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> driver <span class="hljs-keyword">extends</span> uvm_component;<br>  `uvm_component_utils(driver)<br>    `uvm_register_cb(driver,driver_callback)   <span class="hljs-comment">//注册</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name,parent);<br>  <span class="hljs-keyword">endfunction</span>   <br>  <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);<br>      `uvm_do_callbacks(driver,driver_callback,pre_drive());    <span class="hljs-comment">// 添加回调钩子   </span><br>      drive_pkt();       <br>      `uvm_do_callbacks(driver,driver_callback,post_drive());<br>  <span class="hljs-keyword">endtask</span>  <br>  <span class="hljs-keyword">task</span> drive_pkt();<br>    `uvm_info(<span class="hljs-string">&quot;DRIVER&quot;</span>,<span class="hljs-string">&quot;Inside drive_pkt method&quot;</span>,UVM_LOW);<br>  <span class="hljs-keyword">endtask</span>  <br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><h4 id="2-2-Implementing-the-callback-methods"><a href="#2-2-Implementing-the-callback-methods" class="headerlink" title="2.2 Implementing the callback methods"></a>2.2 Implementing the callback methods</h4><p>之前的那一步是VIP设计者要做的工作，在代码中预留出一些接口（回调钩子），供程序使用者扩展功能。接下来的两小节是VIP使用者（验证师）要做的。</p><p><strong>用户自定义回调类，继承自上面的driver_callback类。</strong></p><p><strong>重载回调的虚函数。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> user_callback <span class="hljs-keyword">extends</span> driver_callback;   <span class="hljs-comment">//必须继承</span><br>  `uvm_object_utils(user_callback)   <br>  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;user_callback&quot;</span>);<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>  <span class="hljs-keyword">endfunction</span>  <br>  <span class="hljs-keyword">task</span> pre_drive;<br>    `uvm_info(<span class="hljs-string">&quot;USER_CALLBACK&quot;</span>,<span class="hljs-string">&quot;Inside pre_drive method&quot;</span>,UVM_LOW);<br>  <span class="hljs-keyword">endtask</span>   <br>  <span class="hljs-keyword">task</span> post_drive;<br>    `uvm_info(<span class="hljs-string">&quot;USER_CALLBACK&quot;</span>,<span class="hljs-string">&quot;Inside post_drive method&quot;</span>,UVM_LOW);<br>  <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><h4 id="2-3-Using-callback"><a href="#2-3-Using-callback" class="headerlink" title="2.3 Using callback"></a>2.3 Using callback</h4><p>在testcase中：</p><h5 id="1-定义user-callback回调类。"><a href="#1-定义user-callback回调类。" class="headerlink" title="1.  定义user_callback回调类。"></a>1.  定义user_callback回调类。</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">user_callback callback_1;<br></code></pre></td></tr></table></figure><h5 id="2-创建回调对象。"><a href="#2-创建回调对象。" class="headerlink" title="2. 创建回调对象。"></a>2. 创建回调对象。</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">callback_1 = user_callback::type_id::create(<span class="hljs-string">&quot;callback_1&quot;</span>, <span class="hljs-keyword">this</span>);<br></code></pre></td></tr></table></figure><h5 id="3-将回调对象添加到要使用回调的component中（这里是driver）的回调池子。"><a href="#3-将回调对象添加到要使用回调的component中（这里是driver）的回调池子。" class="headerlink" title="3. 将回调对象添加到要使用回调的component中（这里是driver）的回调池子。"></a>3. 将回调对象添加到要使用回调的component中（这里是driver）的回调池子。</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">uvm_callbacks<span class="hljs-variable">#(driver,driver_callback)::add(env.driv,callback_1)</span>; <br></code></pre></td></tr></table></figure><p>类的参数类型和两个参数对应。</p><p><strong>UVM会自动调用回调池子中所有对象的回调函数。类似于SV中的回调，在SV中回调池子是一个回调基类的队列。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> user_callback_test <span class="hljs-keyword">extends</span> basic_test;<br>  user_callback callback_1;   <span class="hljs-comment">// 定义回调类</span><br>  `uvm_component_utils(user_callback_test)   <br>  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;user_callback_test&quot;</span>, uvm_component parent=<span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name,parent);<br>  <span class="hljs-keyword">endfunction</span>   <br>  <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>    uvm_config_db<span class="hljs-variable">#(uvm_object_wrapper)::set(this,&quot;env0.i_agt.sqr.run_phase&quot;,&quot;default_sequence&quot;,sequence0::type_id::get())</span>;<br>  <span class="hljs-keyword">endfunction</span><br>    <br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);<br>        callback_1 = user_callback::type_id::create(<span class="hljs-string">&quot;callback_1&quot;</span>, <span class="hljs-keyword">this</span>);     <span class="hljs-comment">//创建对象，这里有this</span><br>      uvm_callbacks<span class="hljs-variable">#(driver,driver_callback)::add(env.driv,callback_1)</span>; <span class="hljs-comment">//添加</span><br>    <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p><strong>这里一定要注意，启动sequence写在build phase中，而callback_1对象在connect_phase中创建、添加，如果都写在build phase中，会出错。</strong></p><h3 id="3-注册了多个callback类"><a href="#3-注册了多个callback类" class="headerlink" title="3. 注册了多个callback类"></a>3. 注册了多个callback类</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> user_callback_2_test <span class="hljs-keyword">extends</span> basic_test;<br>  user_callback_1 callback_1;<br>  user_callback_2 callback_2;<br>   <br>  `uvm_component_utils(user_callback_2_test)<br>   <br>  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;user_callback_2_test&quot;</span>, uvm_component parent=<span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name,parent);<br>  <span class="hljs-keyword">endfunction</span><br>   <br>  <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>    callback_1 = user_callback_1::type_id::create(<span class="hljs-string">&quot;callback_1&quot;</span>, <span class="hljs-keyword">this</span>);<br>    callback_2 = user_callback_2::type_id::create(<span class="hljs-string">&quot;callback_2&quot;</span>, <span class="hljs-keyword">this</span>);<br>     <br>      uvm_callbacks<span class="hljs-variable">#(driver,driver_callback)::add(env.driv,callback_2)</span>; <span class="hljs-comment">//2 先注册</span><br>    uvm_callbacks<span class="hljs-variable">#(driver,driver_callback)::add(env.driv,callback_1)</span>;<br>  <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">UVM_INFO @ <span class="hljs-number">0</span>: reporter [RNTST] Running test user_callback_2_test...<br>UVM_INFO user_callback.sv(<span class="hljs-number">39</span>) @ <span class="hljs-number">0</span>: reporter [USER_CALLBACK-<span class="hljs-number">2</span>] Inside pre_drive <span class="hljs-keyword">method</span><br><span class="hljs-title function_">UVM_INFO</span> <span class="hljs-title function_">user_callback</span>.<span class="hljs-title function_">sv</span><span class="hljs-params">(18)</span> @ 0: reporter [USER_CALLBACK-<span class="hljs-number">1</span>] Inside pre_drive <span class="hljs-keyword">method</span><br><span class="hljs-title function_">UVM_INFO</span> <span class="hljs-title function_">slave_driver</span>.<span class="hljs-title function_">sv</span><span class="hljs-params">(23)</span> @ 0: uvm_test_top.env.driver [DRIVER] Inside drive_pkt <span class="hljs-keyword">method</span><br><span class="hljs-title function_">UVM_INFO</span> <span class="hljs-title function_">user_callback</span>.<span class="hljs-title function_">sv</span><span class="hljs-params">(43)</span> @ 0: reporter [USER_CALLBACK-<span class="hljs-number">2</span>] Inside post_drive <span class="hljs-keyword">method</span><br><span class="hljs-title function_">UVM_INFO</span> <span class="hljs-title function_">user_callback</span>.<span class="hljs-title function_">sv</span><span class="hljs-params">(22)</span> @ 0: reporter [USER_CALLBACK-<span class="hljs-number">1</span>] Inside post_drive <span class="hljs-keyword">method</span><br></code></pre></td></tr></table></figure><p>​    user_callback_1、user_callback_2继承自driver_callback；上面代码中向driver添加了两个回调类，那么执行顺序是根据自定义回调类（user_callback_1、user_callback_2）注册到dirver（add函数）的顺序，来执行回调虚函数的。</p><h3 id="4-子类继承父类的回调机制"><a href="#4-子类继承父类的回调机制" class="headerlink" title="4. 子类继承父类的回调机制"></a>4. 子类继承父类的回调机制</h3><p>如果要在原来的验证环境基础上开发第二代验证环境，并且需要扩展my_driver的功能，新的new_driver继承自driver，我们希望new_driver中也可以用driver中的callback函数。</p><p><strong>需要使用下面这个宏将子类父类关联起来。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">`uvm_set_super_type(new_driver,driver);<br></code></pre></td></tr></table></figure><p><strong>在new_driver中添加的回调钩子是原来的my_driver</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">`uvm_do_callbacks(driver,driver_callback,pre_drive()); <br></code></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> new_driver <span class="hljs-keyword">extends</span> driver;<br>  `uvm_component_utils(new_driver)<br>  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name,parent);<br>  <span class="hljs-keyword">endfunction</span>   <br>  <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);<br>      `uvm_do_callbacks(driver,driver_callback,pre_drive());    <span class="hljs-comment">// 还是driver   </span><br>      drive_pkt();       <br>      `uvm_do_callbacks(driver,driver_callback,post_drive());<br>  <span class="hljs-keyword">endtask</span>  <br>  <span class="hljs-keyword">task</span> drive_pkt();<br>    `uvm_info(<span class="hljs-string">&quot;DRIVER&quot;</span>,<span class="hljs-string">&quot;Inside drive_pkt method&quot;</span>,UVM_LOW);<br>  <span class="hljs-keyword">endtask</span>  <br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><h3 id="5-在sequence中使用callback"><a href="#5-在sequence中使用callback" class="headerlink" title="5. 在sequence中使用callback"></a>5. 在sequence中使用callback</h3><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/07/callback/callback2.png"></p><p>拆成5步：</p><ul><li>Write callback class</li><li>Register the callback class</li><li>Place the callback hook</li><li>Implement the callback method</li><li>Create and register the callback object</li></ul><h4 id="5-1-Write-callback-class"><a href="#5-1-Write-callback-class" class="headerlink" title="5.1 Write callback class"></a>5.1 Write callback class</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> mem_callback <span class="hljs-keyword">extends</span> uvm_callback;<br>    <br>  `uvm_object_utils(mem_callback)<br>    <br>  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;mem_callback&quot;</span>);<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>  <span class="hljs-keyword">endfunction</span><br>    <br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> update_pkt(<span class="hljs-keyword">ref</span> mem_seq_item pkt); <span class="hljs-keyword">endtask</span> <span class="hljs-comment">//回调函数</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><h4 id="5-2-Register-the-callback-class"><a href="#5-2-Register-the-callback-class" class="headerlink" title="5.2 Register the callback class"></a>5.2 Register the callback class</h4><p>callback类需要注册在component中，因为sequence是动态的。将callback类注册在sequencer中。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> mem_sequencer <span class="hljs-keyword">extends</span> uvm_sequencer<span class="hljs-variable">#(mem_seq_item)</span>; <br>  `uvm_component_utils(mem_sequencer)<br>    `uvm_register_cb(mem_sequencer,mem_callback) <span class="hljs-comment">//将回调基类注册到sqr中</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name,parent);<br>  <span class="hljs-keyword">endfunction</span>   <br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><h4 id="5-3-Place-the-callback-hook"><a href="#5-3-Place-the-callback-hook" class="headerlink" title="5.3 Place the callback hook"></a>5.3 Place the callback hook</h4><p>回调钩子要放在sequence类中，因为是在sequence中回调。</p><p>&#96;uvm_do_obj_callbacks的第一个参数是mem_sequencer，因为回调注册在mem_sequencer</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> mem_sequence <span class="hljs-keyword">extends</span> uvm_sequence<span class="hljs-variable">#(mem_seq_item)</span>;   <br>  `uvm_object_utils(mem_sequence)<br>  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;mem_sequence&quot;</span>);<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>  <span class="hljs-keyword">endfunction</span><br>   <br>  `uvm_declare_p_sequencer(mem_sequencer)<br>   <br>  <span class="hljs-comment">//---------------------------------------</span><br>  <span class="hljs-comment">// create, randomize and send the item to driver</span><br>  <span class="hljs-comment">//---------------------------------------</span><br>  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();<br>    req = mem_seq_item::type_id::create(<span class="hljs-string">&quot;req&quot;</span>);<br>    wait_for_grant();<br>    req<span class="hljs-variable">.randomize</span>();<br>      `uvm_do_obj_callbacks(mem_sequencer,mem_callback,p_sequencer,update_pkt(req));<span class="hljs-comment">//在sequence中使用sqr中的回调函数。</span><br>    send_request(req);<br>    wait_for_item_done();<br>  <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><h4 id="5-4-Implement-the-callback-method"><a href="#5-4-Implement-the-callback-method" class="headerlink" title="5.4 Implement the callback method"></a>5.4 Implement the callback method</h4><p>自定义回调类和回调函数。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> user_callback <span class="hljs-keyword">extends</span> mem_callback; <span class="hljs-comment">//继承自回调基类</span><br>   <br>  `uvm_object_utils(user_callback)<br>   <br>  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;user_callback&quot;</span>);<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>  <span class="hljs-keyword">endfunction</span><br>   <br>    <span class="hljs-keyword">task</span> update_pkt(<span class="hljs-keyword">ref</span> mem_seq_item pkt); <span class="hljs-comment">//重载回调函数</span><br>    `uvm_info(<span class="hljs-string">&quot;USER_CALLBACK&quot;</span>,<span class="hljs-string">&quot;[update_pkt] before packet modification&quot;</span>,UVM_LOW);<br>    pkt<span class="hljs-variable">.print</span>();<br>    pkt<span class="hljs-variable">.addr</span> = ~pkt<span class="hljs-variable">.addr</span>;<br>    `uvm_info(<span class="hljs-string">&quot;USER_CALLBACK&quot;</span>,<span class="hljs-string">&quot;[update_pkt] after packet modification&quot;</span>,UVM_LOW);<br>    pkt<span class="hljs-variable">.print</span>();<br>  <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><h4 id="5-5-Create-and-register-the-callback-object"><a href="#5-5-Create-and-register-the-callback-object" class="headerlink" title="5.5 Create and register the callback object"></a>5.5 Create and register the callback object</h4><p><strong>将回调对象添加到回调注册的地方，在这里注册到了sequencer。所以在add函数中用的是sequencer而不是sequence。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> user_callback_test <span class="hljs-keyword">extends</span> mem_test;<br>  user_callback callback_1; <span class="hljs-comment">// 回调对象</span><br>   <br>  `uvm_component_utils(user_callback_test)<br>   <br>  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;user_callback_test&quot;</span>, uvm_component parent=<span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name,parent);<br>  <span class="hljs-keyword">endfunction</span><br>   <br>  <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);<br>    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>      callback_1 = user_callback::type_id::create(<span class="hljs-string">&quot;callback_1&quot;</span>, <span class="hljs-keyword">this</span>); <span class="hljs-comment">// 创建</span><br>  <span class="hljs-keyword">endfunction</span><br>   <br>  <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> end_of_elaboration();<br>      uvm_callbacks<span class="hljs-variable">#(mem_sequencer,mem_callback)::add(env.mem_agnt.sequencer,callback_1)</span>;<span class="hljs-comment">//注册到sequencer中</span><br>  <span class="hljs-keyword">endfunction</span> : end_of_elaboration<br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>UVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
      <tag>UVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM——RAL</title>
    <link href="/2019/07/30/Verification/UVM/UVM%E2%80%94%E2%80%94RAL/"/>
    <url>/2019/07/30/Verification/UVM/UVM%E2%80%94%E2%80%94RAL/</url>
    
    <content type="html"><![CDATA[<h3 id="1-寄存器模型介绍"><a href="#1-寄存器模型介绍" class="headerlink" title="1. 寄存器模型介绍"></a>1. 寄存器模型介绍</h3><p>每个IP都有总线接口，连接到总线上，用来对DUT中寄存器进行配置，改变其行为。</p><p>再验证环境中，如果改变了DUT的行为，那么参考模型需要知道DUT做了哪些改变，并同步改变，否则参考模型和当前DUT的功能不一致。</p><p>参考模型要想获得寄存器值，需要做两件事：</p><ol><li>在参考模型中启动sequence用来产生一个读取DUT寄存器的操作。</li><li>读取的值传递给参考模型。</li></ol><p>如果有了寄存器模型，可以直接在参考模型中读取DUT中寄存器的值，如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> model <span class="hljs-keyword">extends</span> uvm_model;<br><span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br>..<br>        reg_model<span class="hljs-variable">.INVERT_REG</span><span class="hljs-variable">.read</span>(status,value,UVM_FRONTEND); <span class="hljs-comment">//读取寄存器值</span><br>..<br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p><strong>无论是读取还是设置寄存器都由参考模型处理。</strong></p><h4 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h4><p>uvm_reg_filed：field是寄存器中最小单位。比如一个16bit的寄存器，它的0-7位表示地址，8-15位表示数据，那么8位的地址是一个field，8位的数据也是一个filed</p><p>uvm_reg：比field高一个级别，reg中可以有一个或者多个field。每个寄存器模型中至少一个reg。</p><p>uvm_reg_block：这就是寄存器模型，其中可以有很多个uvm_reg</p><p>uvm_reg_map：每个寄存器加入到寄存器模型中都有其地址，map就是用来存这些地址的，并将地址转化成可以访问的物理地址（加入寄存器模型中的地址一般是偏移地址，而不是绝对地址）。在进行读写时，map将寄存器地址转化成绝对地址。每个block中至少有一个（通常只有一个）map。</p><h4 id="1-2-前门访问"><a href="#1-2-前门访问" class="headerlink" title="1.2 前门访问"></a>1.2 前门访问</h4><p>前门操作有两种：读和写。模拟CPU在总线上发出读指令，仿真时间一直往前走。</p><h4 id="1-3-后门访问"><a href="#1-3-后门访问" class="headerlink" title="1.3 后门访问"></a>1.3 后门访问</h4><p>后门操作不进行总线读写，通过层次化引用来改变寄存器的值。</p><p>有时DUT中的计数器没法通过前门总线来进行读取</p><h4 id="1-4-前门后门的不同"><a href="#1-4-前门后门的不同" class="headerlink" title="1.4 前门后门的不同"></a>1.4 前门后门的不同</h4><p>后门访问的优点：</p><ol><li><p>不需要仿真时间，大型设计中前门访问中的寄存器配置可能需要几个小时，后门缩短为1&#x2F;100。</p><ol start="2"><li>有些DUT中的计数器没法通过前门写入值，当我们需要测试它的进位的时候，需要一直仿真到它进位；但如果通过后门访问，给它设置了一个很大的初始值，那么只需要几次累加就能产生进位信号。</li></ol></li></ol><p>缺点：</p><ol><li>后门访问不能产生波形，只能通过打印信息来查看结果。</li></ol><h4 id="1-5-注意"><a href="#1-5-注意" class="headerlink" title="1.5 注意"></a>1.5 注意</h4><p>寄存器模型一般例化在base_test中，便于env级集成验证。</p><h3 id="2-简单的寄存器模型"><a href="#2-简单的寄存器模型" class="headerlink" title="2. 简单的寄存器模型"></a>2. 简单的寄存器模型</h3><h4 id="2-1-寄存器模型"><a href="#2-1-寄存器模型" class="headerlink" title="2.1 寄存器模型"></a>2.1 寄存器模型</h4><h5 id="2-1-1-创建一个uvm-reg类。"><a href="#2-1-1-创建一个uvm-reg类。" class="headerlink" title="2.1.1 创建一个uvm_reg类。"></a><strong>2.1.1 创建一个uvm_reg类。</strong></h5><p>可以在reg类中定义多个field。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> reg_invert <span class="hljs-keyword">extends</span> uvm_reg;<br>    <span class="hljs-keyword">rand</span> uvm_reg_field reg_data; <span class="hljs-comment">//在reg中定义field</span><br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build(); <span class="hljs-comment">//build</span><br>        reg_data = uvm_reg_field::type_id::create(<span class="hljs-string">&quot;reg_data&quot;</span>);<br>        <span class="hljs-comment">// parameter: parent, size, lsb_pos, access, volatile, reset value, has_reset, is_rand, individually accessible</span><br>        reg_data<span class="hljs-variable">.configure</span>(<span class="hljs-keyword">this</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;RW&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">//上面一行是参数介绍</span><br>    <span class="hljs-keyword">endfunction</span><br>    `uvm_object_utils(reg_invert)<br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">input</span> <span class="hljs-keyword">string</span> name=<span class="hljs-string">&quot;reg_invert&quot;</span>);<br>        <span class="hljs-comment">//parameter: name, size, has_coverage</span><br>        <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, <span class="hljs-number">16</span>, UVM_NO_COVERAGE); <span class="hljs-comment">//16是这个寄存器的宽度，</span><br>    <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p><strong>每个派生自uvm_reg的类都有一个build（）函数，它只能手工调用.</strong></p><h5 id="2-1-2-创建uvm-reg-block-寄存器模块类"><a href="#2-1-2-创建uvm-reg-block-寄存器模块类" class="headerlink" title="2.1.2 创建uvm_reg_block 寄存器模块类"></a><strong>2.1.2 创建uvm_reg_block 寄存器模块类</strong></h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> reg_model <span class="hljs-keyword">extends</span> uvm_reg_block;<br>   <span class="hljs-keyword">rand</span> reg_invert invert; <span class="hljs-comment">// 定义reg</span><br><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build();<br>      default_map = create_map(<span class="hljs-string">&quot;default_map&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, UVM_BIG_ENDIAN, <span class="hljs-number">0</span>);<br>      invert = reg_invert::type_id::create(<span class="hljs-string">&quot;invert&quot;</span>, , get_full_name());<br>      invert<span class="hljs-variable">.configure</span>(<span class="hljs-keyword">this</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;&quot;</span>);<br>      invert<span class="hljs-variable">.build</span>();<br>      default_map<span class="hljs-variable">.add_reg</span>(invert, <span class="hljs-number">&#x27;h9</span>, <span class="hljs-string">&quot;RW&quot;</span>);<br>   <span class="hljs-keyword">endfunction</span><br><br>   `uvm_object_utils(reg_model)<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">input</span> <span class="hljs-keyword">string</span> name=<span class="hljs-string">&quot;reg_model&quot;</span>);<br>        <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, UVM_NO_COVERAGE);<br>    <span class="hljs-keyword">endfunction</span> <br><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p><strong>在uvm_reg_block中已经声明好了map——default_map。只需创建create_map.</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> uvm_reg_map create_map(<span class="hljs-keyword">string</span> name, uvm_reg_addr_t base_addr,  <br><span class="hljs-keyword">int</span> <span class="hljs-keyword">unsigned</span> n_bytes, uvm_endianness_e endian, <span class="hljs-keyword">bit</span> byte_addressing = <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th></th></tr></thead><tbody><tr><td>base_addr</td><td>the base address for the map.  All registers, memories, and sub-blocks within the map will be at offsets to this address</td></tr><tr><td>n_bytes</td><td>the byte-width of the bus on which this map is used</td></tr><tr><td>endian</td><td>the endian format.  See <a href="uvm_reg_model-svh.html#uvm_endianness_e">uvm_endianness_e</a> for possible values</td></tr><tr><td>byte_addressing</td><td>specifies whether consecutive addresses refer are 1 byte apart (TRUE) or <em>n_bytes</em> apart (FALSE).  Default is TRUE</td></tr></tbody></table><p><strong>configure（）函数主要用来指定后门访问的路径。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> configure (uvm_reg_block blk_parent,uvm_reg_file regfile_parent = <span class="hljs-literal">null</span>,<span class="hljs-keyword">string</span> hdl_path = <span class="hljs-string">&quot;&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>add_reg（）将寄存器添加到default_map中。</strong></p><h4 id="2-2-将寄存器模型集成到验证平台"><a href="#2-2-将寄存器模型集成到验证平台" class="headerlink" title="2.2 将寄存器模型集成到验证平台"></a>2.2 将寄存器模型集成到验证平台</h4><h5 id="2-2-1-先写一个转换器adapter"><a href="#2-2-1-先写一个转换器adapter" class="headerlink" title="2.2.1 先写一个转换器adapter"></a><strong>2.2.1 先写一个转换器adapter</strong></h5><p>通过寄存器模型进行前门读写操作时，寄存器模型都会通过sequence产生一个uvm_reg_bus_op（uvm结构体）的变量，其中保存操作类型（RW）、地址、数据等。此变量需要经过一个转换器（adapter）交给bus_sequencer。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-comment">// uvm_reg_tiem.svh</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>  <span class="hljs-comment">// Kind of access: READ or WRITE.</span><br>  uvm_access_e kind;<br>  <span class="hljs-comment">// The bus address.</span><br>  uvm_reg_addr_t addr;<br>  <span class="hljs-comment">// The data to write. If the bus width is smaller than the register or</span><br>  <span class="hljs-comment">// memory width, ~data~ represents only the portion of ~value~ that is</span><br>  uvm_reg_data_t data;  <br>  <span class="hljs-comment">// The number of bits of &lt;uvm_reg_item::value&gt; being transferred by</span><br>  <span class="hljs-comment">// this transaction.</span><br>  <span class="hljs-keyword">int</span> n_bits;<br>  <span class="hljs-comment">// Enables for the byte lanes on the bus. Meaningful only when the</span><br>  <span class="hljs-comment">// bus supports byte enables and the operation originates from a field  write/read.</span><br>  uvm_reg_byte_en_t byte_en;<br>  <span class="hljs-comment">// The result of the transaction: UVM_IS_OK, UVM_HAS_X, UVM_NOT_OK.</span><br>  <span class="hljs-comment">// See &lt;uvm_status_e&gt;.</span><br>  uvm_status_e status;<br>&#125; uvm_reg_bus_op;<br></code></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_adapter <span class="hljs-keyword">extends</span> uvm_reg_adapter;<br>    <span class="hljs-keyword">string</span> tID = get_type_name();<br>    `uvm_object_utils(my_adapter)<br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name=<span class="hljs-string">&quot;my_adapter&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>   <span class="hljs-keyword">endfunction</span> : <span class="hljs-keyword">new</span><br>    <span class="hljs-comment">// uvm_reg_bus_op转换成bus_transaction类型</span><br>   <span class="hljs-keyword">function</span> uvm_sequence_item reg2bus(<span class="hljs-keyword">const</span> <span class="hljs-keyword">ref</span> uvm_reg_bus_op rw);<br>      bus_transaction tr;<br>      tr = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;tr&quot;</span>); <br>      tr<span class="hljs-variable">.addr</span> = rw<span class="hljs-variable">.addr</span>;<br>      tr<span class="hljs-variable">.bus_op</span> = (rw<span class="hljs-variable">.kind</span> == UVM_READ) ? BUS_RD: BUS_WR;<br>      <span class="hljs-keyword">if</span> (tr<span class="hljs-variable">.bus_op</span> == BUS_WR)<br>         tr<span class="hljs-variable">.wr_data</span> = rw<span class="hljs-variable">.data</span>; <br>      <span class="hljs-keyword">return</span> tr;<br>   <span class="hljs-keyword">endfunction</span> : reg2bus<br><span class="hljs-comment">// bus_transaction转换成uvm_reg_bus_op</span><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> bus2reg(uvm_sequence_item bus_item, <span class="hljs-keyword">ref</span> uvm_reg_bus_op rw);<br>      bus_transaction tr;<br>      <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">$cast</span>(tr, bus_item)) <span class="hljs-keyword">begin</span><br>         `uvm_fatal(tID,<br>          <span class="hljs-string">&quot;Provided bus_item is not of the correct type. Expecting bus_transaction&quot;</span>)<br>          <span class="hljs-keyword">return</span>;<br>      <span class="hljs-keyword">end</span><br>      rw<span class="hljs-variable">.kind</span> = (tr<span class="hljs-variable">.bus_op</span> == BUS_RD) ? UVM_READ : UVM_WRITE;<br>      rw<span class="hljs-variable">.addr</span> = tr<span class="hljs-variable">.addr</span>;<br>      rw<span class="hljs-variable">.byte_en</span> = <span class="hljs-number">&#x27;h3</span>;<br>      rw<span class="hljs-variable">.data</span> = (tr<span class="hljs-variable">.bus_op</span> == BUS_RD) ? tr<span class="hljs-variable">.rd_data</span> : tr<span class="hljs-variable">.wr_data</span>;<br>      rw<span class="hljs-variable">.status</span> = UVM_IS_OK;<br>   <span class="hljs-keyword">endfunction</span> : bus2reg<br><br><span class="hljs-keyword">endclass</span> : my_adapter<br></code></pre></td></tr></table></figure><p>bus_driver在驱动总线进行读操作的时候，它能顺便获取到要读的值，如下面代码所示。将这个值在bus_transaction中，传给bus_sequencer，然后通过bus2reg函数传给寄存器模型。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-keyword">task</span> bus_driver::drive_one_pkt(bus_transaction tr);<br>   `uvm_info(<span class="hljs-string">&quot;bus_driver&quot;</span>, <span class="hljs-string">&quot;begin to drive one pkt&quot;</span>, UVM_LOW);<br>   <span class="hljs-keyword">repeat</span>(<span class="hljs-number">1</span>) @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>   <br>   vif<span class="hljs-variable">.bus_cmd_valid</span> &lt;= <span class="hljs-number">1&#x27;b1</span>;<br>   vif<span class="hljs-variable">.bus_op</span> &lt;= ((tr<span class="hljs-variable">.bus_op</span> == BUS_RD) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>);<br>   vif<span class="hljs-variable">.bus_addr</span> = tr<span class="hljs-variable">.addr</span>;<br>   vif<span class="hljs-variable">.bus_wr_data</span> &lt;= ((tr<span class="hljs-variable">.bus_op</span> == BUS_RD) ? <span class="hljs-number">0</span> : tr<span class="hljs-variable">.wr_data</span>);<br><br>   @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>   vif<span class="hljs-variable">.bus_cmd_valid</span> &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>   vif<span class="hljs-variable">.bus_op</span> &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>   vif<span class="hljs-variable">.bus_addr</span> &lt;= <span class="hljs-number">15&#x27;b0</span>;<br>   vif<span class="hljs-variable">.bus_wr_data</span> &lt;= <span class="hljs-number">15&#x27;b0</span>;<br><br>   @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);<br>   <span class="hljs-keyword">if</span>(tr<span class="hljs-variable">.bus_op</span> == BUS_RD) <span class="hljs-keyword">begin</span><br>      tr<span class="hljs-variable">.rd_data</span> = vif<span class="hljs-variable">.bus_rd_data</span>;   <br>      <span class="hljs-comment">//$display(&quot;@%0t, rd_data is %0h&quot;, $time, tr.rd_data);</span><br>   <span class="hljs-keyword">end</span><br><br>   <span class="hljs-comment">//`uvm_info(&quot;bus_driver&quot;, &quot;end drive one pkt&quot;, UVM_LOW);</span><br><span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><h5 id="2-2-2-在base-test中添加寄存器模型"><a href="#2-2-2-在base-test中添加寄存器模型" class="headerlink" title="2.2.2 在base_test中添加寄存器模型"></a>2.2.2 在base_test中添加寄存器模型</h5><p>​    寄存器模型要写在base_test中，如果写在env中，那么当在芯片级验证中，env复用的时候不能在顶层env中指定各个ip寄存器模型的偏移地址。env中的只是寄存器模型句柄。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-keyword">class</span> base_test <span class="hljs-keyword">extends</span> uvm_test;<br><br>   my_env         env;<br>   my_vsqr        v_sqr;<br>   reg_model      rm; <span class="hljs-comment">// 声明</span><br>   my_adapter     reg_sqr_adapter;<br><br>...<br>   `uvm_component_utils(base_test)<br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> base_test::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>   env  =  my_env::type_id::create(<span class="hljs-string">&quot;env&quot;</span>, <span class="hljs-keyword">this</span>); <br>   v_sqr =  my_vsqr::type_id::create(<span class="hljs-string">&quot;v_sqr&quot;</span>, <span class="hljs-keyword">this</span>);<br>    rm = reg_model::type_id::create(<span class="hljs-string">&quot;rm&quot;</span>, <span class="hljs-keyword">this</span>);<span class="hljs-comment">//创建寄存器模型</span><br>    rm<span class="hljs-variable">.configure</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;&quot;</span>); <br>    rm<span class="hljs-variable">.build</span>();<span class="hljs-comment">// 实例化所有寄存器</span><br>    rm<span class="hljs-variable">.lock_model</span>(); <span class="hljs-comment">//调用此函数后，寄存器模型中不能再添加寄存器</span><br>    rm<span class="hljs-variable">.reset</span>(); <span class="hljs-comment">// 设置寄存器的值为复位值，如果不用这个函数，那么寄存器都为0</span><br>   reg_sqr_adapter = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;reg_sqr_adapter&quot;</span>);<br>   env<span class="hljs-variable">.p_rm</span> = <span class="hljs-keyword">this</span><span class="hljs-variable">.rm</span>; <span class="hljs-comment">//给env中句柄赋值</span><br><span class="hljs-keyword">endfunction</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> base_test::connect_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);<br>   v_sqr<span class="hljs-variable">.p_my_sqr</span> = env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.sqr</span>;<br>   v_sqr<span class="hljs-variable">.p_bus_sqr</span> = env<span class="hljs-variable">.bus_agt</span><span class="hljs-variable">.sqr</span>;<br>   v_sqr<span class="hljs-variable">.p_rm</span> = <span class="hljs-keyword">this</span><span class="hljs-variable">.rm</span>;<br>    rm<span class="hljs-variable">.default_map</span><span class="hljs-variable">.set_sequencer</span>(env<span class="hljs-variable">.bus_agt</span><span class="hljs-variable">.sqr</span>, reg_sqr_adapter);<span class="hljs-comment">// 将adapter和sqr告诉map</span><br>   rm<span class="hljs-variable">.default_map</span><span class="hljs-variable">.set_auto_predict</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">endfunction</span><br></code></pre></td></tr></table></figure><h4 id="2-3-在验证平台使用寄存器模型"><a href="#2-3-在验证平台使用寄存器模型" class="headerlink" title="2.3 在验证平台使用寄存器模型"></a>2.3 在验证平台使用寄存器模型</h4><p><strong>可以再sequence和component中使用寄存器模型。</strong></p><h5 id="2-3-1-在参考模型中有个模型指针"><a href="#2-3-1-在参考模型中有个模型指针" class="headerlink" title="2.3.1 在参考模型中有个模型指针"></a>2.3.1 在参考模型中有个模型指针</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_model <span class="hljs-keyword">extends</span> uvm_model;<br>reg_model p_rm;<br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><h5 id="2-3-2-在env中连接指针和参考模型"><a href="#2-3-2-在env中连接指针和参考模型" class="headerlink" title="2.3.2 在env中连接指针和参考模型"></a>2.3.2 在env中连接指针和参考模型</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> my_env <span class="hljs-keyword">extends</span> uvm_env;<br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);<br>mdl<span class="hljs-variable">.p_rm</span> = <span class="hljs-keyword">this</span><span class="hljs-variable">.p_rm</span>;<br>endfucntion<br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><h5 id="2-3-3-在参考模型中读取寄存器"><a href="#2-3-3-在参考模型中读取寄存器" class="headerlink" title="2.3.3 在参考模型中读取寄存器"></a>2.3.3 在参考模型中读取寄存器</h5><table><thead><tr><th>uvm_status_e</th><th></th></tr></thead><tbody><tr><td>UVM_IS_OK</td><td>Operation completed successfully</td></tr><tr><td>UVM_NOT_OK</td><td>Operation completed with error</td></tr><tr><td>UVM_HAS_X</td><td>Operation completed successfully bit had unknown bits</td></tr></tbody></table><p><strong>uvm_reg_data_t 是64bit的数据。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> my_model::main_phase(uvm_phase phase);<br>   my_transaction tr;<br>   my_transaction new_tr;<br>   uvm_status_e status;<br>   uvm_reg_data_t value;<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.main_phase</span>(phase);<br>    p_rm<span class="hljs-variable">.invert</span><span class="hljs-variable">.read</span>(status, value, UVM_FRONTDOOR); <span class="hljs-comment">//read是寄存器的函数</span><br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>      port<span class="hljs-variable">.get</span>(tr);<br>      new_tr = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;new_tr&quot;</span>);<br>      new_tr<span class="hljs-variable">.copy</span>(tr);<br>      <span class="hljs-comment">//`uvm_info(&quot;my_model&quot;, &quot;get one transaction, copy and print it:&quot;, UVM_LOW)</span><br>      <span class="hljs-comment">//new_tr.print();</span><br>      <span class="hljs-keyword">if</span>(value)<br>         invert_tr(new_tr);<br>      ap<span class="hljs-variable">.write</span>(new_tr);<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> uvm_reg::write(<span class="hljs-keyword">output</span> uvm_status_e status,  <br>        <span class="hljs-keyword">input</span> uvm_reg_data_t value,  <br>        <span class="hljs-keyword">input</span> uvm_path_e path = UVM_DEFAULT_PATH,<br>        <span class="hljs-keyword">input</span> uvm_reg_map map = <span class="hljs-literal">null</span>,<br>        <span class="hljs-keyword">input</span> uvm_sequence_base parent = <span class="hljs-literal">null</span>,<br>        <span class="hljs-keyword">input</span> <span class="hljs-keyword">int</span> prior = -<span class="hljs-number">1</span>,<br>        <span class="hljs-keyword">input</span> uvm_object extension = <span class="hljs-literal">null</span>,<br>        <span class="hljs-keyword">input</span> <span class="hljs-keyword">string</span> fname = <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-keyword">input</span> <span class="hljs-keyword">int</span> lineno = <span class="hljs-number">0</span>)<br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> uvm_reg::read(<span class="hljs-keyword">output</span> uvm_status_e status,  <br>        <span class="hljs-keyword">output</span> uvm_reg_data_t value,  <br>        <span class="hljs-keyword">input</span> uvm_path_e path = UVM_DEFAULT_PATH,<br>        <span class="hljs-keyword">input</span> uvm_reg_map map = <span class="hljs-literal">null</span>,<br>        <span class="hljs-keyword">input</span> uvm_sequence_base parent = <span class="hljs-literal">null</span>,<br>        <span class="hljs-keyword">input</span> <span class="hljs-keyword">int</span> prior = -<span class="hljs-number">1</span>,<br>        <span class="hljs-keyword">input</span> uvm_object extension = <span class="hljs-literal">null</span>,<br>        <span class="hljs-keyword">input</span> <span class="hljs-keyword">string</span> fname = <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-keyword">input</span> <span class="hljs-keyword">int</span> lineno = <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h5 id="2-3-4-在sequence中写寄存器"><a href="#2-3-4-在sequence中写寄存器" class="headerlink" title="2.3.4 在sequence中写寄存器"></a>2.3.4 在sequence中写寄存器</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> case0_cfg_vseq::body();<br>      uvm_status_e   status;<br>      uvm_reg_data_t value;<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>      p_sequencer<span class="hljs-variable">.p_rm</span><span class="hljs-variable">.invert</span><span class="hljs-variable">.write</span>(status, <span class="hljs-number">1</span>, UVM_FRONTDOOR);<br>      p_sequencer<span class="hljs-variable">.p_rm</span><span class="hljs-variable">.invert</span><span class="hljs-variable">.read</span>(status, value, UVM_FRONTDOOR);<br>      `uvm_info(<span class="hljs-string">&quot;case0_cfg_vseq&quot;</span>, <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;after set, invert&#x27;s value is %0h&quot;</span>, value), UVM_LOW)<br>      <span class="hljs-keyword">if</span>(starting_phase != <span class="hljs-literal">null</span>) <br>         starting_phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br>   <span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><h3 id="3-前门操作"><a href="#3-前门操作" class="headerlink" title="3. 前门操作"></a>3. 前门操作</h3><p>前门操作有两种：读和写。模拟CPU在总线上发出读指令，仿真时间一直往前走。</p><p>上面讲的就是前门操作的读写 UVM_FRONTDOOR。</p><h3 id="4-后门操作"><a href="#4-后门操作" class="headerlink" title="4. 后门操作"></a>4. 后门操作</h3><p>后门操作不进行总线读写，通过层次化引用来改变寄存器的值。</p><p>有时DUT中的计数器没法通过前门总线来进行读取。</p><h4 id="4-1-不用UVM进行后门读写"><a href="#4-1-不用UVM进行后门读写" class="headerlink" title="4.1 不用UVM进行后门读写"></a>4.1 不用UVM进行后门读写</h4><p>方法一、直接在top层设置</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>   @(<span class="hljs-keyword">posedge</span> rst_n);<br>   my_dut<span class="hljs-variable">.counter</span> = <span class="hljs-number">32&#x27;hFFFD</span>;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>方法二、在接口中定义函数</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">interface</span> backdoor_if(<span class="hljs-keyword">input</span> clk, <span class="hljs-keyword">input</span> rst_n);<br><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> poke_counter(<span class="hljs-keyword">input</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] value);<br>      top_tb<span class="hljs-variable">.my_dut</span><span class="hljs-variable">.counter</span> = value;<br>   <span class="hljs-keyword">endfunction</span><br><br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> peek_counter(<span class="hljs-keyword">output</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] value);<br>      value = top_tb<span class="hljs-variable">.my_dut</span><span class="hljs-variable">.counter</span>;<br>   <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endinterface</span><br><span class="hljs-comment">/////////////////////////////////////</span><br><span class="hljs-keyword">task</span> my_case0::configure_phase(uvm_phase phase);<br>   phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);<br>   @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.rst_n</span>);<br>    vif<span class="hljs-variable">.poke_counter</span>(<span class="hljs-number">32&#x27;hFFFD</span>); <span class="hljs-comment">//设置reg</span><br>   phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><h4 id="4-2-UVM中的后门访问"><a href="#4-2-UVM中的后门访问" class="headerlink" title="4.2 UVM中的后门访问"></a>4.2 UVM中的后门访问</h4><p><strong>在寄存器configure（）函数中的第三个参数设置路径。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> reg_model::build();<br>     default_map = create_map(<span class="hljs-string">&quot;default_map&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, UVM_BIG_ENDIAN, <span class="hljs-number">0</span>);<br><br>     invert = reg_invert::type_id::create(<span class="hljs-string">&quot;invert&quot;</span>, , get_full_name());<br>    invert<span class="hljs-variable">.configure</span>(<span class="hljs-keyword">this</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;invert&quot;</span>); <span class="hljs-comment">//第三个参数是后门路径</span><br>     invert<span class="hljs-variable">.build</span>();<br>     default_map<span class="hljs-variable">.add_reg</span>(invert, <span class="hljs-number">&#x27;h9</span>, <span class="hljs-string">&quot;RW&quot;</span>);<br>    ...<br><span class="hljs-keyword">endfunction</span>    <br></code></pre></td></tr></table></figure><p><strong>设置根路径hdl_root</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> base_test::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>  ...<br>   rm = reg_model::type_id::create(<span class="hljs-string">&quot;rm&quot;</span>, <span class="hljs-keyword">this</span>);<br> ...<br>    rm<span class="hljs-variable">.set_hdl_path_root</span>(<span class="hljs-string">&quot;top_tb.my_dut&quot;</span>); <span class="hljs-comment">//设置跟路径</span><br>   reg_sqr_adapter = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;reg_sqr_adapter&quot;</span>);<br>   env<span class="hljs-variable">.p_rm</span> = <span class="hljs-keyword">this</span><span class="hljs-variable">.rm</span>;<br><span class="hljs-keyword">endfunction</span><br></code></pre></td></tr></table></figure><p><strong>上面两个路径合起来就是寄存器的路径。</strong></p><h4 id="4-3-后门访问函数"><a href="#4-3-后门访问函数" class="headerlink" title="4.3 后门访问函数"></a>4.3 后门访问函数</h4><p>后门访问也有write和read。这两个函数在操作的时候会模拟DUT的行为，如果寄存器是只读的，如果要写，那么写不进去。</p><p><strong>还有poke（写）和peek（读）这两个函数。可以使用poke向一个只读寄存器写入值。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> poke(<span class="hljs-keyword">output</span> uvm_status_e status,  <br>    <span class="hljs-keyword">input</span> uvm_reg_data_t value,  <br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">string</span> kind = <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-keyword">input</span> uvm_sequence_base parent = <span class="hljs-literal">null</span>,<br>    <span class="hljs-keyword">input</span> uvm_object extension = <span class="hljs-literal">null</span>,<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">string</span> fname = <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">int</span> lineno = <span class="hljs-number">0</span>)<br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> peek(<span class="hljs-keyword">output</span> uvm_status_e status,  <br>    <span class="hljs-keyword">output</span> uvm_reg_data_t value,  <br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">string</span> kind = <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-keyword">input</span> uvm_sequence_base parent = <span class="hljs-literal">null</span>,<br>    <span class="hljs-keyword">input</span> uvm_object extension = <span class="hljs-literal">null</span>,<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">string</span> fname = <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">int</span> lineno = <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h4 id="4-4-使用后门操作"><a href="#4-4-使用后门操作" class="headerlink" title="4.4  使用后门操作"></a>4.4  使用后门操作</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> case0_cfg_vseq::body();<br>     uvm_status_e   status;<br>     uvm_reg_data_t value;<br>    p_sequencer<span class="hljs-variable">.p_rm</span><span class="hljs-variable">.counter_low</span><span class="hljs-variable">.poke</span>(status, <span class="hljs-number">16&#x27;hFFFD</span>); <span class="hljs-comment">// 后门写寄存器</span><br>    p_sequencer<span class="hljs-variable">.p_rm</span><span class="hljs-variable">.counter_low</span><span class="hljs-variable">.read</span>(status, value, UVM_FRONTDOOR); <span class="hljs-comment">// 前门读</span><br>    <br><span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><h3 id="5-层次化寄存器模型"><a href="#5-层次化寄存器模型" class="headerlink" title="5. 层次化寄存器模型"></a>5. 层次化寄存器模型</h3><p>​    层次化寄存器模型就是uvm_reg_block（第一级）中有uvm_reg_block（第二级），一般只在第二级block中添加寄存器。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> global_blk <span class="hljs-keyword">extends</span> uvm_reg_block;<br>    ...<br><span class="hljs-keyword">endclass</span><br><span class="hljs-keyword">class</span> buf_blk <span class="hljs-keyword">extends</span> uvm_reg_block;<br>    ...<br><span class="hljs-keyword">endclass</span><br><span class="hljs-keyword">class</span> mac_blk <span class="hljs-keyword">extends</span> uvm_reg_block;<br>    ...<br><span class="hljs-keyword">endclass</span><br><span class="hljs-keyword">class</span> reg_model <span class="hljs-keyword">extends</span> uvm_reg_block;<br>   <span class="hljs-keyword">rand</span> global_blk gb_ins;<br>   <span class="hljs-keyword">rand</span> buf_blk    bb_ins;<br>   <span class="hljs-keyword">rand</span> mac_blk    mb_ins;<br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build();<br>      default_map = create_map(<span class="hljs-string">&quot;default_map&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, UVM_BIG_ENDIAN, <span class="hljs-number">0</span>);<br>      gb_ins = global_blk::type_id::create(<span class="hljs-string">&quot;gb_ins&quot;</span>);<br>       gb_ins<span class="hljs-variable">.configure</span>(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// 这里只有两个参数</span><br>      gb_ins<span class="hljs-variable">.build</span>();<br>      gb_ins<span class="hljs-variable">.lock_model</span>();<br>       default_map<span class="hljs-variable">.add_submap</span>(gb_ins<span class="hljs-variable">.default_map</span>, <span class="hljs-number">16&#x27;h0</span>); <span class="hljs-comment">//将子map添加到父map</span><br>     ...<br>   <span class="hljs-keyword">endfunction</span><br>..<br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p>​    子block的default_map不知道寄存器的基地址，只知道偏移地址。add_submap（）函数将子block的map添加到父block的map中，并告诉子map的基地址。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> configure(uvm_reg_block parent = <span class="hljs-literal">null</span>,<span class="hljs-keyword">string</span>hdl_path = <span class="hljs-string">&quot;&quot;</span>)<br>    <span class="hljs-comment">// 第二个参数是reg block的hdl路径</span><br></code></pre></td></tr></table></figure><p>使用方法跟之前一样，只是层次化路径多了一层：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">p_rm<span class="hljs-variable">.gb_ins</span><span class="hljs-variable">.invert</span><span class="hljs-variable">.poke</span>(...);<br></code></pre></td></tr></table></figure><h3 id="6-reg-file"><a href="#6-reg-file" class="headerlink" title="6. reg_file"></a>6. reg_file</h3><p>主要用来区分不同的hdl路径。</p><p>如果有寄存器:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">top_tb<span class="hljs-selector-class">.dut</span><span class="hljs-selector-class">.fileA</span><span class="hljs-selector-class">.rega</span><br>top_tb<span class="hljs-selector-class">.dut</span><span class="hljs-selector-class">.fileA</span><span class="hljs-selector-class">.regb</span><br>top_tb<span class="hljs-selector-class">.dut</span><span class="hljs-selector-class">.fileA</span><span class="hljs-selector-class">.regc</span><br>...<br>top_tb<span class="hljs-selector-class">.dut</span><span class="hljs-selector-class">.fileB</span><span class="hljs-selector-class">.rega</span><br>top_tb<span class="hljs-selector-class">.dut</span><span class="hljs-selector-class">.fileB</span><span class="hljs-selector-class">.regb</span><br>top_tb<span class="hljs-selector-class">.dut</span><span class="hljs-selector-class">.fileB</span><span class="hljs-selector-class">.regc</span><br>...<br></code></pre></td></tr></table></figure><p>那么需要将寄存器的hdl路径告诉寄存器模型</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog">rega<span class="hljs-variable">.configure</span>(<span class="hljs-keyword">this</span>,<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;fileA.rega&quot;</span>);<br>rega<span class="hljs-variable">.configure</span>(<span class="hljs-keyword">this</span>,<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;fileA.regb&quot;</span>);<br>rega<span class="hljs-variable">.configure</span>(<span class="hljs-keyword">this</span>,<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;fileA.regc&quot;</span>);<br>....<br></code></pre></td></tr></table></figure><p>需要写好多fileA，并且如果fileA改成其他的值，需要重写。</p><p>可以单独把fileA拿出来，这就是uvm_reg_file。</p><p>uvm_reg_file是个纯虚基类，需要扩展后使用。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> regfile <span class="hljs-keyword">extends</span> uvm_reg_file;<br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;regfile&quot;</span>);<br>      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);<br>   <span class="hljs-keyword">endfunction</span><br><br>   `uvm_object_utils(regfile)<br><span class="hljs-keyword">endclass</span><br><span class="hljs-keyword">class</span> mac_blk <span class="hljs-keyword">extends</span> uvm_reg_block;<br><br>   <span class="hljs-keyword">rand</span> regfile file_a; <span class="hljs-comment">//定义reg file</span><br>   <span class="hljs-keyword">rand</span> reg_regA rega;<br>   <span class="hljs-keyword">rand</span> reg_regB regb;<br>   <span class="hljs-keyword">rand</span> reg_vlan vlan;<br>   <br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build();<br>      default_map = create_map(<span class="hljs-string">&quot;default_map&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, UVM_BIG_ENDIAN, <span class="hljs-number">0</span>);<br><br>      file_a = regfile::type_id::create(<span class="hljs-string">&quot;file_a&quot;</span>, , get_full_name());<br>       file_a<span class="hljs-variable">.configure</span>(<span class="hljs-keyword">this</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;fileA&quot;</span>); <span class="hljs-comment">//配置reg file路径</span><br>      <br>      regA = reg_regA::type_id::create(<span class="hljs-string">&quot;regA&quot;</span>, , get_full_name());<br>       regA<span class="hljs-variable">.configure</span>(<span class="hljs-keyword">this</span>, file_a, <span class="hljs-string">&quot;regA&quot;</span>); <span class="hljs-comment">// reg configure函数第二个参数是reg_file</span><br>      regA<span class="hljs-variable">.build</span>();<br>      default_map<span class="hljs-variable">.add_reg</span>(regA, <span class="hljs-number">&#x27;h31</span>, <span class="hljs-string">&quot;RW&quot;</span>);<br>       regB = reg_regB::type_id::create(<span class="hljs-string">&quot;regB&quot;</span>, , get_full_name());<br>      regB<span class="hljs-variable">.configure</span>(<span class="hljs-keyword">this</span>, file_a, <span class="hljs-string">&quot;regB&quot;</span>);<br>      regB<span class="hljs-variable">.build</span>();<br>      default_map<span class="hljs-variable">.add_reg</span>(regB, <span class="hljs-number">&#x27;h32</span>, <span class="hljs-string">&quot;RW&quot;</span>);<br>   <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>UVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
      <tag>UVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV——SV与C的接口</title>
    <link href="/2019/07/27/Verification/SystemVerilog/SV%E2%80%94%E2%80%94SV%E4%B8%8EC%E7%9A%84%E6%8E%A5%E5%8F%A3/"/>
    <url>/2019/07/27/Verification/SystemVerilog/SV%E2%80%94%E2%80%94SV%E4%B8%8EC%E7%9A%84%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<p>在Verilog中，通过VPI可以引用C程序，听说挺复杂的（，当然我不会）。在SV中引入了DPI（direct programming Interface），可以通过在SV中简单的设置，就可以引用C语言。</p><h3 id="1-SV简单引用C"><a href="#1-SV简单引用C" class="headerlink" title="1. SV简单引用C"></a>1. SV简单引用C</h3><p>先看一个例子</p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// tb.sv</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">int</span> factorial(<span class="hljs-keyword">input</span> <span class="hljs-keyword">int</span> i);<br><br><span class="hljs-keyword">program</span> test;<br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">10</span>;i++) <br>      <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;factorial(%d) is %d&quot;</span>,i,factorial(i));<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endprogram</span><br><span class="hljs-comment">//factorial.c</span><br><span class="hljs-keyword">int</span> factorial(<span class="hljs-keyword">int</span> i) &#123;<br>  <span class="hljs-keyword">if</span>(i&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> factorial(i-<span class="hljs-number">1</span>)*i;<br>&#125;<br></code></pre></td></tr></table></figure><p>用VCS直接编译这两个文件就行了。</p><h4 id="1-1-导入声明"><a href="#1-1-导入声明" class="headerlink" title="1.1  导入声明"></a>1.1  导入声明</h4><p>import将C函数引入SV，<strong>但使用的数据类型是SV的，这里就需要将C的类型转化成对应的SV数据类型。</strong></p><p>如果函数名跟SV中已有的函数冲突，还可以改名，如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span> new_name=<span class="hljs-keyword">function</span> <span class="hljs-keyword">int</span> factorial(<span class="hljs-keyword">input</span> <span class="hljs-keyword">int</span> i);<br><span class="hljs-comment">// 改名为new_name</span><br></code></pre></td></tr></table></figure><p><strong>如果c程序的类型是void，那么可以将C函数映射成task或者返回类型为void的function。</strong></p><p>在SV中允许声明子程序的地方都可以导入函数，可以将导入函数理解成定义了一个函数，只不过是用C语言写的。</p><p>也可以将import声明放在package中，如后导入package就可以。</p><h4 id="1-2-参数方向"><a href="#1-2-参数方向" class="headerlink" title="1.2 参数方向"></a>1.2 参数方向</h4><p>在import函数时可以设置的参数的输入输出方向有 input、output，不支持ref类型。</p><p>input：一般情况下参数方向是input；</p><p>output：当参数是指针（可以对输出数据进行修改）的时候，方向为output。但如果是const指针参数，说明不会改变输入对象，那么参数是input。</p><h4 id="1-3-参数类型"><a href="#1-3-参数类型" class="headerlink" title="1.3 参数类型"></a>1.3 参数类型</h4><p>通过DPI传递的每个变量都有两个数据类型，一个是C类型，一个是SV类型，必须确保兼容。</p><table><thead><tr><th>SystemVerilog</th><th>C（输入）</th><th>C（输出）</th></tr></thead><tbody><tr><td>byte</td><td>char</td><td>char*</td></tr><tr><td>shortint</td><td>short int</td><td>short int*</td></tr><tr><td>int</td><td>int</td><td>int*</td></tr><tr><td>longint</td><td>long long int</td><td>long int*</td></tr><tr><td>shortreal</td><td>float</td><td>float*</td></tr><tr><td>real</td><td>double</td><td>double*</td></tr><tr><td>string</td><td>const char*</td><td>char**</td></tr><tr><td>string[N]</td><td>const char*</td><td>char**</td></tr><tr><td>bit</td><td>svBit or unsigned char</td><td>svBit* or unsigned char*</td></tr><tr><td>logic,reg</td><td>svLogic or unsigned char</td><td>svLogic* or unsigned char*</td></tr><tr><td>bit[N:0]</td><td>const svBitVecVal*</td><td>svBitVecVal*</td></tr><tr><td>reg[N:0]orlogic[N:0]</td><td>const svLogicVecVal*</td><td>svLogicVecVal*</td></tr><tr><td>open array[]</td><td>const svOpenArrayHandle</td><td>svOpenArrayHandle</td></tr><tr><td>chandle</td><td>const void*</td><td>void*</td></tr></tbody></table><p>对于函数的返回类型，SV LRM中规定只能是void、byte、shortint、int、longint、real、shortreal、chandel和string、bit、logic。不能是bit[6:0]这样的向量。</p><p><strong>C的结构类型定义在头文件svdpi.h中，比如svBit。如果在C代码中使用了这些类型，那么需要在C中#include svdpi.h</strong></p><h4 id="1-4-导入数学库函数"><a href="#1-4-导入数学库函数" class="headerlink" title="1.4 导入数学库函数"></a>1.4 导入数学库函数</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">real</span> sin(<span class="hljs-keyword">real</span> a);<br><span class="hljs-keyword">program</span> test; <br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">5</span>;j++)<br>      <span class="hljs-built_in">$display</span>(sin(j));<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endprogram</span><br></code></pre></td></tr></table></figure><p>如上面的方式导入sin函数，可以直接在SV中使用。</p><h3 id="2-连接简单的C子程序"><a href="#2-连接简单的C子程序" class="headerlink" title="2. 连接简单的C子程序"></a>2. 连接简单的C子程序</h3><h4 id="2-1-使用静态变量的计数器"><a href="#2-1-使用静态变量的计数器" class="headerlink" title="2.1 使用静态变量的计数器"></a>2.1 使用静态变量的计数器</h4><p>下面是一个7位计数器。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs verilog">#<span class="hljs-keyword">include</span> &lt;svdpi<span class="hljs-variable">.h</span>&gt; <span class="hljs-comment">// 引入数据类型的声明</span><br><span class="hljs-keyword">void</span> counter7_static(svBitVecVal* o,<br>            <span class="hljs-keyword">const</span> svBitVecVal* i,<br>            <span class="hljs-keyword">const</span> svBit reset,<br>            <span class="hljs-keyword">const</span> svBit load) &#123;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> char count=<span class="hljs-number">0</span>; <span class="hljs-comment">//保存计数</span><br><span class="hljs-keyword">if</span>(reset)  count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(load)  count=*i;<br><span class="hljs-keyword">else</span>   count++;<br>count&amp;=<span class="hljs-number">0</span>x7f; <span class="hljs-comment">// 使最高位无效</span><br>*o = count; <span class="hljs-comment">// 返回计数值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在本例中7位的计数器保存在8位的字符型变量中，所以要使最高位无效。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// tb.sv</span><br><span class="hljs-keyword">import</span>  <span class="hljs-string">&quot;DPI-C&quot;</span> counter7_static=<span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> counter7_static(<span class="hljs-keyword">output</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">6</span>:<span class="hljs-number">0</span>] out,<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">6</span>:<span class="hljs-number">0</span>] in,<span class="hljs-keyword">bit</span> reset,<span class="hljs-keyword">bit</span> load);<br><br><span class="hljs-keyword">program</span> tb;<br><span class="hljs-keyword">bit</span> [<span class="hljs-number">6</span>:<span class="hljs-number">0</span>] in,out;<br><span class="hljs-keyword">bit</span> load,reset;<br><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>  <span class="hljs-built_in">$monitor</span>(<span class="hljs-string">&quot;SV:out=%3d,in=%3d,reset=%3d,load=%3d&quot;</span>,out,in,reset,load);<br>  reset = <span class="hljs-number">0</span>;  load=<span class="hljs-number">0</span>;  in=<span class="hljs-number">126</span>;  out=<span class="hljs-number">42</span>;<br>  counter7_static(out,in,reset,load);<br>#<span class="hljs-number">10</span>  reset=<span class="hljs-number">1</span>;<br>  counter7_static(out,in,reset,load);<br>#<span class="hljs-number">10</span> load=<span class="hljs-number">1</span>; reset=<span class="hljs-number">0</span>;<br>  counter7_static(out,in,reset,load);<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endprogram</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SV</span>:out=  <span class="hljs-number">1</span>,in=<span class="hljs-number">126</span>,reset=  <span class="hljs-number">0</span>,load=  <span class="hljs-number">0</span><br><span class="hljs-attribute">SV</span>:out=  <span class="hljs-number">0</span>,in=<span class="hljs-number">126</span>,reset=  <span class="hljs-number">1</span>,load=  <span class="hljs-number">0</span><br><span class="hljs-attribute">SV</span>:out=<span class="hljs-number">126</span>,in=<span class="hljs-number">126</span>,reset=  <span class="hljs-number">0</span>,load=  <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="2-2-chandle数据类型"><a href="#2-2-chandle数据类型" class="headerlink" title="2.2 chandle数据类型"></a>2.2 chandle数据类型</h4><p>​    上面计数器保存在静态变量中，如果只需要一个计数器，可以这样；但如果需要多个计数器，那么下一个计数器会覆盖之前的计数值，<strong>所以在C代码中不要把变量保存在静态变量中。需要动态申请</strong></p><p><strong>在SV中chandle类型可以存储一个C&#x2F;C++指针，这个指针指向对象的类型是任意的，可以是结构体。。。</strong></p><p><strong>C中如果返回void*指针类型，那么在SV中对应chandle。</strong></p><p><strong>C中的参数是结构体指针类型，那么SV中对应chandle。（这一条不是很确定，可以定义为chandle，也可以如下面第6节中所述）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;svdpi.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;malloc.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span> <span class="hljs-comment">// 计数器结构体</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> cnt;<br>&#125;c7;<br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">counter7_new</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">// 返回一个结构体指针，指向计数器</span><br>  c7* c = (c7*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(c7));<br>  c-&gt;cnt=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> c;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">counter7</span><span class="hljs-params">(c7* inst,  <span class="hljs-comment">// 计数器指针作为参数</span></span><br><span class="hljs-params">            svBitVecVal* o,</span><br><span class="hljs-params">            <span class="hljs-type">const</span> svBitVecVal* i,</span><br><span class="hljs-params">            <span class="hljs-type">const</span> svBit reset,</span><br><span class="hljs-params">            <span class="hljs-type">const</span> svBit load)</span> &#123;<br><br><span class="hljs-keyword">if</span>(reset) inst-&gt;cnt=<span class="hljs-number">0</span>; <span class="hljs-comment">// 对计数器进行操作</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(load) inst-&gt;cnt=*i;<br><span class="hljs-keyword">else</span> inst-&gt;cnt++; <br>inst-&gt;cnt&amp;=<span class="hljs-number">0x7f</span>;<br>*o = inst-&gt;cnt;<br>io_printf(<span class="hljs-string">&quot;C:count=%d,i=%d,reset=%d,load=%d\n&quot;</span>,*o,*i,reset,load);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面程序中定义了一个结构体来保存计数器；counter7_new()函数用来动态申请计数器的内存，保证每个计数器唯一。调用counter7函数的时候将相应的<strong>计数器指针</strong>（inst）作为参数传入其中。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">chandle</span> counter7_new();  <span class="hljs-comment">// 将结构体指针声明称chandle</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> counter7(<span class="hljs-keyword">input</span> <span class="hljs-keyword">chandle</span> inst,<span class="hljs-comment">// 将结构体指针声明称chandle</span><br>                                      <span class="hljs-keyword">output</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">6</span>:<span class="hljs-number">0</span>] out,<br>                                      <span class="hljs-keyword">input</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">6</span>:<span class="hljs-number">0</span>] in,<br>                                      <span class="hljs-keyword">input</span> <span class="hljs-keyword">bit</span> reset,<br>                                      <span class="hljs-keyword">input</span> <span class="hljs-keyword">bit</span> load<br>                                      );<br><br><span class="hljs-keyword">program</span> <span class="hljs-keyword">automatic</span> tb;<br><span class="hljs-keyword">bit</span> [<span class="hljs-number">6</span>:<span class="hljs-number">0</span>] in1,in2,out1,out2;<br><span class="hljs-keyword">bit</span> load,reset,clk;<br><span class="hljs-keyword">chandle</span> inst1,inst2;<br><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br><span class="hljs-comment">//  $monitor(&quot;@ %0t SV:out2=%3d,in2=%3d,reset=%3d,load=%3d\n&quot;,$time,out2,in2,reset,load);</span><br><span class="hljs-comment">//  $monitor(&quot;@ %0t SV:out1=%3d,in1=%3d,reset=%3d,load=%3d\n&quot;,$time,out1,in1,reset,load);</span><br>    inst1=counter7_new(); <span class="hljs-comment">// 调用函数创建计数器</span><br>  inst2=counter7_new();<br>  clk=<span class="hljs-number">0</span>;<br>  reset = <span class="hljs-number">0</span>;<br>  load=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">fork</span><br>    <span class="hljs-keyword">forever</span> #<span class="hljs-number">5</span> clk = ~clk;<br>    <span class="hljs-keyword">forever</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>      counter7(inst1,out1,in1,reset,load);<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@ %0t SV:out1=%3d,in1=%3d,reset=%3d,load=%3d\n&quot;</span>,<span class="hljs-built_in">$time</span>,out1,in1,reset,load);<br><br>      counter7(inst2,out2,in2,reset,load);<br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@ %0t SV:out2=%3d,in2=%3d,reset=%3d,load=%3d\n&quot;</span>,<span class="hljs-built_in">$time</span>,out2,in2,reset,load);<br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">join_none</span><br>  in1=<span class="hljs-number">120</span>;<br>  in2=<span class="hljs-number">20</span>;<br>  @(<span class="hljs-keyword">negedge</span> clk) load=<span class="hljs-number">1</span>;<br>  @(<span class="hljs-keyword">negedge</span> clk) reset=<span class="hljs-number">1</span>;<br>  @(<span class="hljs-keyword">negedge</span> clk) reset=<span class="hljs-number">0</span>;<br>  @(<span class="hljs-keyword">negedge</span> clk) load=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">repeat</span>(<span class="hljs-number">5</span>) @(<span class="hljs-keyword">posedge</span> clk);<br>  @(<span class="hljs-keyword">negedge</span> clk) <span class="hljs-built_in">$finish</span>;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>$vcdpluson;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endprogram</span><br></code></pre></td></tr></table></figure><p><strong>计数器结构体的指针，在SV中对应chandle数据类型。</strong></p><h3 id="3-调用C-子程序"><a href="#3-调用C-子程序" class="headerlink" title="3. 调用C++子程序"></a>3. 调用C++子程序</h3><p>在SV中可以使用DPI调用C\C++子程序，模型的抽象层次不同调用方式不同。</p><h4 id="3-1-C-中的计数器"><a href="#3-1-C-中的计数器" class="headerlink" title="3.1 C++中的计数器"></a>3.1 C++中的计数器</h4><p>用类实现计数器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;svdpi.h&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Counter</span>() &#123;    cnt = <span class="hljs-number">0</span>;    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">counter7_signal</span> <span class="hljs-params">(  svBitVecVal* count, <span class="hljs-type">const</span> svBitVecVal* i,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> svBit reset, <span class="hljs-type">const</span> svBit load         )</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">if</span>(reset) cnt=<span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(load) cnt=*i;<br>      <span class="hljs-keyword">else</span> cnt++;<br>      cnt &amp;=<span class="hljs-number">0x7f</span>;<br>     *count = cnt; <br>    &#125;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> cnt;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="3-2-静态方法"><a href="#3-2-静态方法" class="headerlink" title="3.2 静态方法"></a>3.2 静态方法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">counter7_new</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Counter;<br>&#125;<br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">counter7</span> <span class="hljs-params">( <span class="hljs-type">void</span>* inst, svBitVecVal* out, <span class="hljs-type">const</span> svBitVecVal* in,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> svBit reset, <span class="hljs-type">const</span> svBit load    </span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span><br><span class="hljs-function"></span>&#123;<br>  Counter* c7=(Counter*) inst;<br>  c7-&gt;<span class="hljs-built_in">counter7_signal</span>(out,in,reset,load);<br>  <span class="hljs-keyword">delete</span> c7;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过DPI只能调用静态的C、C++方法，即链接时已经存在的方法。C++对象在链接的时候还不存在，那么方法也就不存在。</p><p>解决方法：通过创建与C++动态对象和方法通信的静态方法，也就是上面的两个方法。<strong>将对象的指针传入函数。</strong></p><p>**extern “C”**告诉C++编译器，送入链接器的外部信息应当使用C调用风格，并且不能执行名字调整name mangling。（基本支持函数重载的语言都需要进行name mangling。mangling的目的就是为了给重载的函数不同的签名，以避免调用时的二义性调用。）</p><p>可以直接使用第2节中的tb。</p><h4 id="3-3-和事务级C-模型通信"><a href="#3-3-和事务级C-模型通信" class="headerlink" title="3.3 和事务级C++模型通信"></a>3.3 和事务级C++模型通信</h4><p>事务级通信中用的是方法，而不是信号和时钟。</p><p><strong>1.先用C++实现事务级的计数器。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;svdpi.h&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter7</span>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Counter7</span>()&#123;cnt=<span class="hljs-number">0</span>;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span></span>&#123;cnt=<span class="hljs-number">0</span>;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">load</span><span class="hljs-params">(<span class="hljs-type">const</span> svBitVecVal* i)</span></span>&#123;cnt=*i;cnt&amp;=<span class="hljs-number">0x7f</span>;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">count</span><span class="hljs-params">()</span></span>&#123;cnt++;cnt&amp;=<span class="hljs-number">0x7f</span>;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> cnt;&#125;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> cnt;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>2.将动态方法包装成静态方法。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">counter7_new</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-built_in">io_printf</span>(<span class="hljs-string">&quot;call new()\n&quot;</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Counter7;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">counter7_reset</span><span class="hljs-params">(<span class="hljs-type">void</span>* inst)</span></span>&#123;<br>      <span class="hljs-built_in">io_printf</span>(<span class="hljs-string">&quot;call counter7_reset()\n&quot;</span>);<br>      Counter7 * c7=(Counter7*) inst;<br>      c7-&gt;<span class="hljs-built_in">reset</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">counter7_load</span><span class="hljs-params">(<span class="hljs-type">void</span>* inst,<span class="hljs-type">const</span> svBitVecVal* i)</span></span>&#123;<br>      <span class="hljs-built_in">io_printf</span>(<span class="hljs-string">&quot;call counter7_load()\n&quot;</span>);<br>      Counter7 * c7=(Counter7*) inst;<br>      c7-&gt;<span class="hljs-built_in">load</span>(i);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">counter7_count</span><span class="hljs-params">(<span class="hljs-type">void</span>* inst)</span></span>&#123;<br>      <span class="hljs-built_in">io_printf</span>(<span class="hljs-string">&quot;call counter7_count()\n&quot;</span>);<br>      Counter7 * c7=(Counter7*) inst;<br>      c7-&gt;<span class="hljs-built_in">count</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">counter7_get</span><span class="hljs-params">(<span class="hljs-type">void</span>* inst)</span></span>&#123;<br>      <span class="hljs-built_in">io_printf</span>(<span class="hljs-string">&quot;call counter7_get()\n&quot;</span>);<br>      Counter7 * c7=(Counter7*) inst;<br>      <span class="hljs-keyword">return</span> c7-&gt;<span class="hljs-built_in">get</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3.在测试平台中将方法引入</strong></p><p>​    注意get（）函数的返回值，它应该返回bit[6:0] 7位数据，但是规定导入函数只能返回void、byte、shortint、int、longint、real、shortreal、chandel和string、bit、logic。不能是bit[6:0]这样的向量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span> <span class="hljs-function">function chandle <span class="hljs-title">counter7_new</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span> <span class="hljs-function">function <span class="hljs-type">void</span> <span class="hljs-title">counter7_reset</span><span class="hljs-params">(input chandle inst)</span></span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span> <span class="hljs-function">function <span class="hljs-type">void</span> <span class="hljs-title">counter7_load</span><span class="hljs-params">(input chandle inst,input  bit[<span class="hljs-number">6</span>:<span class="hljs-number">0</span>] i)</span></span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span> <span class="hljs-function">function <span class="hljs-type">void</span> <span class="hljs-title">counter7_count</span><span class="hljs-params">(input chandle inst)</span></span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span> <span class="hljs-function">function <span class="hljs-type">int</span> <span class="hljs-title">counter7_get</span><span class="hljs-params">(input chandle inst)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>4.为了方便使用，将引入的方法封装成类</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> Counter7;<br>    <span class="hljs-keyword">chandle</span> inst;<br>    <span class="hljs-keyword">string</span> id;<br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> str);<br>      id=str;<br>      inst = counter7_new();<br>    <span class="hljs-keyword">endfunction</span>:<span class="hljs-keyword">new</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> reset();<br>      counter7_reset(inst);<br>    <span class="hljs-keyword">endfunction</span>:reset<br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> count();<br>      counter7_count(inst);<br>    <span class="hljs-keyword">endfunction</span>:count<br>    <span class="hljs-keyword">function</span> load(<span class="hljs-keyword">bit</span>[<span class="hljs-number">6</span>:<span class="hljs-number">0</span>] i);<br>      counter7_load(inst,i);<br>    <span class="hljs-keyword">endfunction</span>:load<br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">6</span>:<span class="hljs-number">0</span>] get();<br>      <span class="hljs-keyword">bit</span>[<span class="hljs-number">6</span>:<span class="hljs-number">0</span>] tmp = counter7_get(inst);<br>      <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@%0t : [%s] count is %d&quot;</span>,<span class="hljs-built_in">$time</span>,id,tmp);<br>      <span class="hljs-keyword">return</span> tmp;<br>    <span class="hljs-keyword">endfunction</span>:get<br><span class="hljs-keyword">endclass</span>:Counter7<br></code></pre></td></tr></table></figure><p>在测试平台中使用计数器的时候，定义一个Counter7对象，然后调用它的方法就行了。</p><p><strong>5.测试平台</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">program</span> <span class="hljs-keyword">automatic</span> tb;<br><span class="hljs-keyword">bit</span> clk;<br><span class="hljs-keyword">bit</span>[<span class="hljs-number">6</span>:<span class="hljs-number">0</span>] out1,out2;<br>Counter7 c1,c2;<br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">forever</span> #<span class="hljs-number">5</span> clk = ~clk;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>  clk = <span class="hljs-number">0</span>;<br>  c1=<span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;c1&quot;</span>);<br>  c2=<span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;c2&quot;</span>);<br>  <span class="hljs-keyword">fork</span><br>      <span class="hljs-keyword">begin</span><br>          @(<span class="hljs-keyword">posedge</span> clk)  c1<span class="hljs-variable">.reset</span>();<br>          @(<span class="hljs-keyword">posedge</span> clk)  c1<span class="hljs-variable">.load</span>(<span class="hljs-number">100</span>);<br>          <span class="hljs-keyword">repeat</span>(<span class="hljs-number">10</span>) @(<span class="hljs-keyword">posedge</span> clk)<span class="hljs-keyword">begin</span><br>              c1<span class="hljs-variable">.count</span>();<br>              out1=c1<span class="hljs-variable">.get</span>();<br>          <span class="hljs-keyword">end</span><br>      <span class="hljs-keyword">end</span><br>      <span class="hljs-keyword">begin</span><br>          @(<span class="hljs-keyword">posedge</span> clk)  c2<span class="hljs-variable">.reset</span>();<br>          @(<span class="hljs-keyword">posedge</span> clk)  c2<span class="hljs-variable">.load</span>(<span class="hljs-number">10</span>);<br>          <span class="hljs-keyword">repeat</span>(<span class="hljs-number">10</span>) @(<span class="hljs-keyword">posedge</span> clk)<span class="hljs-keyword">begin</span><br>              c2<span class="hljs-variable">.count</span>();<br>              out2=c2<span class="hljs-variable">.get</span>();<br>          <span class="hljs-keyword">end</span><br>      <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">join_none</span><br>  <span class="hljs-keyword">repeat</span>(<span class="hljs-number">20</span>) @(<span class="hljs-keyword">posedge</span> clk); <span class="hljs-built_in">$finish</span>;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endprogram</span><br></code></pre></td></tr></table></figure><p><strong>6.输出</strong></p><p>两个计数器并行计数，各记各的，互不干扰。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">call <span class="hljs-keyword">new</span>()</span><br><span class="hljs-function">call <span class="hljs-keyword">new</span>()</span><br><span class="hljs-function">call <span class="hljs-title">counter7_reset</span>()</span><br><span class="hljs-function">call <span class="hljs-title">counter7_reset</span>()</span><br><span class="hljs-function">call <span class="hljs-title">counter7_load</span>()</span><br><span class="hljs-function">call <span class="hljs-title">counter7_load</span>()</span><br><span class="hljs-function">call <span class="hljs-title">counter7_count</span>()</span><br><span class="hljs-function">call <span class="hljs-title">counter7_get</span>()</span><br><span class="hljs-function">@25000 : [c1] count <span class="hljs-keyword">is</span> 101</span><br><span class="hljs-function">call <span class="hljs-title">counter7_count</span>()</span><br><span class="hljs-function">call <span class="hljs-title">counter7_get</span>()</span><br><span class="hljs-function">@25000 : [c2] count <span class="hljs-keyword">is</span>  11</span><br><span class="hljs-function">call <span class="hljs-title">counter7_count</span>()</span><br><span class="hljs-function">call <span class="hljs-title">counter7_get</span>()</span><br><span class="hljs-function">@35000 : [c1] count <span class="hljs-keyword">is</span> 102</span><br><span class="hljs-function">call <span class="hljs-title">counter7_count</span>()</span><br><span class="hljs-function">call <span class="hljs-title">counter7_get</span>()</span><br><span class="hljs-function">@35000 : [c2] count <span class="hljs-keyword">is</span>  12</span><br><span class="hljs-function">call <span class="hljs-title">counter7_count</span>()</span><br><span class="hljs-function">call <span class="hljs-title">counter7_get</span>()</span><br></code></pre></td></tr></table></figure><h3 id="4-共享简单数组"><a href="#4-共享简单数组" class="headerlink" title="4. 共享简单数组"></a>4. 共享简单数组</h3><h4 id="4-1-双状态一维数组"><a href="#4-1-双状态一维数组" class="headerlink" title="4.1 双状态一维数组"></a>4.1 双状态一维数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;svdpi.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;veriuser.h&gt;</span></span><br><br><span class="hljs-comment">//data : OUTPUT</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fib</span><span class="hljs-params">(svBitVecVal data[<span class="hljs-number">20</span>])</span></span>&#123;<br>  <span class="hljs-type">int</span> i;<br>  data[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>  data[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span>( i=<span class="hljs-number">2</span>;i&lt;<span class="hljs-number">20</span>;i++) &#123;<br>    data[i] = data[i<span class="hljs-number">-1</span>] + data[i<span class="hljs-number">-2</span>];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这里的参数是svBitVecVal，没有星号。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> fib(<span class="hljs-keyword">output</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] data[<span class="hljs-number">20</span>]);<br><span class="hljs-comment">// 数组有大小</span><br><span class="hljs-keyword">program</span> <span class="hljs-keyword">automatic</span> tb;<br>  <span class="hljs-keyword">bit</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] data[<span class="hljs-number">20</span>];<br>  <span class="hljs-keyword">bit</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] da;<br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    fib(data);<br>    <span class="hljs-keyword">foreach</span>(data[i]) <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;%d : %d&quot;</span>,i,data[i]);<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endprogram</span><br></code></pre></td></tr></table></figure><h3 id="5-开放数组-open-array"><a href="#5-开放数组-open-array" class="headerlink" title="5. 开放数组 open array"></a>5. 开放数组 open array</h3><p>开放数组定义在svdpi.h中，在C代码中，可以通过开放数组，操作任何大小的数组。</p><h3 id="6-传递特殊结构"><a href="#6-传递特殊结构" class="headerlink" title="6. 传递特殊结构"></a>6. 传递特殊结构</h3><h4 id="6-1-SV和C之间传递结构体参数"><a href="#6-1-SV和C之间传递结构体参数" class="headerlink" title="6.1 SV和C之间传递结构体参数"></a>6.1 SV和C之间传递结构体参数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C代码</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> r,g,b;<br>&#125;* s_rgb;<br><span class="hljs-type">void</span> <span class="hljs-title function_">invert</span><span class="hljs-params">(s_rgb rgb)</span>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// SV</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<span class="hljs-keyword">bit</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] r,g,b;&#125; RGB; <span class="hljs-comment">//将C的结构体定义成SV的结构体</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> invert(<span class="hljs-keyword">inout</span> RGB rgb); <span class="hljs-comment">//使用SV结构体</span><br><span class="hljs-keyword">program</span> <span class="hljs-keyword">automatic</span> tb;<br>..<br><span class="hljs-keyword">endprogram</span><br></code></pre></td></tr></table></figure><h4 id="6-2-传递字符串"><a href="#6-2-传递字符串" class="headerlink" title="6.2 传递字符串"></a>6.2 传递字符串</h4><p>从C程序向SV返回字符串。</p><p><strong>最简单的方法是字符串返回值；</strong></p><p><strong>还有一种是char</strong>类型的参数。**</p><p>下面程序同时用了这两种方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;svdpi.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;veriuser.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* in,<span class="hljs-type">char</span>** out)</span> </span>&#123;<br>    <br>  <span class="hljs-type">static</span> <span class="hljs-type">char</span> * s;<br>  s=in;<br>  *out=in;<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;DPI-C&quot;</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">string</span> test(<span class="hljs-keyword">input</span> <span class="hljs-keyword">string</span> in,<span class="hljs-keyword">output</span> <span class="hljs-keyword">string</span> out);<br><span class="hljs-keyword">program</span> <span class="hljs-keyword">automatic</span> tb;<br>  <span class="hljs-keyword">string</span> s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>  <span class="hljs-keyword">string</span> s2;<br>  <span class="hljs-keyword">string</span> s3;<br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    s3 = test(s1,s2);<br>    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;s2=%s,s3=%s\n&quot;</span>,s2,s3);<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endprogram</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">s2</span>=hello,s3=hello<br></code></pre></td></tr></table></figure><p>从输出看一看到，test函数既返回了string值，也修改了传入的参数s2.</p><h3 id="7-C也可以调用SV的函数。"><a href="#7-C也可以调用SV的函数。" class="headerlink" title="7. C也可以调用SV的函数。"></a>7. C也可以调用SV的函数。</h3>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逻辑综合——便捷命令</title>
    <link href="/2019/07/24/IC/Synthesis/%E9%80%BB%E8%BE%91%E7%BB%BC%E5%90%88%E2%80%94%E2%80%94%E4%BE%BF%E6%8D%B7%E5%91%BD%E4%BB%A4/"/>
    <url>/2019/07/24/IC/Synthesis/%E9%80%BB%E8%BE%91%E7%BB%BC%E5%90%88%E2%80%94%E2%80%94%E4%BE%BF%E6%8D%B7%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h4 id="1-获取感兴趣的对象"><a href="#1-获取感兴趣的对象" class="headerlink" title="1. 获取感兴趣的对象"></a>1. 获取感兴趣的对象</h4><figure class="highlight tcl"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs tcl">filter_collection [get_cells *] <span class="hljs-string">&quot;ref_name=AN*&quot;</span> #找到以AN开头的单元名字<br>get_cells -filter <span class="hljs-string">&quot;ref_name = AN*&quot;</span> #找到以AN开头的单元名字<br>get_cells -filter <span class="hljs-string">&quot;dont_touch==true&quot;</span> # 按照属性过滤<br></code></pre></td></tr></table></figure><h4 id="2-获得属性-get-attribute"><a href="#2-获得属性-get-attribute" class="headerlink" title="2. 获得属性 get_attribute"></a>2. 获得属性 get_attribute</h4><p>可以获得时钟、库单元等的属性</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl">get_attribute [get_clocks CLK] <span class="hljs-keyword">clock</span> #获得时钟周期<br></code></pre></td></tr></table></figure><h4 id="3-collection格式转化成list格式"><a href="#3-collection格式转化成list格式" class="headerlink" title="3. collection格式转化成list格式"></a>3. collection格式转化成list格式</h4><p>get_cells  all_*这些命令产生的是collection，为了方便操作，需要转化成list格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> reg_coll [all_registers]  <span class="hljs-comment">#reg_coll是collection</span><br><span class="hljs-built_in">set</span> reg [get_object_name <span class="hljs-variable">$&#123;reg_coll&#125;</span>]   <span class="hljs-comment">#reg 是list</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>Synthesis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>Synthesis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逻辑综合——设置库</title>
    <link href="/2019/07/24/IC/Synthesis/%E9%80%BB%E8%BE%91%E7%BB%BC%E5%90%88%E2%80%94%E2%80%94%E8%AE%BE%E7%BD%AE%E5%BA%93/"/>
    <url>/2019/07/24/IC/Synthesis/%E9%80%BB%E8%BE%91%E7%BB%BC%E5%90%88%E2%80%94%E2%80%94%E8%AE%BE%E7%BD%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>逻辑综合分成三步：<strong>综合&#x3D;转化+优化+映射</strong>。</p><p>​    DC先通过read命令将RTL设计转化成布尔表达式，也就是GTECH格式，然后执行compile命令，按照设计约束进行逻辑综合和优化，并使用工艺库中的逻辑单元映射成门级网表</p><p>​    DC以时序为基础进行优化。DC内建STA工具，将设计分解成多条时序路径，通过计算路径延迟对它们进行约束和优化。</p><h4 id="1-目标库-target-library"><a href="#1-目标库-target-library" class="headerlink" title="1. 目标库 target library"></a>1. 目标库 target library</h4><p>​    DC根据目标库中的电路单元计算延迟，并映射成门级网表。</p><figure class="highlight tcl"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-keyword">set</span> target_library my_tech.db<br></code></pre></td></tr></table></figure><h4 id="2-连接库-link-library"><a href="#2-连接库-link-library" class="headerlink" title="2. 连接库 link library"></a>2. 连接库 link library</h4><p>​    当读入门级网表时候，连接库指向生成该门级网表的目标库。DC通过目标库来识别门级网表中的<strong>门单元及模块的功能及整个电路的功能</strong>。<strong>对于门单元要从库中找到对应的门单元的实际库单元来替换；对于模块，DC要知道它们的网表在什么地方。</strong></p><p>​    链接库一般设置成与目标库相同。</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-keyword">set</span> link_library <span class="hljs-string">&quot;* $target_library&quot;</span><br></code></pre></td></tr></table></figure><p>符号*表示先从内存中找库。</p><h4 id="3-符号库-symbol-library"><a href="#3-符号库-symbol-library" class="headerlink" title="3. 符号库 symbol library"></a>3. 符号库 symbol library</h4><p>在图形化界面中来显示网表中的单元的符号，要跟相应的目标库对应，以.sdb后缀。</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-keyword">set</span> sysbol_library <span class="hljs-string">&quot;my_tech.sdb&quot;</span><br></code></pre></td></tr></table></figure><h4 id="4-搜索目录"><a href="#4-搜索目录" class="headerlink" title="4. 搜索目录"></a>4. 搜索目录</h4><p>search path是库的搜索目录，DC会在这些目录下找库。</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-keyword">set</span> search_path <span class="hljs-string">&quot; &quot;</span><br></code></pre></td></tr></table></figure><h4 id="5-DesignWare库"><a href="#5-DesignWare库" class="headerlink" title="5. DesignWare库"></a>5. DesignWare库</h4><p>DesignWare是synopsys提供的IP库，如果用到其中的库需要设置。</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-keyword">set</span> synthetic_library  dw_foundation.sldb<br><span class="hljs-keyword">lappend</span>  link_library <span class="hljs-variable">$synthetic_library</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>Synthesis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>Synthesis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV——OOP技巧</title>
    <link href="/2019/07/23/Verification/SystemVerilog/SV%E2%80%94%E2%80%94OOP%E6%8A%80%E5%B7%A7/"/>
    <url>/2019/07/23/Verification/SystemVerilog/SV%E2%80%94%E2%80%94OOP%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="1-事务传递"><a href="#1-事务传递" class="headerlink" title="1. 事务传递"></a>1. 事务传递</h3><p>​    在事务生成器中，每次新建transaction，随机化后发送给接收器，这样每次发送函数transmit(tr)发送的transaction都不同。避免了transmit程序需要多个cycle，后面的随机化将前面还没有发送完成的数据覆盖了。</p><p>​    下面这种写法是只创建一个transaction对象，对对象进行多次随机化，后面的随机化可能会覆盖前面没发送的数据。</p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">class</span> Generator;<br>Transaction tr; <span class="hljs-comment">//声明句柄</span><br><span class="hljs-keyword">task</span> gen(<span class="hljs-keyword">int</span> n);<br>tr = <span class="hljs-keyword">new</span>(); <span class="hljs-comment">// 新建一个对象</span><br><span class="hljs-keyword">repeat</span>(n) <span class="hljs-keyword">begin</span><br>tr<span class="hljs-variable">.randomize</span>(); <span class="hljs-comment">//随机化transaction</span><br>transmit(tr); <span class="hljs-comment">//发送transaction</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p>​    <strong>每次新建新的对象，再随机化之后发送。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">class</span> Generator;<br>Transaction tr; <span class="hljs-comment">//声明句柄</span><br><span class="hljs-keyword">task</span> gen(<span class="hljs-keyword">int</span> n);<br><span class="hljs-keyword">repeat</span>(n) <span class="hljs-keyword">begin</span><br>tr = <span class="hljs-keyword">new</span>(); <span class="hljs-comment">// 每次新建一个对象</span><br>tr<span class="hljs-variable">.randomize</span>(); <span class="hljs-comment">//随机化transaction</span><br>transmit(tr); <span class="hljs-comment">//发送transaction</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><h3 id="2-继承"><a href="#2-继承" class="headerlink" title="2. 继承"></a>2. 继承</h3><p>在子类的构造函数中，第一行先调用父类的构造函数，如果父类的构造函数有传入参数，那么子类构造也要有参数。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> Parent;<br><span class="hljs-keyword">int</span> <span class="hljs-keyword">var</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">int</span> n);<br><span class="hljs-keyword">var</span> = n;<br><span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br><span class="hljs-keyword">class</span> Child <span class="hljs-keyword">extends</span> Parent;<br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">int</span> n); <span class="hljs-comment">//必须传入参数</span><br><span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(n);<br><span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><h3 id="3-blueprint模式"><a href="#3-blueprint模式" class="headerlink" title="3. blueprint模式"></a>3. blueprint模式</h3><p>​    蓝图（blueprint）模式可以在不改变生成器代码的前提下，让生成器生成并发送不同的transaction。</p><p>​    在生成器中定义hook对象，也可以叫他蓝图对象，然后再testbench将这个对象通过层次引用的方式替换成需要的对象。</p><p>​    作用：不需要修改generator代码，就可以生成不同的transaction。</p><p>​    在第一节中，将事务创建和发送写在一起，避免覆盖的问题，但那也使得没法通过层次引用来替换generator中的对象，因为一创建对象，立马就随机化并发送了。所以必须营造这样的流程：</p><p>​    <strong>generator中的new函数创建transaction —-&gt;&gt;&gt; tb中在对象创建后将对象替换 —-&gt;&gt;&gt;generator中随机化对象，并发送对象的一个深拷贝（避免覆盖问题）。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">class</span> Generator;<br>Transaction blueprint; <span class="hljs-comment">//声明句柄</span><br>    mailbox mlb;<br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">input</span> mailbox mlb_i);<br>        mlb = mlb_i;<br>        blueprint = <span class="hljs-keyword">new</span>(); <span class="hljs-comment">// 在new函数中新建一个对象</span><br>    <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">task</span> run(<span class="hljs-keyword">int</span> n);<br><span class="hljs-keyword">repeat</span>(n) <span class="hljs-keyword">begin</span><br>blueprint<span class="hljs-variable">.randomize</span>(); <span class="hljs-comment">//随机化blueprint</span><br>            mlb<span class="hljs-variable">.put</span>(blueprint<span class="hljs-variable">.copy</span>()); <span class="hljs-comment">//发送blueprint的深拷贝</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p>在使用的时候，在testbench中：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> Env;<br>    Generator gen;<br>    Driver drv;<br>    mailbox mlb;<br>    ....<br><span class="hljs-keyword">endclass</span><br><span class="hljs-keyword">module</span> tb;<br>Env env;<br>    <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>        env=<span class="hljs-keyword">new</span>();<br>        env<span class="hljs-variable">.build</span>(); <span class="hljs-comment">//创建验证平台对象（结构）</span><br>        BadTr bad=<span class="hljs-keyword">new</span>(); <span class="hljs-comment">// 新的事务</span><br>        env<span class="hljs-variable">.gen</span><span class="hljs-variable">.blueprint</span>=bad; <span class="hljs-comment">//验证平台对象创建后，将新事务替换blueprint，那么发送的就是bad</span><br>        env<span class="hljs-variable">.run</span>(); <span class="hljs-comment">//运行平台（发送接受tr）</span><br>        env<span class="hljs-variable">.wrap_up</span>();<span class="hljs-comment">//清理</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h3 id="4-纯虚方法和抽象类"><a href="#4-纯虚方法和抽象类" class="headerlink" title="4. 纯虚方法和抽象类"></a>4. 纯虚方法和抽象类</h3><p><strong>抽象类可以被扩展但不能被实例化，用virtual关键字定义。</strong></p><p><strong>纯虚方法没有实体，只有声明。只能定义在抽象类中，但抽象类中可以由其他非纯虚方法。****pure</strong></p><p>由抽象类扩展的子类，必须将抽象类中的纯虚方法都重定义了才能用。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">class</span> Base;<br><span class="hljs-keyword">pure</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> get();<br><span class="hljs-keyword">pure</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> cmp(<span class="hljs-keyword">int</span> i);<br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><h3 id="5-回调-callback"><a href="#5-回调-callback" class="headerlink" title="5.回调 callback"></a>5.回调 callback</h3><p>​    希望创建一个不需要修改就可以生成所有激励的验证平台。方法是在测试平台上提供一些hook，使得测试程序在不改变验证平台代码的前提下，向测试平台注入一些代码，改变发生器的行为，产生需要的激励。</p><p>​    通过<strong>继承</strong>的方法来实现。</p><h4 id="5-1-创建并使用回调"><a href="#5-1-创建并使用回调" class="headerlink" title="5.1 创建并使用回调"></a>5.1 创建并使用回调</h4><p>1）定义回调基类，可以定义为纯虚方法</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">class</span> CallBack;<br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> pre_tx(<span class="hljs-keyword">ref</span> Transaction tr,<span class="hljs-keyword">ref</span> <span class="hljs-keyword">bit</span> drop);<br><span class="hljs-comment">//空方法</span><br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> post_tx(<span class="hljs-keyword">ref</span> Transaction tr);<br><span class="hljs-comment">//空方法</span><br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p>2）driver中使用回调基类</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> Driver ;<br>    CallBack cbs[$]; <span class="hljs-comment">//队列保存回调类</span><br>Transaction tr;<br><span class="hljs-keyword">bit</span> drop;<br>    mailbox mlb;<br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(mailbox m);mlb=m;<span class="hljs-keyword">endfunction</span><br>taks run();<br>        <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span><br>drop=<span class="hljs-number">0</span>;<br>mlb<span class="hljs-variable">.get</span>(tr);<br>            <span class="hljs-keyword">foreach</span>(cbs[i]) cbs<span class="hljs-variable">.pre_tx</span>(tr,drop); <span class="hljs-comment">// 调用回调基类</span><br><span class="hljs-keyword">if</span>(drop) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//结束这一次循环，不发送这个tr。</span><br>transmit(tr);<span class="hljs-comment">//发送tr</span><br><span class="hljs-keyword">foreach</span>(cbs[i]) cbs<span class="hljs-variable">.post_tx</span>(tr);<br>        <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p>此时cbs是空的，不会调用foreach语句。</p><p>3）定义回调类、回调函数。</p><p>回调类继承回调基类</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">class</span> CallBack_drop <span class="hljs-keyword">extends</span> CallBack;<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> pre_tx(<span class="hljs-keyword">ref</span> Transaction tr,<span class="hljs-keyword">ref</span> <span class="hljs-keyword">bit</span> drop);<br> <span class="hljs-comment">// 没100个tr取消一个</span><br>drop=(<span class="hljs-built_in">$random</span>(<span class="hljs-number">0</span>,<span class="hljs-number">99</span>)==<span class="hljs-number">0</span>);<br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p>4）在顶层注入回调函数</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">program</span> <span class="hljs-keyword">automatic</span> test;<br>Env env;<br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>env=<span class="hljs-keyword">new</span>();<br>env<span class="hljs-variable">.gen_cfg</span>();<br>env<span class="hljs-variable">.build</span>();<br><span class="hljs-keyword">begin</span><br>CallBack_drop cb=<span class="hljs-keyword">new</span>();<br>            env<span class="hljs-variable">.drv</span><span class="hljs-variable">.cbs</span><span class="hljs-variable">.push_back</span>(cb); <span class="hljs-comment">//注入回调</span><br><span class="hljs-keyword">end</span><br>        env<span class="hljs-variable">.run</span>();<br>        env<span class="hljs-variable">.wrap_up</span>();<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endprogram</span><br></code></pre></td></tr></table></figure><h4 id="5-2-回调与记分板连接"><a href="#5-2-回调与记分板连接" class="headerlink" title="5.2 回调与记分板连接"></a>5.2 回调与记分板连接</h4><p>在driver的回调中假如记分板，<strong>可以将driver发送的tr保存在记分板中。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">class</span> CallBack_scb extend CallBack;<br>Scb scb;<br><span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(Scb s);<br><span class="hljs-keyword">this</span><span class="hljs-variable">.scb</span> = s;<br><span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> pre_tx(<span class="hljs-keyword">ref</span> Transaction tr,<span class="hljs-keyword">ref</span> <span class="hljs-keyword">bit</span> drop);<br>scb<span class="hljs-variable">.save_expected</span>(tr);<span class="hljs-comment">// 保存发送的tr到记分板</span><br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><p>也可以对覆盖率用回调，将发送的tr收集到覆盖率的类中。</p><p>使用的时候也是在tb上注入到Driver中。</p><h3 id="6-参数化的类"><a href="#6-参数化的类" class="headerlink" title="6. 参数化的类"></a>6. 参数化的类</h3><p>要用<strong>type</strong>关键字定义类型。</p><p>要写一个参数化类，先要写一个非参数化的类，然后将他转换成参数化。</p><p>下面实现一个参数化的堆栈。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> Stack<span class="hljs-variable">#(type T=int)</span>;<br><span class="hljs-keyword">local</span> T stack[<span class="hljs-number">100</span>];<br><span class="hljs-keyword">local</span> <span class="hljs-keyword">int</span> top;<br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> push(T t);<br>stack[top++]=t;<br><span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">function</span> T pop();<br>pop=stack[top--];<br><span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br></code></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>Stack<span class="hljs-variable">#(real)</span> s;<br>s<span class="hljs-variable">.push</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br><span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;%f&quot;</span>,s<span class="hljs-variable">.pop</span>());<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><ol><li>使用blueprint模式和callback都可以生成不同的transaction，并且不需要改变tb代码。</li><li>记分板、覆盖率可以通过回调来收集transaction信息。</li><li><strong>callback是一种思想——向验证环境中注入代码。至于实现什么功能，由你向其中注入的代码决定。</strong></li></ol>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV——线程及线程间的通信（一）</title>
    <link href="/2019/07/23/Verification/SystemVerilog/SV%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2019/07/23/Verification/SystemVerilog/SV%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>​    实际硬件中，计算是并发进行的，在Verilog中通过initial、always、连续赋值来模拟，在测试平台中为了模拟、检验Verilog中的这些语句块，tb使用许多并发的线程。</p><h3 id="1-线程的定义和使用"><a href="#1-线程的定义和使用" class="headerlink" title="1. 线程的定义和使用"></a>1. 线程的定义和使用</h3><h4 id="1-1-定义线程"><a href="#1-1-定义线程" class="headerlink" title="1.1 定义线程"></a>1.1 定义线程</h4><p>initial 、always、assign都是进程，初次之外还有：</p><ol><li><p>fork    join</p><p>其内的语句并发，fork-join块执行完才执行后面的语句。</p></li><li><p>fork    join_none</p><p>其内 的语句并发，并且不会阻塞块之后的语句，块内语句与块之后的语句是并发关系。</p></li></ol><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>语句<span class="hljs-number">1</span>；<br>    #<span class="hljs-number">10</span>；<br><span class="hljs-keyword">fork</span><br>语句<span class="hljs-number">2</span>；<br>语句<span class="hljs-number">3</span>；<br><span class="hljs-keyword">join_none</span><br>语句<span class="hljs-number">4</span>；<br>    语句<span class="hljs-number">5</span>；<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">// 执行顺序</span><br><span class="hljs-comment">// #0 语句1</span><br><span class="hljs-comment">// #10 语句2，语句3，语句4并发执行</span><br><span class="hljs-comment">// #10 语句4执行完之后才执行语句5。4执行完之后，即使2，3没执行完，也会接着执行5，因为fork块内语句与之后的语句是并行的，不会阻塞之后的语句</span><br></code></pre></td></tr></table></figure><ol start="3"><li><p>fork    join_any</p><p>与fork   Join_none类似，只是，先要执行一条块内的进程。</p></li></ol><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">fork</span><br>      #<span class="hljs-number">20</span> <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@ %0t [line1] seq 20&quot;</span>,<span class="hljs-built_in">$time</span>);<br>      #<span class="hljs-number">10</span> <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@ %0t [line2] seq 10&quot;</span>,<span class="hljs-built_in">$time</span>);<br>  <span class="hljs-keyword">join_any</span><br>    #<span class="hljs-number">15</span>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@ %0t [line3] after seq 15&quot;</span>,<span class="hljs-built_in">$time</span>);<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">//结果</span><br>@ <span class="hljs-number">10</span> [line2] seq <span class="hljs-number">10</span><br>@ <span class="hljs-number">20</span> [line1] seq <span class="hljs-number">20</span><br>@ <span class="hljs-number">25</span> [line3] after seq <span class="hljs-number">15</span> <br></code></pre></td></tr></table></figure><p>分析：先要执行fork内的语句，line1与line2的并行，先执行完line2，此时仿真时间是10ns。从现在开始也可以执行fork块之后的语句，也就是line3，line3还需要15ns才输出，而此时line1已经仿真的10ns，再需要10ns就可以输出了，所以先输出line1，然后是line3</p><h4 id="1-2-动态线程"><a href="#1-2-动态线程" class="headerlink" title="1.2 动态线程"></a>1.2 动态线程</h4><p>在类中创建线程，用上面的三个fork块。</p><p><strong>每个fork块都可以看成启动了一个线程。</strong></p><p>如果循环启动线程，需要用automatic关键字，来自动创建变量，这样为每个线程单独分配内存。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)<br><span class="hljs-keyword">fork</span><br><span class="hljs-keyword">automatic</span> <span class="hljs-keyword">int</span> k=i;<br><span class="hljs-built_in">$display</span>(k);<br><span class="hljs-keyword">join_none</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="1-3-等待所有子线程结束"><a href="#1-3-等待所有子线程结束" class="headerlink" title="1.3 等待所有子线程结束"></a>1.3 等待所有子线程结束</h4><p>在SV，所有的initial都执行完就结束仿真了，有的线程执行时间长，可能还没执行完，仿真就结束了。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>....<br>run_fork(); <span class="hljs-comment">//调用run_fork()之后，继续执行a&lt;=b，最后一条语句结束，仿真结束，此时</span><br><span class="hljs-comment">// run_fork()可能还没执行完。</span><br>a &lt;= b;<br>....<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>wait fork来等待线程都执行完。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> run();<br><span class="hljs-keyword">fork</span>:fork_all<br>        run_fork0(); <span class="hljs-comment">//线程0 ；任务内有fork</span><br>        run_fork1();<span class="hljs-comment">//任务内有fork</span><br>run_fork2();<span class="hljs-comment">//任务内有fork</span><br>...<br><span class="hljs-keyword">join_none</span><br><span class="hljs-keyword">wait</span> <span class="hljs-keyword">fork</span>; <span class="hljs-comment">// 等待fork_all中的所有线程都执行完</span><br><span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><h4 id="1-4-停止线程-disable"><a href="#1-4-停止线程-disable" class="headerlink" title="1.4  停止线程  disable"></a>1.4  停止线程  disable</h4><ol><li><p>停止单个线程</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">fork</span>:timeout_fork  <span class="hljs-comment">//fork有标识符</span><br>run_fork0();<span class="hljs-comment">//任务内有fork</span><br>run_fork1();<span class="hljs-comment">//任务内有fork</span><br><span class="hljs-keyword">join_none</span><br>#<span class="hljs-number">100</span>;<br><span class="hljs-keyword">disable</span> timeout_fork; <span class="hljs-comment">// disable+标识符</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></li><li><p>停止多个线程</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    run_fork2();<br><span class="hljs-keyword">fork</span> <span class="hljs-comment">// timeout_fork</span><br><span class="hljs-keyword">begin</span><br>run_fork0();<span class="hljs-comment">//任务内有fork</span><br>run_fork1();<span class="hljs-comment">//任务内有fork</span><br>#<span class="hljs-number">100</span> <span class="hljs-keyword">disable</span> <span class="hljs-keyword">fork</span>;<span class="hljs-comment">// 将disable_fork进程中所有的子进程都停止，不需要标识符。</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">join</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>timeout_fork块用来限制要disable的fork的范围，上方代码中的disable对run_fork2()没影响。</p></li><li><p>禁止多次被调用的任务</p><p>如果在任务中启动了进程，当禁用这个任务的时候，会停止所有由该任务启动的进程；在其他地方也调用了该任务，那么其他的那些进程也会被disable。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">task</span> time_out(<span class="hljs-keyword">input</span> <span class="hljs-keyword">int</span> i);<br><span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)<br>#<span class="hljs-number">2</span> <span class="hljs-keyword">disable</span> time_out; <span class="hljs-comment">// 如果i等于0，那么2ns之后停止任务</span><br>....<br>endtaks<br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>time_out(<span class="hljs-number">0</span>);<br>time_out(<span class="hljs-number">1</span>);<br>time_out(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>在2ns时，停止time_out(0)任务，此时也会导致另外两个任务也disable，使它们不能执行完。</p><p><strong>所有disable任务要慎重。</strong></p></li></ol><h3 id="2-线程间通信"><a href="#2-线程间通信" class="headerlink" title="2. 线程间通信"></a>2. 线程间通信</h3><p>​    测试平台中所有的线程需要传递数据，可能多个线程同时要访问同一个数据，测试平台的代码是使得同一时间只有一个线程能访问。</p><p>​    这些数据交换和控制的同步叫做线程间的通信(IPC)。</p><h3 id="3-事件-event"><a href="#3-事件-event" class="headerlink" title="3. 事件 event"></a>3. 事件 event</h3><p>SV中对Verilog中的event做了扩展：</p><p>​    <strong>1. event可以作为参数传递给方法。</strong></p><p>​    <strong>2. 引入了triggered函数</strong></p><p>Verilog中由@，-&gt;操作符来阻塞和触发事件。如果一个线程在阻塞事件的同时，另一个线程同时触发了事件，那么可能发生竞争，如果触发先于阻塞，那么错过触发。</p><p>​    <strong>SV中引入了triggered函数，它可以查询事件是否被触发，包括当前时间片触发（time slot）。触发了返回1.这样可以用wait来等待这个函数的结果，而不必用@来阻塞。</strong></p><p>​    <strong>@e1是边沿敏感的阻塞语句；wait(e1.triggered())是电平敏感的。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">event</span> e1,e2;<br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>:i1<br>@e1; <span class="hljs-comment">// 先执行i1块，发现阻塞</span><br><span class="hljs-built_in">$display</span>(....);<br>-&gt;e2; <span class="hljs-comment">//执行完代码后触发e2，开始执行i2</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>:i2<br>#<span class="hljs-number">1</span>; <span class="hljs-comment">// 1ns后触发e1，并且阻塞在e2</span><br>-&gt;e1;<br>    @e2;<br><span class="hljs-built_in">$display</span>(...);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">event</span> e1,e2;<br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">wait</span>(e1<span class="hljs-variable">.triggered</span>());<br><span class="hljs-built_in">$display</span>(....);<br>-&gt;e2;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>#<span class="hljs-number">1</span>;<br>-&gt;e1;<br>    <span class="hljs-keyword">wait</span>(e2<span class="hljs-variable">.triggered</span>());<br><span class="hljs-built_in">$display</span>(...);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="3-1-在循环中使用事件"><a href="#3-1-在循环中使用事件" class="headerlink" title="3.1 在循环中使用事件"></a>3.1 在循环中使用事件</h4><p><strong>@e1是边沿敏感的阻塞语句；wait(e1.triggered())是电平敏感的。</strong></p><p>在循环中使用事件，如果循环是0延时的，那么会有点问题：</p><ol><li><p>电平敏感的阻塞</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">wait</span>(e1<span class="hljs-variable">.triggered</span>());<br><span class="hljs-built_in">$display</span>(...);<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>wait会持续地触发，仿真时间不会向前推进。因为wait触发，执行了一个循环之后，还在当前时间片，e1.triggered()还是返回1，wait继续触发。</p><p>改进：在循环中加入延迟。</p></li><li><p>边沿敏感的阻塞</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span><br>@e1;<br><span class="hljs-built_in">$display</span>(...);<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>边沿的触发，即使0延迟，只触发一次。</p></li></ol><h4 id="3-2-事件作为参数"><a href="#3-2-事件作为参数" class="headerlink" title="3.2 事件作为参数"></a>3.2 事件作为参数</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> Generator;<br><span class="hljs-keyword">event</span> e;<br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">event</span> e1) <span class="hljs-comment">//传入事件</span><br><span class="hljs-keyword">this</span><span class="hljs-variable">.e</span> = e1;<br><span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">task</span> run()<br>...<br>-&gt;e; <span class="hljs-comment">//触发</span><br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br><span class="hljs-keyword">class</span> Driver;<br><span class="hljs-keyword">event</span> e;<br><span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">event</span> e2);<span class="hljs-comment">//传入事件</span><br><span class="hljs-keyword">this</span><span class="hljs-variable">.e</span>=e2;<br><span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">task</span> run();<br>@e;  <span class="hljs-comment">//等待触发</span><br><span class="hljs-comment">// wait(e.triggered());</span><br>...<br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br><span class="hljs-keyword">program</span> test;<br>Generator gen;<br>Driver drv;<br><span class="hljs-keyword">event</span> e;<br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>gen=<span class="hljs-keyword">new</span>(e);<br>drv=<span class="hljs-keyword">new</span>(e);<br><span class="hljs-keyword">fork</span><br>gen<span class="hljs-variable">.run</span>();<br>drv<span class="hljs-variable">.run</span>();<br><span class="hljs-keyword">join</span><br><span class="hljs-keyword">end</span><br>endpragram<br></code></pre></td></tr></table></figure><h4 id="3-3-等待多个事件"><a href="#3-3-等待多个事件" class="headerlink" title="3.3 等待多个事件"></a>3.3 等待多个事件</h4><p>如果有多个发生器，那么需要等待所有的发生器的线程都执行完。</p><p>方法一、用wait fork</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">event</span> done[N];<span class="hljs-comment">// N是发生器数目</span><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">foreach</span> (gen[i])<span class="hljs-keyword">begin</span><br>gen[i]=<span class="hljs-keyword">new</span>(done[i]);<br>gen[i]<span class="hljs-variable">.run</span>();<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">foreach</span>(gen[i]) <span class="hljs-keyword">fork</span><br><span class="hljs-keyword">automatic</span> <span class="hljs-keyword">int</span> k=i;<br><span class="hljs-keyword">wait</span>(done[k]<span class="hljs-variable">.triggered</span>());<br><span class="hljs-keyword">join_none</span><br>    <span class="hljs-keyword">wait</span> <span class="hljs-keyword">fork</span>; <span class="hljs-comment">//等待所有的fork执行完</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>方法二、用计数器</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">event</span> done[N];<span class="hljs-comment">// N是发生器数目</span><br><span class="hljs-keyword">int</span> cnt;<br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">foreach</span> (gen[i])<span class="hljs-keyword">begin</span><br>gen[i]=<span class="hljs-keyword">new</span>(done[i]);<br>gen[i]<span class="hljs-variable">.run</span>();<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">foreach</span>(gen[i]) <span class="hljs-keyword">fork</span><br><span class="hljs-keyword">automatic</span> <span class="hljs-keyword">int</span> k=i;<br>        <span class="hljs-keyword">begin</span> <span class="hljs-comment">//begin块</span><br>            <span class="hljs-keyword">wait</span>(done[k]<span class="hljs-variable">.triggered</span>());<br>            cnt++; <span class="hljs-comment">//触发一个，计数加一。</span><br>        <span class="hljs-keyword">end</span><br><span class="hljs-keyword">join_none</span><br>    <span class="hljs-keyword">wait</span>(cnt==N); <span class="hljs-comment">//等待计数到N。说明所有的fork执行完毕，所有的事件都触发</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>方法三、摆脱事件，只用静态变量来计数</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> Generator ;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">task</span> run();<br>        cnt++; <span class="hljs-comment">// 调用run计数加一</span><br>        <span class="hljs-keyword">fork</span><br>            <span class="hljs-keyword">begin</span><br>               ....<br>                cnt--; <span class="hljs-comment">//代码执行完毕，cnt减一。</span><br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">join_none</span><br>    <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">foreach</span> (gen[i])  gen[i]=<span class="hljs-keyword">new</span>();<br>    <span class="hljs-keyword">foreach</span> (gen[i])  gen[i]<span class="hljs-variable">.run</span>();<br>    <span class="hljs-keyword">wait</span>(Generator::cnt == <span class="hljs-number">0</span>); <span class="hljs-comment">//gen启动时都+1，结束时都-1，最终结果0.</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV——线程及线程间的通信（二）</title>
    <link href="/2019/07/23/Verification/SystemVerilog/SV%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2019/07/23/Verification/SystemVerilog/SV%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="1-旗语-semaphore"><a href="#1-旗语-semaphore" class="headerlink" title="1. 旗语 semaphore"></a>1. 旗语 semaphore</h3><p>​    如果把进程执行看成“开车”这个行为，开车需要钥匙，旗语就类似于“钥匙”。一个线程执行要先申请钥匙（旗语），如果只有一个钥匙（旗语）并且被其他线程申请了，那么这个线程阻塞。当那个线程执行完了，返回钥匙（旗语），被阻塞的线程可以再申请钥匙（旗语）。</p><p>​    <strong>旗语可以用在多个进程共享资源的时候。</strong></p><ol><li>new方法创建一个或多个旗语</li><li>get获取一个或多个旗语，获取失败阻塞</li><li>put返回一个或多个旗语</li><li>try_get()试图获取旗语，但不阻塞。返回1表示有足够旗语，返回0表示旗语不够。</li></ol><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">program</span> <span class="hljs-keyword">automatic</span> test;<br>semaphore sem; <span class="hljs-comment">//创建一个旗语</span><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>sem = <span class="hljs-keyword">new</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//分配一把钥匙</span><br>run();<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">task</span> run();<br>sem<span class="hljs-variable">.get</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//申请一把钥匙；此时如果其他进程申请这个旗语的钥匙，则阻塞。</span><br>....       <span class="hljs-comment">// 使用资源</span><br>sem<span class="hljs-variable">.put</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//执行结束，返回钥匙</span><br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endprogram</span><br></code></pre></td></tr></table></figure><h3 id="2-信箱-mailbox"><a href="#2-信箱-mailbox" class="headerlink" title="2. 信箱 mailbox"></a>2. 信箱 mailbox</h3><p>信箱用来再多个线程之间传递事务，比如生成器和驱动器之间。</p><p><strong>信箱类似一个FIFO，先入先出。</strong></p><p>如果向一个定容的满了的信箱里添加对象，会阻塞；向空的信箱取对象也会阻塞。</p><p><strong>信箱是一种对象，需要实例化。</strong></p><p>get、put、peak（取对象数据的拷贝，但不删除它）。</p><p><strong>信箱中最好只放一种类型的数据。（虽然放不同的数据语法不会错）。</strong></p><p><strong>信箱其实是一个参数类，可以指定信箱中放数据的类型。</strong></p><p><strong>信箱中存的是句柄（指针），如果只new了一个对象，只是将它随机了许多次，那么存入mailbox的对象是一个。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>mailbox mlb<span class="hljs-variable">#(Transaction)</span>; <span class="hljs-comment">//指定类型</span><br>Transaction tr,tmp;<br><span class="hljs-keyword">repeat</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>tr = <span class="hljs-keyword">new</span>(); <span class="hljs-comment">// 在循环内创建对象</span><br><span class="hljs-keyword">assert</span>(tr<span class="hljs-variable">.randomize</span>());<br>mlb<span class="hljs-variable">.put</span>(tr); <span class="hljs-comment">//存入mlb</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">repeat</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>mlb<span class="hljs-variable">.get</span>(tmp); <span class="hljs-comment">//从mlb取</span><br>tmp<span class="hljs-variable">.show</span>();<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="2-1-使用定容信箱同步"><a href="#2-1-使用定容信箱同步" class="headerlink" title="2.1 使用定容信箱同步"></a>2.1 使用定容信箱同步</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> Transaction;<br>  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] data;<br>  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] addr;<br><span class="hljs-keyword">endclass</span><br><span class="hljs-keyword">class</span> Generator;<br>  mailbox mlb;<br>  Transaction tr;<br>  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(mailbox m);<br>    <span class="hljs-keyword">this</span><span class="hljs-variable">.mlb</span>= m;<br>  <span class="hljs-keyword">endfunction</span><br>  <span class="hljs-keyword">task</span> run();<br>    <span class="hljs-keyword">repeat</span>(<span class="hljs-number">5</span>) <span class="hljs-keyword">begin</span>   <br>      tr=<span class="hljs-keyword">new</span>();<br>      <span class="hljs-keyword">assert</span>(tr<span class="hljs-variable">.randomize</span>());<br>      mlb<span class="hljs-variable">.put</span>(tr);<br>      <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@ %0t [gen] put a tr&quot;</span>,<span class="hljs-built_in">$time</span>);<br>    <span class="hljs-keyword">end</span> <br>  <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">class</span> Driver;<br>  mailbox mlb;<br>  Transaction tr;<br>  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(mailbox m);<br>    <span class="hljs-keyword">this</span><span class="hljs-variable">.mlb</span>= m;<br>  <span class="hljs-keyword">endfunction</span><br>  <span class="hljs-keyword">task</span> run();<br>  <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span><br>      #<span class="hljs-number">10</span>; <span class="hljs-comment">//每延迟10ns，driver取一个数据，也可以同步到时钟沿@(posedge clk);</span><br>    mlb<span class="hljs-variable">.get</span>(tr);<br>    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@ %0t [drv] get a tr&quot;</span>,<span class="hljs-built_in">$time</span>);<br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">program</span> <span class="hljs-keyword">automatic</span> tb;<br>Generator gen;<br>Driver drv;<br>mailbox mlb;<br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    mlb=<span class="hljs-keyword">new</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//定容信箱，容量1，如果参数为空，则mailbox不限容量</span><br>  gen=<span class="hljs-keyword">new</span>(mlb);<br>  drv=<span class="hljs-keyword">new</span>(mlb);<br>  <span class="hljs-keyword">fork</span> <span class="hljs-comment">// 并发执行</span><br>    gen<span class="hljs-variable">.run</span>();<br>    drv<span class="hljs-variable">.run</span>();<br>  <span class="hljs-keyword">join</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endprogram</span> <br><span class="hljs-comment">// output </span><br>@ <span class="hljs-number">0</span> [gen] put a tr<br>@ <span class="hljs-number">10</span> [drv] get a tr<br>@ <span class="hljs-number">10</span> [gen] put a tr<br>@ <span class="hljs-number">20</span> [drv] get a tr<br>@ <span class="hljs-number">20</span> [gen] put a tr<br>@ <span class="hljs-number">30</span> [drv] get a tr<br>@ <span class="hljs-number">30</span> [gen] put a tr<br>@ <span class="hljs-number">40</span> [drv] get a tr<br>@ <span class="hljs-number">40</span> [gen] put a tr<br>@ <span class="hljs-number">50</span> [drv] get a tr<br></code></pre></td></tr></table></figure><p>从输出可以看到，put一个tr，阻塞put操作，然后get一个tr，再put如此循环。</p><h4 id="2-2-使用信箱和事件来同步"><a href="#2-2-使用信箱和事件来同步" class="headerlink" title="2.2 使用信箱和事件来同步"></a>2.2 使用信箱和事件来同步</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">program</span> <span class="hljs-keyword">automatic</span> tb;<br><span class="hljs-keyword">event</span> handshake; <span class="hljs-comment">// 事件</span><br>mailbox mlb;<br><span class="hljs-keyword">class</span> Generator;<br>  ...<br>  <span class="hljs-keyword">task</span> run();<br>    <span class="hljs-keyword">repeat</span>(<span class="hljs-number">5</span>) <span class="hljs-keyword">begin</span>   <br>      ...<br>      mlb<span class="hljs-variable">.put</span>(tr);<br>      <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@ %0t [gen] put a tr&quot;</span>,<span class="hljs-built_in">$time</span>);<br>      @handshake;  <span class="hljs-comment">//生成完一个tr后阻塞。</span><br>    <span class="hljs-keyword">end</span> <br>  <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">class</span> Driver;<br>  ...<br>  <span class="hljs-keyword">task</span> run();<br>  <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span><br>#<span class="hljs-number">10</span>;<br>    mlb<span class="hljs-variable">.get</span>(tr);<br>    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@ %0t [drv] get a tr&quot;</span>,<span class="hljs-built_in">$time</span>);<br>  -&gt;handshake; <span class="hljs-comment">//获取完一个tr后触发事件</span><br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">endtask</span><br><br><span class="hljs-keyword">endclass</span><br><br>Generator gen;<br>Driver drv;<br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    mlb=<span class="hljs-keyword">new</span>(); <span class="hljs-comment">//无限容量</span><br>  gen=<span class="hljs-keyword">new</span>(mlb);<br>  drv=<span class="hljs-keyword">new</span>(mlb);<br>  <span class="hljs-keyword">fork</span> ... <span class="hljs-keyword">join_none</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endprogram</span> <br>@ <span class="hljs-number">0</span> [gen] put a tr<br>@ <span class="hljs-number">10</span> [drv] get a tr<br>@ <span class="hljs-number">10</span> [gen] put a tr<br>@ <span class="hljs-number">20</span> [drv] get a tr<br>@ <span class="hljs-number">20</span> [gen] put a tr<br>@ <span class="hljs-number">30</span> [drv] get a tr<br>@ <span class="hljs-number">30</span> [gen] put a tr<br>@ <span class="hljs-number">40</span> [drv] get a tr<br>@ <span class="hljs-number">40</span> [gen] put a tr<br>@ <span class="hljs-number">50</span> [drv] get a tr<br></code></pre></td></tr></table></figure><h4 id="2-3-使用两个信箱同步"><a href="#2-3-使用两个信箱同步" class="headerlink" title="2.3 使用两个信箱同步"></a>2.3 使用两个信箱同步</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">program</span> <span class="hljs-keyword">automatic</span> tb;<br>mailbox<span class="hljs-variable">#(Transaction)</span> mlb;<br>    mailbox<span class="hljs-variable">#(int)</span> m;  <span class="hljs-comment">// 定义两个信箱</span><br><span class="hljs-keyword">class</span> Generator;<br>  Transaction tr;<br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-keyword">task</span> run();<br>    <span class="hljs-keyword">repeat</span>(<span class="hljs-number">5</span>) <span class="hljs-keyword">begin</span><br>      tr=<span class="hljs-keyword">new</span>();<br>      <span class="hljs-keyword">assert</span>(tr<span class="hljs-variable">.randomize</span>());<br>      mlb<span class="hljs-variable">.put</span>(tr);<br>      <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@ %0t [gen] put a tr&quot;</span>,<span class="hljs-built_in">$time</span>);<br>        m<span class="hljs-variable">.get</span>(i); <span class="hljs-comment">//m为空，阻塞</span><br>    <span class="hljs-keyword">end</span> <br>  <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br><br><span class="hljs-keyword">class</span> Driver;<br>  Transaction tr;<br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-keyword">task</span> run();<br>  <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span><br>#<span class="hljs-number">10</span>;<br>    mlb<span class="hljs-variable">.get</span>(tr);<br>    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@ %0t [drv] get a tr&quot;</span>,<span class="hljs-built_in">$time</span>);<br>      m<span class="hljs-variable">.put</span>(i); <span class="hljs-comment">// m不为空，触发了Generator中的语句。</span><br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br><br>Generator gen;<br>Driver drv;<br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>  mlb=<span class="hljs-keyword">new</span>();<br>    m=<span class="hljs-keyword">new</span>(); <span class="hljs-comment">//新建信箱</span><br>  gen=<span class="hljs-keyword">new</span>();<br>  drv=<span class="hljs-keyword">new</span>();<br>  <span class="hljs-keyword">fork</span><br>    gen<span class="hljs-variable">.run</span>();<br>    drv<span class="hljs-variable">.run</span>();<br>  <span class="hljs-keyword">join</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endprogram</span> <br>@ <span class="hljs-number">0</span> [gen] put a tr<br>@ <span class="hljs-number">10</span> [drv] get a tr<br>@ <span class="hljs-number">10</span> [gen] put a tr<br>@ <span class="hljs-number">20</span> [drv] get a tr<br>@ <span class="hljs-number">20</span> [gen] put a tr<br>@ <span class="hljs-number">30</span> [drv] get a tr<br>@ <span class="hljs-number">30</span> [gen] put a tr<br>@ <span class="hljs-number">40</span> [drv] get a tr<br>@ <span class="hljs-number">40</span> [gen] put a tr<br>@ <span class="hljs-number">50</span> [drv] get a tr<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV——SV与Verilog的不同</title>
    <link href="/2019/07/22/Verification/SystemVerilog/SV%E2%80%94%E2%80%94SV%E4%B8%8EVerilog%E7%9A%84%E4%B8%8D%E5%90%8C/"/>
    <url>/2019/07/22/Verification/SystemVerilog/SV%E2%80%94%E2%80%94SV%E4%B8%8EVerilog%E7%9A%84%E4%B8%8D%E5%90%8C/</url>
    
    <content type="html"><![CDATA[<p>介绍SV语法中与Verilog不同的地方。</p><p>参考《Systemverilog验证——测试平台编写指南》</p><h3 id="1-过程语句"><a href="#1-过程语句" class="headerlink" title="1. 过程语句"></a>1. 过程语句</h3><p>相比于Verilog，SV从C中继承了一些方便的语法。</p><ol><li><p>在for循环中可以定义变量，它的作用范围仅限于for循环。</p></li><li><p>initial 、always块中也可以定义变量。</p></li><li><p>可以用++、–自增运算符。</p></li><li><p>在begin、fork、module、function等标识符后放置符号，并在结束语句中也放置相同符号，便于首位匹配。</p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">begin</span>:test  <span class="hljs-comment">//test就是标识符</span><br>......<br><span class="hljs-keyword">end</span>:test<br></code></pre></td></tr></table></figure></li><li><p>在循环中可以用continue和break。</p></li></ol><h3 id="2-任务和函数"><a href="#2-任务和函数" class="headerlink" title="2. 任务和函数"></a>2. 任务和函数</h3><ol><li><p>在SV中的fork—join_none线程中，函数可以调用任务，只有这时可以。</p></li><li><p>void’ () 调用函数忽略它的返回值。 void’(fun);</p></li><li><p>在task、function定义中可以去掉begin—end</p></li><li><p>参数缺省的类型和方向是logic和input。缺省情况下，参数的类型、方向跟前一个参数一样。</p></li><li><p>可以传ref类型参数，引用，跟C++中一样概念，可以用const修饰。<strong>ref只能用在自动存储的子程序中，也就是有automatic修饰。</strong></p></li><li><p>可以为参数指定默认值（缺省值）。</p></li><li><p>返回数组类型</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> fixed_array[<span class="hljs-number">5</span>] ; <span class="hljs-comment">//5个int的数组类型，作为返回类型</span><br>fixed_array f5;<br><span class="hljs-keyword">function</span> fixed_array init(<span class="hljs-keyword">int</span> data) ;<br><span class="hljs-keyword">foreach</span>(init[i])<br>init[i]++;<br><span class="hljs-keyword">endfunction</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="3-局部数据存储-automatic"><a href="#3-局部数据存储-automatic" class="headerlink" title="3. 局部数据存储 automatic"></a>3. 局部数据存储 automatic</h3><p>动态存储方式是指在程序运行期间根据需要进行动态的分配存储空间的方式，包括堆区、栈区。</p><p>静态存储方式是指在程序编译期间分配固定的存储空间的方式。</p><p>​    <strong>SV中模块、program中的子程序（任务、函数）里的局部变量（没有明确指出是静态的）采用静态存储区，在不同线程中会串用这些变量</strong>。如果要自动存储，必须要automatic关键字修饰。如果用automatic修饰了module或者子程序，那么其中的所有局部变量都是自动存储（动态存储）。</p><p>​    多个线程调用同一个任务，定义了automatic之后，不同线程之间动态分配内存。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">program</span> <span class="hljs-keyword">automatic</span> test;<br><span class="hljs-keyword">task</span> wait_mem(<span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] addr,expect_data);<br><span class="hljs-keyword">while</span>(bus<span class="hljs-variable">.addr</span>!==addr)<br>@(bus<span class="hljs-variable">.addr</span>);<br>......<br><span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endprogram</span><br></code></pre></td></tr></table></figure><p>​    如上面程序，如果没有automatic关键字，当任务等待事件而卡住的时候，如果这时又调用了这个任务，那么新的addr\data会覆盖之前调用的任务的参数。</p><h3 id="4-时间、精度"><a href="#4-时间、精度" class="headerlink" title="4. 时间、精度"></a>4. 时间、精度</h3><p>可以在每个模块中指明时间参数。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">module</span> test;<br><span class="hljs-keyword">timeunit</span> <span class="hljs-number">1</span>ns; <span class="hljs-comment">// 时间单位1ns</span><br><span class="hljs-keyword">timeprecision</span> <span class="hljs-number">1</span>ps; <span class="hljs-comment">//精度1ps</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM UG中的一些细节点</title>
    <link href="/2019/07/22/Verification/UVM/UG%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82%E7%82%B9/"/>
    <url>/2019/07/22/Verification/UVM/UG%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>c</p><p>UG 1.1</p><h3 id="Chapter3"><a href="#Chapter3" class="headerlink" title="Chapter3"></a>Chapter3</h3><p>P42</p><p>在SV中不允许在class中使用concurrent assertion，但可以在interface中使用concurrent assertion进行协议检查。</p><p>P46</p><p>$format(inst_name,”master[%0d]”,i); &#x2F;&#x2F;将字符串内容存在inst_name变量中。注意和$formatf区别。</p>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>UVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
      <tag>UVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM1.2与UVM1.1的不同</title>
    <link href="/2019/07/22/Verification/UVM/UVM1.2%E4%B8%8EUVM1.1%E7%9A%84%E4%B8%8D%E5%90%8C/"/>
    <url>/2019/07/22/Verification/UVM/UVM1.2%E4%B8%8EUVM1.1%E7%9A%84%E4%B8%8D%E5%90%8C/</url>
    
    <content type="html"><![CDATA[<p><strong>UVM-1.2在2014年5月发布，相比于之前的UVM-1.1改变了一些东西，这里分两部分，逐步总结UVM-1.2和UVM-1.1的不同。</strong></p><h3 id="1-UVM-1-2增加的内容"><a href="#1-UVM-1-2增加的内容" class="headerlink" title="1. UVM-1.2增加的内容"></a>1. UVM-1.2增加的内容</h3><h3 id="2-UVM-1-2取消的内容"><a href="#2-UVM-1-2取消的内容" class="headerlink" title="2. UVM-1.2取消的内容"></a>2. UVM-1.2取消的内容</h3><h4 id="2-1-取消在sequence中控制objection"><a href="#2-1-取消在sequence中控制objection" class="headerlink" title="2.1 取消在sequence中控制objection"></a>2.1 取消在sequence中控制objection</h4><p>在1.1中可以通过raise_objection   drop_objection 来控制tb的执行，而在1.2中取消了这种写法，改成了。</p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog">set_automatic_phase_objection(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p><strong>在sequence的new函数中添加上面这一句就行了，自动控制sequence开始和结束。</strong></p><p>原来在1.1中在sequence中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">if</span>(starting_phase!=<span class="hljs-literal">null</span>)<br>starting_phase.raise_objection(<span class="hljs-keyword">this</span>);<br>....<br><span class="hljs-keyword">if</span>(starting_phase!=<span class="hljs-literal">null</span>)<br>starting_phase.drop_objection(<span class="hljs-keyword">this</span>);<br></code></pre></td></tr></table></figure><p>其中starting_phase是sequence中的一个变量，uvm_phase类型。sequencer自动将phase传给req变量的startiing_phase。（req指向sequencer发送的sequence）。</p><p>在1.2中用户不能访问starting_phase这个变量，不能传递phase，所以这个方法不行了。</p>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>UVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
      <tag>UVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVM——控制打印信息</title>
    <link href="/2019/07/22/Verification/UVM/UVM%E2%80%94%E2%80%94%E6%8E%A7%E5%88%B6%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF/"/>
    <url>/2019/07/22/Verification/UVM/UVM%E2%80%94%E2%80%94%E6%8E%A7%E5%88%B6%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<p>通过控制component打印信息的行为，提高日志的可读性。</p><p><strong>uvm_component 直接继承自uvm_report_object，所以component继承了一些设置report的函数。</strong></p><p>打印信息的宏有：</p><ol><li>&#96;uvm_info(id,mess,verbosity).</li><li>&#96;uvm_warning(id,mess)</li><li>&#96;uvm_error(id,mess)</li><li>&#96;uvm_fatal(id,mess)</li></ol><h3 id="1-设置信息冗余度阈值-verbosity-level"><a href="#1-设置信息冗余度阈值-verbosity-level" class="headerlink" title="1. 设置信息冗余度阈值 verbosity level"></a>1. 设置信息冗余度阈值 verbosity level</h3><p><strong>冗余度等于低于阈值的信息可以打印出来，否则不会显示。</strong></p><table><thead><tr><th>uvm_verbosity</th><th></th></tr></thead><tbody><tr><td>UVM_NONE</td><td>Report is always printed.  Verbosity level setting can not disable it.</td></tr><tr><td>UVM_LOW</td><td>Report is issued if configured verbosity is set to UVM_LOW or above.</td></tr><tr><td>UVM_MEDIUM</td><td>Report is issued if configured verbosity is set to UVM_MEDIUM or above.</td></tr><tr><td>UVM_HIGH</td><td>Report is issued if configured verbosity is set to UVM_HIGH or above.</td></tr><tr><td>UVM_FULL</td><td>Report is issued if configured verbosity is set to UVM_FULL or above.</td></tr></tbody></table><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog">tyypedef <span class="hljs-keyword">enum</span>&#123;<br>UVM_NONE=<span class="hljs-number">0</span>,<br>UVM_LOW=<span class="hljs-number">100</span>,<br>UVM_MEDIUM=<span class="hljs-number">200</span>,<br>UVM_HIGH=<span class="hljs-number">300</span>,<br>UVM_FULL = <span class="hljs-number">400</span>,<br>UVM_DEBUG=<span class="hljs-number">500</span><br>&#125; uvm_verbosity<br></code></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// get_verbosity_level()</span><br><span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;env&#x27;s verbosity is %0d&quot;</span>,env<span class="hljs-variable">.get_verbosity_level</span>());<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// set_report_verbosity_level(UVM_LOW)</span><br><span class="hljs-comment">// 设置某个component的verbosity level</span><br>env.set_report_verbosity_level(UVM_HIGH);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// set_report_verbosity_level_hier(UVM_LOW)</span><br><span class="hljs-comment">// 递归设置</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// set_report_id_verbosity(&quot;env&quot;,UVM_LOW)</span><br><span class="hljs-comment">//设置只打印某个id的报告，不是这个id的不打印</span><br><span class="hljs-comment">// 比如在env中有如下代码：</span><br><span class="hljs-comment">// `uvm_info(&quot;ID1&quot;,&quot;THIS IS ID1 UVM_LOW&quot;,UVM_LOW)</span><br><span class="hljs-comment">// `uvm_info(&quot;ID1&quot;,&quot;THIS IS ID1 UVM_HIGH&quot;,UVM_HIGH)</span><br><span class="hljs-comment">// `uvm_info(&quot;ID2&quot;,&quot;THIS IS ID2&quot;,UVM_LOW)</span><br><span class="hljs-comment">// 设置：</span><br>env.set_report_id_verbosity(<span class="hljs-string">&quot;env&quot;</span>,UVM_LOW);<br><span class="hljs-comment">// 打印结果：</span><br><span class="hljs-comment">// THIS IS ID1 UVM_LOW</span><br><span class="hljs-comment">// 这个方法既对id进行过滤，也过滤verbosity level</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// set_report_id_verbosity_hier(&quot;env&quot;,UVM_LOW)</span><br></code></pre></td></tr></table></figure><p><strong>也可以在仿真的时候添加仿真选项：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">./simv +UVM_VERBOSITY=UVM_HIGH<br><span class="hljs-comment">// 为整个验证平台设置verbosity level</span><br></code></pre></td></tr></table></figure><h3 id="2-重载打印信息严重性-severity"><a href="#2-重载打印信息严重性-severity" class="headerlink" title="2. 重载打印信息严重性 severity"></a>2. 重载打印信息严重性 severity</h3><p>uvm有四种信息严重性：</p><ol><li>UVM_INFO</li><li>UVM_WARNING</li><li>UVM_ERROR</li><li>UVM_FATAL</li></ol><p>这四种可以相互重载</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// set_report_severity_override(UVM_WARNING,UVM_ERROR)</span><br>env.set_report_severity_override(UVM_WARNING,UVM_ERROR);<br><span class="hljs-comment">// 将env的UVM_WARNING设置成UVM_ERROR</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// set_report_severity_id_override(UVM_WARNING,UVM_ERROR)</span><br><span class="hljs-comment">// 针对component的某个id起作用</span><br></code></pre></td></tr></table></figure><p><strong>也可以在仿真时候设置，设置选项如下：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">+uvm_set_severity=<span class="hljs-tag">&lt;<span class="hljs-name">comp</span>&gt;</span>,<span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>,<span class="hljs-tag">&lt;<span class="hljs-name">current_severity</span>&gt;</span>,<span class="hljs-tag">&lt;<span class="hljs-name">new_severity</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./simv</span> +uvm_<span class="hljs-keyword">set</span>_severity=<span class="hljs-string">&quot;uvm_base_top.env,env,UVM_WARNING,UVM_ERROR&quot;</span><br></code></pre></td></tr></table></figure><h4 id="2-1-观察打印信息"><a href="#2-1-观察打印信息" class="headerlink" title="2.1 观察打印信息"></a>2.1 观察打印信息</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">UVM_INFO my_env<span class="hljs-selector-class">.sv</span>(<span class="hljs-number">17</span>) @ <span class="hljs-number">0</span>: uvm_test_top<span class="hljs-selector-class">.env</span> <span class="hljs-selector-attr">[my_env]</span> my_env is created !!<br></code></pre></td></tr></table></figure><p>上面是&#96;uvm_info宏输出的信息：</p><ol><li>UVM_INFO：                信息severity</li><li>my_env.sv(17）：        code中的位置</li><li>@ 0：                             仿真事件</li><li>uvm_test_top.env ：   层次路径</li><li>[my_env]：                    设置的id</li><li>my_env is created !!：要打印的信息</li></ol><h3 id="3-错误信息到一定数量结束仿真"><a href="#3-错误信息到一定数量结束仿真" class="headerlink" title="3. 错误信息到一定数量结束仿真"></a>3. 错误信息到一定数量结束仿真</h3><p>当UVM_FATAL发生时，立即结束仿真；但UVM_ERROR则需要到了一定数量才会结束仿真。</p><p>可以设置达到几个error就结束仿真。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// set_report_max_quit(5) </span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> base_test::build_phase(uvm_phase phase);<br>   <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);<br>   env  =  my_env::type_id::create(<span class="hljs-string">&quot;env&quot;</span>, <span class="hljs-keyword">this</span>); <br>    set_report_max_quit_count(<span class="hljs-number">5</span>); <span class="hljs-comment">//5个ERROR结束仿真 $finish</span><br><span class="hljs-keyword">endfunction</span><br></code></pre></td></tr></table></figure><p><strong>也可以在仿真选项中设置：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">./simv +UVM_MAX_QUIT_COUNT=<span class="hljs-number">5</span>,NO<br><span class="hljs-comment">// NO表示这个值不可以被后面的设置语句覆盖</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//get_max_quit_count()</span><br><span class="hljs-comment">// 返回int值，表示当前的最大推出值</span><br><span class="hljs-comment">// 如果返回0，表示无论多少个error都不会结束仿真</span><br></code></pre></td></tr></table></figure><h3 id="4-设置计数目标"><a href="#4-设置计数目标" class="headerlink" title="4. 设置计数目标"></a>4. 设置计数目标</h3><p>上一节中UVM_ERROR到达一定值后结束仿真，也可以把UVM_WARNING也加入计数目标，error和warning的达到最大值就退出仿真。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// function void set_report_severity_action (uvm_severity severity,uvm_action action)</span><br>env.set_report_severity_action(UVM_WARNING,UVM_DISPLAY|UVM_COUNT);<br><span class="hljs-comment">// 将UVM_WARNING也加入到计数中。</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// function void set_report_severity_action_hier (uvm_severity severity,uvm_action action)</span><br></code></pre></td></tr></table></figure><p>也可以针对某个ID计数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//function void set_report_id_action (string id,uvm_action action)</span><br><span class="hljs-comment">//function void set_report_id_action_hier (string id,uvm_action action)</span><br></code></pre></td></tr></table></figure><p>也可把id和severity联合起来进行设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// function void set_report_severity_id_action (uvm_severity severity,string id,uvm_action action)</span><br><span class="hljs-comment">// function void set_report_severity_id_action_hier (uvm_severity severity,string id,uvm_action action)</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>uvm_action</th><th>description</th></tr></thead><tbody><tr><td>UVM_NO_ACTION</td><td>No action is taken</td></tr><tr><td>UVM_DISPLAY</td><td>Sends the report to the standard output</td></tr><tr><td><strong>UVM_LOG</strong></td><td><strong>Sends the report to the file(s) for this (severity,id) pair</strong></td></tr><tr><td>UVM_COUNT</td><td>Counts the number of reports with the COUNT attribute.  When this value reaches max_quit_count, the simulation terminates</td></tr><tr><td>UVM_EXIT</td><td>Terminates the simulation immediately.</td></tr><tr><td>UVM_CALL_HOOK</td><td>Callback the report hook methods</td></tr><tr><td>UVM_STOP</td><td>Causes <em>$stop</em> to be executed, putting the simulation into interactive mode.</td></tr></tbody></table><h3 id="5-UVM断点"><a href="#5-UVM断点" class="headerlink" title="5. UVM断点"></a>5. UVM断点</h3><p>执行到断点，停止仿真。</p><p>设置出现UVM_WARNING的时候停止仿真：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">env.set_report_severity_action(UVM_WARNING,UVM_DISPLAY|UVM_STOP);<br></code></pre></td></tr></table></figure><h3 id="6-将输出信息写入到文件"><a href="#6-将输出信息写入到文件" class="headerlink" title="6. 将输出信息写入到文件"></a>6. 将输出信息写入到文件</h3><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-keyword">function</span> void set_report_severity_file (uvm_severity <span class="hljs-keyword">severity</span>,UVM_FILE <span class="hljs-keyword">file</span>)<br><span class="hljs-keyword">function</span> void set_report_id_file (<span class="hljs-built_in">string</span> id,UVM_FILE <span class="hljs-keyword">file</span>)<br><span class="hljs-keyword">function</span> void set_report_severity_id_file (uvm_severity <span class="hljs-keyword">severity</span>,<span class="hljs-built_in">string</span> id,UVM_FILE <span class="hljs-keyword">file</span>)<br><span class="hljs-keyword">function</span> void set_report_severity_file_hier (uvm_severity <span class="hljs-keyword">severity</span>,UVM_FILE <span class="hljs-keyword">file</span>)<br><span class="hljs-keyword">function</span> void set_report_id_file_hier (<span class="hljs-built_in">string</span> id,UVM_FILE <span class="hljs-keyword">file</span>)<br><span class="hljs-keyword">function</span> void set_report_severity_id_file_hier (uvm_severity <span class="hljs-keyword">severity</span>,<span class="hljs-built_in">string</span> id,UVM_FILE <span class="hljs-keyword">file</span>)<br></code></pre></td></tr></table></figure><h4 id="6-1-将不同severity的信息打印到不同的文件中。"><a href="#6-1-将不同severity的信息打印到不同的文件中。" class="headerlink" title="6.1 将不同severity的信息打印到不同的文件中。"></a>6.1 将不同severity的信息打印到不同的文件中。</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// 创建文件句柄</span><br><span class="hljs-comment">// 写入方式打开文件</span><br><span class="hljs-comment">//为不同severity设置保存文件</span><br><span class="hljs-comment">//设置打印的行为UVM_LOG</span><br><br>   UVM_FILE info_log;   <span class="hljs-comment">// 创建文件句柄</span><br>   UVM_FILE warning_log;<br>   UVM_FILE error_log;<br>   UVM_FILE fatal_log;<br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);<br>       info_log = <span class="hljs-built_in">$fopen</span>(<span class="hljs-string">&quot;info.log&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>); <span class="hljs-comment">// 写入方式打开文件</span><br>       warning_log = <span class="hljs-built_in">$fopen</span>(<span class="hljs-string">&quot;warning.log&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>       error_log = <span class="hljs-built_in">$fopen</span>(<span class="hljs-string">&quot;error.log&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>       fatal_log = <span class="hljs-built_in">$fopen</span>(<span class="hljs-string">&quot;fatal.log&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>       env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_file</span>(UVM_INFO,    info_log);<span class="hljs-comment">//为不同severity设置保存文件</span><br>       env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_file</span>(UVM_WARNING, warning_log);<br>       env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_file</span>(UVM_ERROR,   error_log);<br>       env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_file</span>(UVM_FATAL,   fatal_log);<br>       env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_action</span>(UVM_INFO, UVM_DISPLAY | UVM_LOG);<span class="hljs-comment">//设置打印的行为UVM_LOG</span><br>       env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_action</span>(UVM_WARNING, UVM_DISPLAY | UVM_LOG);<br>       env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_action</span>(UVM_ERROR, UVM_DISPLAY | UVM_COUNT | UVM_LOG);<br>       env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_action</span>(UVM_FATAL, UVM_DISPLAY | UVM_EXIT | UVM_LOG);<br>      <br>       <span class="hljs-comment">//env.i_agt.set_report_severity_file_hier(UVM_INFO,    info_log);</span><br>       <span class="hljs-comment">//env.i_agt.set_report_severity_file_hier(UVM_WARNING, warning_log);</span><br>       <span class="hljs-comment">//env.i_agt.set_report_severity_file_hier(UVM_ERROR,   error_log);</span><br>       <span class="hljs-comment">//env.i_agt.set_report_severity_file_hier(UVM_FATAL,   fatal_log);</span><br>       <span class="hljs-comment">//env.i_agt.set_report_severity_action_hier(UVM_INFO, UVM_DISPLAY| UVM_LOG);</span><br>       <span class="hljs-comment">//env.i_agt.set_report_severity_action_hier(UVM_WARNING, UVM_DISPLAY| UVM_LOG);</span><br>       <span class="hljs-comment">//env.i_agt.set_report_severity_action_hier(UVM_ERROR, UVM_DISPLAY| UVM_COUNT | UVM_LOG);</span><br>       <span class="hljs-comment">//env.i_agt.set_report_severity_action_hier(UVM_FATAL, UVM_DISPLAY| | UVM_EXIT | UVM_LOG);</span><br>   <span class="hljs-keyword">endfunction</span><br>   <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> final_phase(uvm_phase phase);<br>       <span class="hljs-built_in">$fclose</span>(info_log);<br>       <span class="hljs-built_in">$fclose</span>(warning_log);<br>       <span class="hljs-built_in">$fclose</span>(error_log);<br>       <span class="hljs-built_in">$fclose</span>(fatal_log);<br>   <span class="hljs-keyword">endfunction</span><br></code></pre></td></tr></table></figure><h4 id="6-2-将不同id的信息打印到不同的文件中。"><a href="#6-2-将不同id的信息打印到不同的文件中。" class="headerlink" title="6.2 将不同id的信息打印到不同的文件中。"></a>6.2 将不同id的信息打印到不同的文件中。</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs verilog">UVM_FILE driver_log;<br>UVM_FILE drv_log;<br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);<br>    driver_log = <span class="hljs-built_in">$fopen</span>(<span class="hljs-string">&quot;driver.log&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>    drv_log = <span class="hljs-built_in">$fopen</span>(<span class="hljs-string">&quot;drv.log&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>    env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_id_file</span>(UVM_WARNING, <span class="hljs-string">&quot;my_driver&quot;</span>, driver_log);<br>    env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_severity_id_file</span>(UVM_INFO, <span class="hljs-string">&quot;my_drv&quot;</span>, drv_log);<br>    env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_id_action</span>(<span class="hljs-string">&quot;my_driver&quot;</span>, UVM_DISPLAY| UVM_LOG);<br>    env<span class="hljs-variable">.i_agt</span><span class="hljs-variable">.drv</span><span class="hljs-variable">.set_report_id_action</span>(<span class="hljs-string">&quot;my_drv&quot;</span>, UVM_DISPLAY| UVM_LOG);<br>    <span class="hljs-comment">//env.i_agt.set_report_severity_id_file_hier(UVM_WARNING, &quot;my_driver&quot;, driver_log);</span><br>    <span class="hljs-comment">//env.i_agt.set_report_severity_id_file_hier(UVM_INFO, &quot;my_drv&quot;, drv_log);</span><br>    <span class="hljs-comment">//env.i_agt.set_report_id_action_hier(&quot;my_driver&quot;, UVM_DISPLAY| UVM_LOG);</span><br>    <span class="hljs-comment">//env.i_agt.set_report_id_action_hier(&quot;my_drv&quot;, UVM_DISPLAY| UVM_LOG);</span><br><span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> final_phase(uvm_phase phase);<br>    <span class="hljs-built_in">$fclose</span>(driver_log);<br>    <span class="hljs-built_in">$fclose</span>(drv_log);<br><span class="hljs-keyword">endfunction</span><br></code></pre></td></tr></table></figure><h3 id="7-信息的打印行为-action"><a href="#7-信息的打印行为-action" class="headerlink" title="7. 信息的打印行为 action"></a>7. 信息的打印行为 action</h3><p>前面大都是通过设置action来控制打印信息。</p><table><thead><tr><th>uvm_action</th><th>description</th></tr></thead><tbody><tr><td>UVM_NO_ACTION</td><td>No action is taken</td></tr><tr><td>UVM_DISPLAY</td><td>Sends the report to the standard output</td></tr><tr><td>UVM_LOG</td><td>Sends the report to the file(s) for this (severity,id) pair</td></tr><tr><td>UVM_COUNT</td><td>Counts the number of reports with the COUNT attribute.  When this value reaches max_quit_count, the simulation terminates</td></tr><tr><td>UVM_EXIT</td><td>Terminates the simulation immediately.</td></tr><tr><td>UVM_CALL_HOOK</td><td>Callback the report hook methods</td></tr><tr><td>UVM_STOP</td><td>Causes <em>$stop</em> to be executed, putting the simulation into interactive mode.</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span></span><br><span class="hljs-class">&#123;</span><br>  UVM_NO_ACTION = <span class="hljs-string">&#x27;b000000,</span><br><span class="hljs-string">  UVM_DISPLAY   = &#x27;</span>b000001,<br>  UVM_LOG       = <span class="hljs-string">&#x27;b000010,</span><br><span class="hljs-string">  UVM_COUNT     = &#x27;</span>b000100,<br>  UVM_EXIT      = <span class="hljs-string">&#x27;b001000,</span><br><span class="hljs-string">  UVM_CALL_HOOK = &#x27;</span>b010000,<br>  UVM_STOP      = <span class="hljs-string">&#x27;b100000</span><br><span class="hljs-string">&#125; uvm_action_type;</span><br></code></pre></td></tr></table></figure><h3 id="8-打印UVM树结构"><a href="#8-打印UVM树结构" class="headerlink" title="8. 打印UVM树结构"></a>8. 打印UVM树结构</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">uvm_top.print_topology()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>可以把它写在base_test中</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> base_test::report_phase(uvm_phase phase);<br>  <span class="hljs-keyword">super</span><span class="hljs-variable">.report_phase</span>(phase);<br>  uvm_top<span class="hljs-variable">.print_topology</span>();<br><span class="hljs-keyword">endfunction</span><br></code></pre></td></tr></table></figure><p>打印输出</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs sql">UVM_INFO @ <span class="hljs-number">43550000</span>: reporter [UVMTOP] UVM testbench topology:<br><span class="hljs-comment">------------------------------------------------------------------</span><br>Name                       Type                        Size  <span class="hljs-keyword">Value</span><br><span class="hljs-comment">------------------------------------------------------------------</span><br>uvm_test_top               case0                       <span class="hljs-operator">-</span>     <span class="hljs-variable">@460</span> <br>  env                      enviroment                  <span class="hljs-operator">-</span>     <span class="hljs-variable">@468</span> <br>    agt2mdl                uvm_tlm_analysis_fifo #(T)  <span class="hljs-operator">-</span>     <span class="hljs-variable">@492</span> <br>      analysis_export      uvm_analysis_imp            <span class="hljs-operator">-</span>     <span class="hljs-variable">@536</span> <br>      get_ap               uvm_analysis_port           <span class="hljs-operator">-</span>     <span class="hljs-variable">@527</span> <br>      get_peek_export      uvm_get_peek_imp            <span class="hljs-operator">-</span>     <span class="hljs-variable">@509</span> <br>      put_ap               uvm_analysis_port           <span class="hljs-operator">-</span>     <span class="hljs-variable">@518</span> <br>      put_export           uvm_put_imp                 <span class="hljs-operator">-</span>     <span class="hljs-variable">@500</span> <br>    i_agt                  agent                       <span class="hljs-operator">-</span>     <span class="hljs-variable">@480</span> <br>      drv                  driver                      <span class="hljs-operator">-</span>     <span class="hljs-variable">@545</span> <br>        rsp_port           uvm_analysis_port           <span class="hljs-operator">-</span>     <span class="hljs-variable">@562</span> <br>        seq_item_port      uvm_seq_item_pull_port      <span class="hljs-operator">-</span>     <span class="hljs-variable">@553</span> <br>      mon_apb              monitor_apb                 <span class="hljs-operator">-</span>     <span class="hljs-variable">@694</span> <br>        ap                 uvm_analysis_port           <span class="hljs-operator">-</span>     <span class="hljs-variable">@702</span> <br>      sqr                  sequencer                   <span class="hljs-operator">-</span>     <span class="hljs-variable">@571</span> <br>        rsp_export         uvm_analysis_export         <span class="hljs-operator">-</span>     <span class="hljs-variable">@579</span> <br>        seq_item_export    uvm_seq_item_pull_imp       <span class="hljs-operator">-</span>     <span class="hljs-variable">@685</span> <br>        arbitration_queue  <span class="hljs-keyword">array</span>                       <span class="hljs-number">0</span>     <span class="hljs-operator">-</span>    <br>        lock_queue         <span class="hljs-keyword">array</span>                       <span class="hljs-number">0</span>     <span class="hljs-operator">-</span>    <br>        num_last_reqs      integral                    <span class="hljs-number">32</span>    <span class="hljs-string">&#x27;d1  </span><br><span class="hljs-string">        num_last_rsps      integral                    32    &#x27;</span>d1  <br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>UVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
      <tag>UVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Verilog仿真原理</title>
    <link href="/2019/07/22/Verification/simulation/Verilog%E4%BB%BF%E7%9C%9F%E5%8E%9F%E7%90%86/"/>
    <url>/2019/07/22/Verification/simulation/Verilog%E4%BB%BF%E7%9C%9F%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="1-电路与仿真"><a href="#1-电路与仿真" class="headerlink" title="1. 电路与仿真"></a>1. 电路与仿真</h3><h4 id="1-1-电路是并行的"><a href="#1-1-电路是并行的" class="headerlink" title="1.1 电路是并行的"></a>1.1 电路是并行的</h4><h4 id="1-2-仿真时串行的"><a href="#1-2-仿真时串行的" class="headerlink" title="1.2 仿真时串行的"></a>1.2 仿真时串行的</h4><p>EDA工具是软件，在CPU中串行执行，所以仿真是串行的，也是顺序执行。</p><p>Verilog的并行性在仿真中是通过其语义（semantics）来实现的。语义就是Verilog的语言含义。比如@是等待事件，#10是延迟10个时间单位，块语句都是并行的。</p><h3 id="2-Verilog仿真概念"><a href="#2-Verilog仿真概念" class="headerlink" title="2. Verilog仿真概念"></a>2. Verilog仿真概念</h3><h4 id="2-1-仿真时间"><a href="#2-1-仿真时间" class="headerlink" title="2.1 仿真时间"></a>2.1 仿真时间</h4><p>仿真事件是仿真器维护的时间值，它用来模拟电路真实的运行事件。</p><p>Verilog仿真严格按照仿真时间 的时间轴向前推进。同一时刻有多个事件，那么按照优先级来执行，也就是后面要将的<strong>分层事件队列</strong>。</p><h4 id="2-2-事件驱动"><a href="#2-2-事件驱动" class="headerlink" title="2.2 事件驱动"></a>2.2 事件驱动</h4><p>事件分为计算事件和更新事件。</p><p>线网和寄存器值发生变化，叫做更新事件。一个更新事件执行后，所有对这个事件敏感的进程都被激活，以随机顺序计算。进程的计算是计算事件。</p><p>更新事件会产生计算事件，计算事件也会产生更新事件。相互触发，推进仿真进行。</p><h4 id="2-3-进程"><a href="#2-3-进程" class="headerlink" title="2.3 进程"></a>2.3 进程</h4><p>进程包括initial、always、module、原语、assign、异步任务和过程赋值等。</p><p>进程可以被激活和挂起。仿真器总是在处理被激活的一个进程，而挂起其他所有的进程。</p><p>多个进程在同一仿真时间执行时，仿真器会对它们的顺序进行调度。只有当前时刻所有的进程都执行完进入挂起状态，仿真时间才会向前推进。</p><p>进程的挂起有 事件语句@、延迟#、等待语句wait。当事件到来、延迟已过、wait的表达式为真，则进程激活</p><h4 id="2-4-调度"><a href="#2-4-调度" class="headerlink" title="2.4 调度"></a>2.4 调度</h4><p>调度就是安排同一时刻中事件的执行顺序，参见下面的<strong>分层事件队列</strong>。</p><h4 id="2-5-时序控制"><a href="#2-5-时序控制" class="headerlink" title="2.5 时序控制"></a>2.5 时序控制</h4><p>时序控制有<strong>事件语句@、延迟#、等待语句wait</strong>。当事件到来、延迟已过、wait的表达式为真，则进程激活</p><h4 id="2-6-进程、事件和仿真时间的关系"><a href="#2-6-进程、事件和仿真时间的关系" class="headerlink" title="2.6 进程、事件和仿真时间的关系"></a>2.6 进程、事件和仿真时间的关系</h4><p>​    事件在不同的时间发生，为了跟踪事件，以正确的时间处理事件，将事件放在事件队列中，由仿真时间来负责排序。<strong>特定时刻的所有事件放在一起，调度器可以将事件插入到事件队列中来把事件调度到将来某个时刻，也可以把事件弹出——执行事件。</strong></p><h4 id="2-7-verilog语言的不确定性"><a href="#2-7-verilog语言的不确定性" class="headerlink" title="2.7 verilog语言的不确定性"></a>2.7 verilog语言的不确定性</h4><ol><li>零时刻时，进程的执行顺序任意</li><li>各个进程的执行顺序不确定</li></ol><h3 id="3-分层事件队列"><a href="#3-分层事件队列" class="headerlink" title="3. 分层事件队列"></a>3. 分层事件队列</h3><h4 id="3-1-事件队列"><a href="#3-1-事件队列" class="headerlink" title="3.1 事件队列"></a>3.1 事件队列</h4><table><thead><tr><th></th><th>内容</th><th></th><th>描述</th></tr></thead><tbody><tr><td>active</td><td>阻塞赋值；连续赋值；非阻塞赋值的右值；$display；</td><td>当前时间</td><td>Active events occur at the current simulation time and can be processed in any order.</td></tr><tr><td>inactive</td><td>显式0延迟阻塞赋值；</td><td>当前时间</td><td>Inactive events occur at the current simulation time, but shall be processed after all the active events<br/>are processed</td></tr><tr><td>NBA</td><td>非阻塞赋值更新事件</td><td>当前时间</td><td>Nonblocking assign update events have been evaluated during some previous simulation time, but<br/>shall be assigned at this simulation time after all the active and inactive events are processed.</td></tr><tr><td>monitor</td><td>$monitor,$strobe函数</td><td>当前时间</td><td>Monitor events shall be processed after all the active, inactive, and nonblocking assign update<br/>events are processed.</td></tr><tr><td>将来仿真事件</td><td>被调度到将来时间的事件</td><td>将来时间</td><td>Future events occur at some future simulation time. Future events are divided into future inactive<br/>events and future nonblocking assignment update events.</td></tr></tbody></table><h4 id="3-2-仿真参考模型"><a href="#3-2-仿真参考模型" class="headerlink" title="3.2 仿真参考模型"></a>3.2 仿真参考模型</h4><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">while</span> (there are events) &#123;<br>    <span class="hljs-keyword">if</span> (no active events) &#123;<br>    <span class="hljs-keyword">if</span> (there are inactive events) &#123;<br>   activate all inactive events;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (there are nonblocking <span class="hljs-keyword">assign</span> update events) &#123;<br>    activate all nonblocking <span class="hljs-keyword">assign</span> update events;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (there are monitor events) &#123;<br>    activate all monitor events;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        advance T to the next <span class="hljs-keyword">event</span> <span class="hljs-keyword">time</span>;<br>        activate all inactive events <span class="hljs-keyword">for</span> <span class="hljs-keyword">time</span> T;<br>    &#125;<br>    &#125;<br>    E = any active <span class="hljs-keyword">event</span>;<br>    <span class="hljs-keyword">if</span> (E is an update <span class="hljs-keyword">event</span>) &#123;<br>        update the modified object;<br>        add evaluation events <span class="hljs-keyword">for</span> sensitive processes to <span class="hljs-keyword">event</span> queue;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* shall be an evaluation event */</span><br>        evaluate the process;<br>        add update events to the <span class="hljs-keyword">event</span> queue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>当前时间内所有的active event被称为仿真周期，</strong></p><p>0延迟的阻塞赋值 <code>assign #0 a = b;</code> 阻塞赋值的计算在active区域执行，但他的更新时间因为有0延迟，所以要在下一个仿真周期处理，也就是inactive区域被激活，此时对激活后的inactive event的处理也是一个仿真周期。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>sum1 &lt;= a+b; <span class="hljs-comment">//先执行a+b的计算事件，更新事件调度到当前仿真时刻的NBA区域</span><br>sum2 &lt;= #<span class="hljs-number">5</span> a+b; <span class="hljs-comment">//先执行a+b的计算事件，更新事件调度到5ns后仿真时间的NBA区域</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="4-仿真延迟"><a href="#4-仿真延迟" class="headerlink" title="4. 仿真延迟"></a>4. 仿真延迟</h3><h4 id="4-1-惯性延迟"><a href="#4-1-惯性延迟" class="headerlink" title="4.1 惯性延迟"></a>4.1 惯性延迟</h4><p>器件上的延迟，比如反相器的延迟。</p><p><strong>对惯性延迟的模拟：</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> #<span class="hljs-number">5</span> a = ~b;<br></code></pre></td></tr></table></figure><p>b变化后，a的计算事件执行，但是更新事件要到5ns以后。这模拟了一个反相器的延迟。</p><h4 id="4-2-传导延迟"><a href="#4-2-传导延迟" class="headerlink" title="4.2 传导延迟"></a>4.2 传导延迟</h4><p><strong>连线上的延迟。</strong></p><h3 id="5-阻塞和非阻塞"><a href="#5-阻塞和非阻塞" class="headerlink" title="5. 阻塞和非阻塞"></a>5. 阻塞和非阻塞</h3><p>没什么好补充的，通俗易懂。</p><p>在仿真时，非阻塞赋值先进行采样——右值进行计算。然后才执行阻塞赋值。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>data &lt;= a;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">assign</span> a = b + c;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">如果在时钟上升沿处，恰好a的值从0到1变化，那么因为先进行非阻塞采样，在always快中，</span><br><span class="hljs-comment">右值a采样到的还是0，然后再执行阻塞赋值a变成1，但这时always块中的a还是0，它已经采样过了。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>Simulation</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>Verilog</tag>
      
      <tag>Simulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV——数据类型</title>
    <link href="/2019/07/21/Verification/SystemVerilog/SV%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2019/07/21/Verification/SystemVerilog/SV%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>SystemVerilog中扩展了Verilog中的数据类型，增加双状态数据、动态数组、队列等。</p><h3 id="1-内建类型"><a href="#1-内建类型" class="headerlink" title="1. 内建类型"></a>1. 内建类型</h3><h4 id="1-1-logic类型"><a href="#1-1-logic类型" class="headerlink" title="1.1 logic类型"></a>1.1 logic类型</h4><p>SV中将reg类型替换成logic关键字，logic既可以在块语句中被赋值，也可以在assign中被赋值，可以用wire的地方都可以用logic来替换，但logic不能有多个驱动，比如双向总线建模的时候需要用wire。</p><h4 id="1-2-双状态数据类型"><a href="#1-2-双状态数据类型" class="headerlink" title="1.2 双状态数据类型"></a>1.2 双状态数据类型</h4><p>只有0 1两个状态，没有x z，有利于提高仿真器性能，减少内存使用。</p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">bit</span> b; <span class="hljs-comment">//sigle bit</span><br><span class="hljs-keyword">bit</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] b32 ;<span class="hljs-comment">// 32bit unsigned integer</span><br><span class="hljs-keyword">int</span> <span class="hljs-keyword">unsigned</span> ui ;<span class="hljs-comment">// 32bit unsigned integer</span><br><span class="hljs-keyword">int</span> i ;<span class="hljs-comment">//// 32bit signed integer</span><br><span class="hljs-keyword">byte</span> b8; <span class="hljs-comment">// 8bit signed integer</span><br><span class="hljs-keyword">shortint</span> s; <span class="hljs-comment">// 16bit signed integer</span><br><span class="hljs-keyword">longint</span> l;<span class="hljs-comment">//4bit signed integer</span><br><span class="hljs-keyword">integer</span> i4; <span class="hljs-comment">// 32bit signed integer</span><br><span class="hljs-keyword">time</span> t;<span class="hljs-comment">//64bit unsigned integer</span><br><span class="hljs-keyword">real</span> r; <span class="hljs-comment">// double precision floating point</span><br></code></pre></td></tr></table></figure><p>如果将双状态的变量连接到DUT的输出，那么如果输出x或z，将被转换成0或1，而不能检测到x z。使用$isunknown操作符可以在表达式位x或z的时候返回1.</p><h3 id="2-定位宽的数组"><a href="#2-定位宽的数组" class="headerlink" title="2. 定位宽的数组"></a>2. 定位宽的数组</h3><h4 id="2-1-定义和初始化"><a href="#2-1-定义和初始化" class="headerlink" title="2.1 定义和初始化"></a>2.1 定义和初始化</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">int</span> lo_hi[<span class="hljs-number">0</span>:<span class="hljs-number">15</span>]; <span class="hljs-comment">//声明16个元素的数组</span><br><span class="hljs-keyword">int</span> c_type[<span class="hljs-number">16</span>];<span class="hljs-comment">//声明16个元素的数组</span><br></code></pre></td></tr></table></figure><p>初始化用<strong>单引号和花括号</strong>组合。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">int</span> ascend[<span class="hljs-number">4</span>] = &#x27;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;; <br>ascend[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>] = &#x27;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;; <span class="hljs-comment">//修改前两个元素值</span><br>ascend=&#x27;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-keyword">default</span>:<span class="hljs-number">1</span>&#125;; <span class="hljs-comment">//最后两个元素默认1</span><br></code></pre></td></tr></table></figure><h4 id="2-2-foreach遍历数组"><a href="#2-2-foreach遍历数组" class="headerlink" title="2.2 foreach遍历数组"></a>2.2 foreach遍历数组</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">int</span> ascend[<span class="hljs-number">4</span>] = &#x27;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;; <br>    <span class="hljs-keyword">foreach</span> (ascend[i])  <span class="hljs-comment">// 不需要定义i，可以之间拿来用</span><br>    ascend[i]*=<span class="hljs-number">2</span>;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="2-3-遍历多维数组"><a href="#2-3-遍历多维数组" class="headerlink" title="2.3 遍历多维数组"></a>2.3 遍历多维数组</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">int</span> arr[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = &#x27;&#123;&#x27;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#x27;&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;&#125;;<br>    <span class="hljs-keyword">foreach</span>(arr[i，j])<br><span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,arr[i][j]); <span class="hljs-comment">//打印6个值</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>也可以分开遍历</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">int</span> arr[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = &#x27;&#123;&#x27;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#x27;&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;&#125;;<br><span class="hljs-keyword">foreach</span>(arr[i]) <span class="hljs-keyword">begin</span><br><span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;%d:\n&quot;</span>,i); <span class="hljs-comment">//打印6个值</span><br><span class="hljs-keyword">foreach</span>(arr[,j])<br><span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,arr[i][j]); <span class="hljs-comment">//打印6个值</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="2-4-赋值和比较"><a href="#2-4-赋值和比较" class="headerlink" title="2.4 赋值和比较"></a>2.4 赋值和比较</h4><p>两个数组间可以直接赋值，比较</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog">arr1 = arr2;<br>arr1 == arr2;<br></code></pre></td></tr></table></figure><h4 id="2-5-合并数组"><a href="#2-5-合并数组" class="headerlink" title="2.5 合并数组"></a>2.5 合并数组</h4><p>既可以当作单独的数据，也可以分成几个小份作为数组。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">bit</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>][<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] bytes;  <span class="hljs-comment">//4字节组装成的32bit</span><br>bytes = <span class="hljs-number">32&#x27;hCafe_Dada</span>;<br>bytes; <span class="hljs-comment">// 32bit</span><br>bytes[<span class="hljs-number">3</span>]; <span class="hljs-comment">//Ca字节</span><br>bytes[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>];<span class="hljs-comment">//单bit</span><br></code></pre></td></tr></table></figure><p><strong>用途：</strong></p><ol><li><p>如果需要标量与数组的转换用合并数组。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">bit </span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>]  <span class="hljs-keyword">b32 </span>= <span class="hljs-keyword">bytes </span><br></code></pre></td></tr></table></figure></li><li><p>如果需要等待信号变化，用合并数组，比如唤醒@操作符</p></li></ol><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">bit</span> [<span class="hljs-number">0</span>:<span class="hljs-number">3</span>][<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] bytes;<br><span class="hljs-keyword">bit</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] arr[<span class="hljs-number">4</span>];<br>@bytes ;<span class="hljs-comment">//正确，合并数组</span><br>@arr;<span class="hljs-comment">//错误，非合并数组</span><br></code></pre></td></tr></table></figure><h3 id="3-动态数组"><a href="#3-动态数组" class="headerlink" title="3. 动态数组"></a>3. 动态数组</h3><p>​    定宽数组的宽读在编译的时候就确定了。如果想在仿真时生成事务，但事务的总量是随机的，那么就需要用一个很宽的数组，但实际上可能只需要很小的数组，造成存储空间浪费。<strong>SV中提供动态数组，数组在仿真时分配存储空间。用[ ].用new[]来分配空间，delete()删除元素。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">int</span> dyn[],dyn2[]; <span class="hljs-comment">//[]符号</span><br>    dyn = <span class="hljs-keyword">new</span>[<span class="hljs-number">4</span>]; <span class="hljs-comment">//分配4个元素</span><br>    <span class="hljs-keyword">foreach</span>(dyn[i]) dyn[i] = i;<br>    dyn2=<span class="hljs-keyword">new</span>[<span class="hljs-number">4</span>](dyn); <span class="hljs-comment">// 将dyn的值给dyn2</span><br>    dyn<span class="hljs-variable">.delete</span>(); <br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><strong>定宽数组可以给动态数组赋值，编译器自动调用new函数。</strong></p><h3 id="4-队列-queue"><a href="#4-队列-queue" class="headerlink" title="4. 队列 queue"></a>4. 队列 queue</h3><p>可以在队列任何地方增加或者删除元素，在性能上的损耗比数组小。**$符号。**</p><p><strong>还括号初始化，但不需要单引号。</strong></p><p>最后一个索引是$.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;<br>q1[$] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br>q2[$] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>    q1<span class="hljs-variable">.insert</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>);<span class="hljs-comment">//在索引1处插入10</span><br>    q1<span class="hljs-variable">.insert</span>(<span class="hljs-number">1</span>,q2);<span class="hljs-comment">//插入队列</span><br>    q1<span class="hljs-variable">.delete</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//删除索引1处元素</span><br>q1<span class="hljs-variable">.push_front</span>(<span class="hljs-number">1</span>);<br>j=q1<span class="hljs-variable">.pop_front</span>;<br>q1<span class="hljs-variable">.push_back</span>(<span class="hljs-number">1</span>);<br>j=q1<span class="hljs-variable">.pop_back</span>();<br><span class="hljs-keyword">foreach</span> (q1[m]) q1[m];<br>    q1 = &#123;q1[<span class="hljs-number">0</span>],q1[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]&#125;; <span class="hljs-comment">// 最后一个索引是$</span><br>    q1 = &#123;q1[<span class="hljs-number">0</span>],j,q1[<span class="hljs-number">1</span>:$]&#125;; <span class="hljs-comment">// 在任意位置插入元素、队列</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="5-关联数组"><a href="#5-关联数组" class="headerlink" title="5. 关联数组"></a>5. 关联数组</h3><p>关联数组就是哈希，保存键值对。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-comment">//文件内容：</span><br><span class="hljs-number">12</span> min_address<br><span class="hljs-number">123</span> max_address<br><span class="hljs-comment">//</span><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">int</span> switch[<span class="hljs-keyword">string</span>]；<span class="hljs-comment">//定义，int是值类型，string是键类型</span><br><span class="hljs-keyword">int</span> min_add,max_add;<span class="hljs-comment">//</span><br><span class="hljs-keyword">int</span> i,r,file;<br><span class="hljs-keyword">string</span> s,idx;<br>file = <span class="hljs-built_in">$fopen</span>(<span class="hljs-string">&quot;switch.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">$feof</span>(file)) <span class="hljs-keyword">begin</span><br>r = <span class="hljs-built_in">$fscanf</span>(file,<span class="hljs-string">&quot;%d %s&quot;</span>,i,s);<br>switch[s] = i;  <span class="hljs-comment">// 赋值</span><br><span class="hljs-keyword">end</span><br>switch<span class="hljs-variable">.exist</span>(<span class="hljs-string">&quot;max_address&quot;</span>); <span class="hljs-comment">//是否存在某个键</span><br>switch<span class="hljs-variable">.first</span>(idx);<span class="hljs-comment">// 将第一个键值对的键（索引）保存在idx</span><br>    switch<span class="hljs-variable">.next</span>(idx);<span class="hljs-comment">//得到下一个键值对的键，保存在idx</span><br>switch<span class="hljs-variable">.delete</span>(idx);<span class="hljs-comment">//删除idx的键对应的键值对</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="6-数组的方法"><a href="#6-数组的方法" class="headerlink" title="6. 数组的方法"></a>6. 数组的方法</h3><h4 id="6-1-size"><a href="#6-1-size" class="headerlink" title="6.1 $size"></a>6.1 $size</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">int</span> arr[<span class="hljs-number">4</span>] = &#x27;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;; <br><span class="hljs-built_in">$size</span>(arr);<span class="hljs-comment">//返回数组长度</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="6-2-sum-product-or-xor"><a href="#6-2-sum-product-or-xor" class="headerlink" title="6.2 sum\product\or\xor"></a>6.2 sum\product\or\xor</h4><p>sum方法，返回元素宽度的值。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">bit</span>[<span class="hljs-number">0</span>:<span class="hljs-number">7</span>] arr[<span class="hljs-number">4</span>] = &#x27;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>arr<span class="hljs-variable">.sum</span>;<span class="hljs-comment">//返回8bit的值，也就是返回元素宽度的值</span><br><span class="hljs-number">32</span>‘b + arr<span class="hljs-variable">.sum</span>; <span class="hljs-comment">//返回32bit</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="6-3-定位数组元素"><a href="#6-3-定位数组元素" class="headerlink" title="6.3 定位数组元素"></a>6.3 定位数组元素</h4><p>max最大值、min最小值、unique返回不重复的元素。</p><p><strong>这些方法可以用在定宽数组、动态数组、队列中。返回类型是队列。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">int</span> f[<span class="hljs-number">6</span>] = &#x27;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>&#125;;<br><span class="hljs-keyword">int</span> q[$];<br>q = f<span class="hljs-variable">.max</span>; <span class="hljs-comment">//&#123;4&#125;</span><br>q = f<span class="hljs-variable">.min</span>; <span class="hljs-comment">//&#123;0&#125;</span><br>q = f<span class="hljs-variable">.unique</span>; <span class="hljs-comment">// &#123;0,1,2,4&#125;</span><br></code></pre></td></tr></table></figure><p><strong>with用来定位数组中的元素，与其他方法一起使用。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Verilog">q = f<span class="hljs-variable">.find</span> <span class="hljs-keyword">with</span>(item &gt; <span class="hljs-number">2</span>); /找到大于<span class="hljs-number">2</span>的元素，也是返回队列<br>q = f<span class="hljs-variable">.find_index</span> <span class="hljs-keyword">with</span>(item &gt;<span class="hljs-number">2</span>); <span class="hljs-comment">//大于2 的元素的索引</span><br>q = f<span class="hljs-variable">.find_first</span> <span class="hljs-keyword">with</span>(item &gt;<span class="hljs-number">2</span>);<br>q = f<span class="hljs-variable">.find_first_index</span> <span class="hljs-keyword">with</span>(item &gt;<span class="hljs-number">2</span>);<br>q = f<span class="hljs-variable">.find_last</span> <span class="hljs-keyword">with</span>(item &gt;<span class="hljs-number">2</span>);<br>q = f<span class="hljs-variable">.find_last_index</span> <span class="hljs-keyword">with</span>(item &gt;<span class="hljs-number">2</span>);<br>sum = f<span class="hljs-variable">.sum</span> <span class="hljs-keyword">with</span> (item &gt;<span class="hljs-number">2</span>);<span class="hljs-comment">//对大于2的元素求和</span><br></code></pre></td></tr></table></figure><p>在条件语句with中item是重复参数，默认是item，也可以制定其他值</p><h4 id="6-4-数组排序"><a href="#6-4-数组排序" class="headerlink" title="6.4 数组排序"></a>6.4 数组排序</h4><p>reverse，sort（从小到大），rsort（从大到小）</p><h3 id="7-元素类型选择"><a href="#7-元素类型选择" class="headerlink" title="7. 元素类型选择"></a>7. 元素类型选择</h3><p>动态数组：子程序中最好用动态数组，这样子程序可以对不同长度的数组进行处理，只需要程序参数匹配就行了。</p><p>关联数组：用在索引不规则的时候。比如由于随机值产生的分布索引</p><p>队列：当数组的元素数目变化很大的时候用队列，比如保存预期值的记分板中。</p><p>$size(array) 返回数组宽度</p><h3 id="8-typedef定义类型"><a href="#8-typedef定义类型" class="headerlink" title="8. typedef定义类型"></a>8. typedef定义类型</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> u32;<br></code></pre></td></tr></table></figure><h3 id="9-创建自定义结构"><a href="#9-创建自定义结构" class="headerlink" title="9. 创建自定义结构"></a>9. 创建自定义结构</h3><h4 id="9-1-struct"><a href="#9-1-struct" class="headerlink" title="9.1 struct"></a>9.1 struct</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br><span class="hljs-keyword">int</span> a;<br><span class="hljs-keyword">string</span> b;&#125; my_struct;<br>my_struct st = &#x27;&#123;<span class="hljs-number">1</span>,&#x27;dong&#x27;&#125;;<br></code></pre></td></tr></table></figure><p><strong>用单引号和花括号来初始化。</strong></p><h4 id="9-2-合并结构packed"><a href="#9-2-合并结构packed" class="headerlink" title="9.2 合并结构packed"></a>9.2 合并结构packed</h4><p>合并结构以连续的bit集来存放数据，</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-keyword">packed</span> &#123;<span class="hljs-keyword">bit</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] a,b,c;&#125; p_s;<br></code></pre></td></tr></table></figure><p>合并struct和非合并struct的区别在于仿真的效率上。P42《绿皮书》</p><h3 id="10-枚举类型"><a href="#10-枚举类型" class="headerlink" title="10. 枚举类型"></a>10. 枚举类型</h3><h4 id="10-1-定义"><a href="#10-1-定义" class="headerlink" title="10.1 定义"></a>10.1 定义</h4><p>枚举类型可以为列表中的每个名称赋值。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;INIT,DECODE,IDLE&#125; fstate_e; <span class="hljs-comment">//定义枚举类型</span><br>fstate_e nstate,pstate;<span class="hljs-comment">//创建枚举变量</span><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">case</span>(pstete)<br>IDLE:nstate &lt;= INIT;<br>INIT:nstate &lt;= DECODE;<br>DECODE:nstate &lt;= IDLE;<br><span class="hljs-keyword">endcase</span><br>    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;nstate name is %s&quot;</span>,nstate<span class="hljs-variable">.name</span>()); <span class="hljs-comment">//</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>name()函数返回当前枚举值的符号名。</p><p><strong>声明了枚举变量fstate_e之后，INIT,DECODE,IDLE这些名字可以直接拿过来用。它们的默认值是从0开始，递增，当然也可以自己设置.</strong></p><p><strong>注意：枚举类型被当作int来存在，如果定义变量的时候没有初始化，那么默认将枚举变量初始化为0，但如果在定义枚举变量的时候没有0，那么出错。如下面：</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;INIT=<span class="hljs-number">1</span>,DECODE&#125; state_e;<br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>state_e p=<span class="hljs-number">1</span>;<span class="hljs-comment">//正确</span><br>state_e pp;<span class="hljs-comment">//错误，默认给pp赋值0，但state_e中没0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="10-2-枚举子程序"><a href="#10-2-枚举子程序" class="headerlink" title="10.2 枚举子程序"></a>10.2 枚举子程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">first（）;<span class="hljs-comment">//返回第一个</span><br>last（）<br>next（）下一个，会绕回<br>next（N）下N个<br>prev（）前一个<br>prev（N）前N个<br></code></pre></td></tr></table></figure><h3 id="11-常量-const"><a href="#11-常量-const" class="headerlink" title="11. 常量 const"></a>11. 常量 const</h3><h3 id="12-字符串-string"><a href="#12-字符串-string" class="headerlink" title="12. 字符串 string"></a>12. 字符串 string</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">getc(index)<br><span class="hljs-built_in">tolower</span>()<br>tohigher()<br>len()<br>substr(index1,index2);<br>$psprintf();<span class="hljs-comment">//产生格式化的字符串</span><br></code></pre></td></tr></table></figure><h3 id="13-类型转换"><a href="#13-类型转换" class="headerlink" title="13. 类型转换"></a>13. 类型转换</h3><h4 id="13-1-静态转换"><a href="#13-1-静态转换" class="headerlink" title="13.1 静态转换"></a>13.1 静态转换</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">int</span> i;<br>i = <span class="hljs-keyword">int</span>&#x27;(<span class="hljs-number">10</span><span class="hljs-variable">.0</span>-<span class="hljs-number">0</span><span class="hljs-variable">.1</span>);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="13-2-动态-cast"><a href="#13-2-动态-cast" class="headerlink" title="13.2 动态 $cast"></a>13.2 动态 $cast</h4><h4 id="13-3-流操作符"><a href="#13-3-流操作符" class="headerlink" title="13.3 流操作符"></a>13.3 流操作符</h4><p>“&gt;&gt;”是将bit从左到右排列，转换成一个数据。</p><p>“&lt;&lt;”是将bit从右到左排列，转换成一个数据。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">int</span> h;<br><span class="hljs-keyword">bit</span>[<span class="hljs-number">0</span>:<span class="hljs-number">7</span>] g[<span class="hljs-number">4</span>],j[<span class="hljs-number">4</span>] = &#x27;&#123;<span class="hljs-number">8&#x27;ha</span>,<span class="hljs-number">8&#x27;hb</span>,<span class="hljs-number">8&#x27;hc</span>&#x27;<span class="hljs-number">8&#x27;hd</span>&#125;;<br><span class="hljs-keyword">bit</span>[<span class="hljs-number">0</span>:<span class="hljs-number">7</span>] q;<br>    <span class="hljs-keyword">bit</span>[<span class="hljs-number">0</span>:<span class="hljs-number">7</span>] b1,b2,b3,b4;<br>h = &#123;&gt;&gt;&#123;j&#125;&#125;; <span class="hljs-comment">//以bit为单位将数组j从左到右打包成整数 0a0b0c0d</span><br>h = &#123;&lt;&lt;&#123;j&#125;&#125;; <span class="hljs-comment">//以bit为单位将数组j从右到左打包成整数 b030d050</span><br>h = &#123;&lt;&lt;<span class="hljs-keyword">byte</span>&#123;j&#125;&#125;; <span class="hljs-comment">//以byte为单位将数组j从左到右打包成整数 0d0c0b0a</span><br>g = &#123;&lt;&lt;<span class="hljs-keyword">byte</span>&#123;j&#125;&#125;;<br>q = &#123;&lt;&lt;<span class="hljs-number">4</span>&#123;<span class="hljs-number">8&#x27;b0001_1000</span>&#125;&#125;; <span class="hljs-comment">//1000_0001 半字节倒序</span><br>    &#123;&gt;&gt;<span class="hljs-keyword">byte</span>&#123;b1,b2,b3,b4&#125;&#125; = &#123;&gt;&gt;<span class="hljs-keyword">byte</span>&#123;j&#125;&#125;;<span class="hljs-comment">//先将数组j以byte为单位pack，然后再以byte为单位unpack，并赋值给b1,b2,b3,b4</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cummings——异步FIFO第二讲</title>
    <link href="/2019/07/18/IC/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F/Cummings%E2%80%94%E2%80%94%E5%BC%82%E6%AD%A5FIFO%E7%AC%AC%E4%BA%8C%E8%AE%B2/"/>
    <url>/2019/07/18/IC/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F/Cummings%E2%80%94%E2%80%94%E5%BC%82%E6%AD%A5FIFO%E7%AC%AC%E4%BA%8C%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="0-参考"><a href="#0-参考" class="headerlink" title="0. 参考"></a>0. 参考</h3><p><strong>Simulation and Synthesis Techniques for Asynchronous FIFO Design with Asynchronous Pointer Comparisons – Clifford E. Cummings ，Sunburst Design</strong></p><h3 id="1-异步FIFO"><a href="#1-异步FIFO" class="headerlink" title="1. 异步FIFO"></a>1. 异步FIFO</h3><p>异步FIFO是指读数据在一个clock demain，写数据在另一个clock demain的FIFO buffer。</p><p>相关参考之前一篇文章      <a href="https://east1203.github.io/2019/07/16/IC/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F/Cummings%E2%80%94%E2%80%94%E5%BC%82%E6%AD%A5FIFO%E7%AC%AC%E4%B8%80%E8%AE%B2/">Cummings——异步FIFO第一讲</a></p><h3 id="2-判断FIFO空满的第二种方法"><a href="#2-判断FIFO空满的第二种方法" class="headerlink" title="2. 判断FIFO空满的第二种方法"></a>2. 判断FIFO空满的第二种方法</h3><p>通常情况下FIFO的空满是通过增加一位地址位来判断的，比如   <a href="https://east1203.github.io/2019/07/16/IC/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F/Cummings%E2%80%94%E2%80%94%E5%BC%82%E6%AD%A5FIFO%E7%AC%AC%E4%B8%80%E8%AE%B2/">Cummings——异步FIFO第一讲</a></p><p>中的方法，本文要介绍另一种方法，可以减少寄存器使用。</p><h4 id="2-1-满判断"><a href="#2-1-满判断" class="headerlink" title="2.1 满判断"></a>2.1 满判断</h4><p>根据地址的高两位将FIFO的地址空间分成四部分，如下图figure2所示：</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/asynchronous/two0.png"></p><p>地址是格雷码地址。如果写地址落后读地址一个地址空间，比如写地址在00空间，读地址在01空间，那么说明写地址快要追上读地址，FIFO快要满了，这时候给一个”possibly going full”位，此时figure4中的direction latch会被set（低电平set，所以figure2中取反了）。</p><h4 id="2-2-空判断"><a href="#2-2-空判断" class="headerlink" title="2.2 空判断"></a>2.2 空判断</h4><p>空判断与满判断类似，有一个“possibly going empty”位，低电平时将direction latch clear了。如下图，只是这时候</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/asynchronous/two1.png"></p><h4 id="2-3-direction-latch"><a href="#2-3-direction-latch" class="headerlink" title="2.3 direction latch"></a>2.3 direction latch</h4><p>direction为1表示快要满了，如果接下来读写地址相同，则满；为0表示快要空了，如果接下来读写地址相同，则空。</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/asynchronous/two2.png"></p><h3 id="3-fifo结构图"><a href="#3-fifo结构图" class="headerlink" title="3. fifo结构图"></a>3. fifo结构图</h3><p>FIFO的结构图如下，空满标志位是在CMP比较逻辑中产生的，在CMP中先生成direction方向位，然后判断读写地址。</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/asynchronous/fifo2.png"></p><h3 id="4-RTL代码"><a href="#4-RTL代码" class="headerlink" title="4. RTL代码"></a>4. RTL代码</h3><h4 id="4-1-top层"><a href="#4-1-top层" class="headerlink" title="4.1 top层"></a>4.1 top层</h4><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> fifo2 (rdata, wfull, rempty, wdata,<br>winc, wclk, wrst_n, rinc, rclk, rrst_n);<br><span class="hljs-keyword">parameter</span> DSIZE = <span class="hljs-number">8</span>;<br><span class="hljs-keyword">parameter</span> ASIZE = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">output</span> [DSIZE-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] rdata;<br><span class="hljs-keyword">output</span> wfull;<br><span class="hljs-keyword">output</span> rempty;<br><span class="hljs-keyword">input</span> [DSIZE-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] wdata;<br><span class="hljs-keyword">input</span> winc, wclk, wrst_n;<br><span class="hljs-keyword">input</span> rinc, rclk, rrst_n;<br><span class="hljs-keyword">wire</span> [ASIZE-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] wptr, rptr;<br><span class="hljs-keyword">wire</span> [ASIZE-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] waddr, raddr;<br>async_cmp <span class="hljs-variable">#(ASIZE)</span> async_cmp<br>(<span class="hljs-variable">.aempty_n</span>(aempty_n), <span class="hljs-variable">.afull_n</span>(afull_n),<br><span class="hljs-variable">.wptr</span>(wptr), <span class="hljs-variable">.rptr</span>(rptr), <span class="hljs-variable">.wrst_n</span>(wrst_n));<br>fifomem <span class="hljs-variable">#(DSIZE, ASIZE)</span> fifomem<br>(<span class="hljs-variable">.rdata</span>(rdata), <span class="hljs-variable">.wdata</span>(wdata),<br><span class="hljs-variable">.waddr</span>(wptr), <span class="hljs-variable">.raddr</span>(rptr),<br><span class="hljs-variable">.wclken</span>(winc), <span class="hljs-variable">.wclk</span>(wclk));<br>rptr_empty <span class="hljs-variable">#(ASIZE)</span> rptr_empty<br>(<span class="hljs-variable">.rempty</span>(rempty), <span class="hljs-variable">.rptr</span>(rptr),<br><span class="hljs-variable">.aempty_n</span>(aempty_n), <span class="hljs-variable">.rinc</span>(rinc),<br><span class="hljs-variable">.rclk</span>(rclk), <span class="hljs-variable">.rrst_n</span>(rrst_n));<br>wptr_full <span class="hljs-variable">#(ASIZE)</span> wptr_full<br>(<span class="hljs-variable">.wfull</span>(wfull), <span class="hljs-variable">.wptr</span>(wptr),<br><span class="hljs-variable">.afull_n</span>(afull_n), <span class="hljs-variable">.winc</span>(winc),<br><span class="hljs-variable">.wclk</span>(wclk), <span class="hljs-variable">.wrst_n</span>(wrst_n));<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h4 id="4-2-mem读写"><a href="#4-2-mem读写" class="headerlink" title="4.2 mem读写"></a>4.2 mem读写</h4><p>mem读写跟第一种FIFO一样，  <a href="https://east1203.github.io/2019/07/16/IC/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F/Cummings%E2%80%94%E2%80%94%E5%BC%82%E6%AD%A5FIFO%E7%AC%AC%E4%B8%80%E8%AE%B2/">Cummings——异步FIFO第一讲</a></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> fifomem (rdata, wdata, waddr, raddr, wclken, wclk);<br><span class="hljs-keyword">parameter</span> DATASIZE = <span class="hljs-number">8</span>; <span class="hljs-comment">// Memory data word width</span><br><span class="hljs-keyword">parameter</span> ADDRSIZE = <span class="hljs-number">4</span>; <span class="hljs-comment">// Number of memory address bits</span><br><span class="hljs-keyword">parameter</span> DEPTH = <span class="hljs-number">1</span>&lt;&lt;ADDRSIZE; <span class="hljs-comment">// DEPTH = 2**ADDRSIZE</span><br><span class="hljs-keyword">output</span> [DATASIZE-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] rdata;<br><span class="hljs-keyword">input</span> [DATASIZE-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] wdata;<br><span class="hljs-keyword">input</span> [ADDRSIZE-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] waddr, raddr;<br><span class="hljs-keyword">input</span> wclken, wclk;<br><span class="hljs-meta">`<span class="hljs-keyword">ifdef</span> VENDORRAM</span><br><span class="hljs-comment">// instantiation of a vendor&#x27;s dual-port RAM</span><br>VENDOR_RAM MEM (<span class="hljs-variable">.dout</span>(rdata), <span class="hljs-variable">.din</span>(wdata),<br><span class="hljs-variable">.waddr</span>(waddr), <span class="hljs-variable">.raddr</span>(raddr),<br><span class="hljs-variable">.wclken</span>(wclken), <span class="hljs-variable">.clk</span>(wclk));<br><span class="hljs-meta">`<span class="hljs-keyword">else</span></span><br><span class="hljs-keyword">reg</span> [DATASIZE-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] MEM [<span class="hljs-number">0</span>:DEPTH-<span class="hljs-number">1</span>];<br><span class="hljs-keyword">assign</span> rdata = MEM[raddr];<br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> wclk)<br><span class="hljs-keyword">if</span> (wclken) MEM[waddr] &lt;= wdata;<br><span class="hljs-meta">`<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h4 id="4-3-CMP比较逻辑"><a href="#4-3-CMP比较逻辑" class="headerlink" title="4.3 CMP比较逻辑"></a>4.3 CMP比较逻辑</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> async_cmp (aempty_n, afull_n, wptr, rptr, wrst_n);<br><span class="hljs-keyword">parameter</span> ADDRSIZE = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">parameter</span> N = ADDRSIZE-<span class="hljs-number">1</span>;<br><span class="hljs-keyword">output</span> aempty_n, afull_n;<br><span class="hljs-keyword">input</span> [N:<span class="hljs-number">0</span>] wptr, rptr;<br><span class="hljs-keyword">input</span> wrst_n;<br><span class="hljs-keyword">reg</span> direction;<br><span class="hljs-keyword">wire</span> high = <span class="hljs-number">1&#x27;b1</span>;<br><span class="hljs-keyword">wire</span> dirset_n = ~( (wptr[N]^rptr[N-<span class="hljs-number">1</span>]) &amp; ~(wptr[N-<span class="hljs-number">1</span>]^rptr[N]));<br><span class="hljs-keyword">wire</span> dirclr_n = ~((~(wptr[N]^rptr[N-<span class="hljs-number">1</span>]) &amp; (wptr[N-<span class="hljs-number">1</span>]^rptr[N])) |<br>~wrst_n);<br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> high <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> dirset_n <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> dirclr_n)<br><span class="hljs-keyword">if</span> (!dirclr_n) direction &lt;= <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!dirset_n) direction &lt;= <span class="hljs-number">1&#x27;b1</span>;<br><span class="hljs-keyword">else</span> direction &lt;= high;<br><span class="hljs-comment">//always @(negedge dirset_n or negedge dirclr_n)</span><br><span class="hljs-comment">//if (!dirclr_n) direction &lt;= 1&#x27;b0;</span><br><span class="hljs-comment">//else direction &lt;= 1&#x27;b1;</span><br><span class="hljs-keyword">assign</span> aempty_n = ~((wptr == rptr) &amp;&amp; !direction);<br><span class="hljs-keyword">assign</span> afull_n = ~((wptr == rptr) &amp;&amp; direction);<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>CMP的框图如下：</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/asynchronous/two3.png"></p><h5 id="4-3-1-异步的空满产生"><a href="#4-3-1-异步的空满产生" class="headerlink" title="4.3.1 异步的空满产生"></a>4.3.1 异步的空满产生</h5><p>aempty_n为0时，empty置位为1.aempty_n为0（也就是空）是在rclk时钟域产生的（因为读数据时候才可能空），而aempty_n为1（也就是空被clear）是在我才离开时钟域产生（因为写数据才不为空）。</p><p>同样afull_n是在wclk产生满置位，在rclk满清零。</p><p><strong>异步的空满操作：</strong></p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/asynchronous/two5.png"></p><p>​    如果afull_n&#x3D;0说明满了，满这个状态相比于不满状态持续时间肯定短，如果刚刚满了，但是又接着读数据，那么这个满状态持续时间很短（在rclk的上升沿afull_n&#x3D;1，使状态编程不满。)，如果用wclk对afull_n采样这个满状态0可能不满足建立保持时间，所以就直接将afull_n接到置位上，避免时序不满足。<br>​    还可以看出wfull的set不受wclk的影响，这是因为满是由wclk控制的waddr来控制的；wfull的clear需要用wclk用两个周期来同步，这是因为不满是由rclk控制的raddr来控制的，需要用wclk同步一下。</p><h5 id="4-3-2-reset操作"><a href="#4-3-2-reset操作" class="headerlink" title="4.3.2 reset操作"></a>4.3.2 reset操作</h5><p>如figure6所示，这里的复位信号是wrst_n。如果wrst_n复位，则：</p><p>1） 满标志位立马清零。</p><p>2） 使读写地址都为零，所以地址比较器输出1</p><p>3） direction置为零</p><p>4） direction清零值得aempty_n为零，使empty为1.</p><h5 id="4-3-3-写与满"><a href="#4-3-3-写与满" class="headerlink" title="4.3.3 写与满"></a>4.3.3 写与满</h5><p>置位之后，如果winc有效，则地址比较器输出0，aempty_n为1，两个rclk之后，empty为0.</p><p>如果winc继续有效，当waddr落后raddr一个地址空间时，direction为1，表明将要满了。</p><p>如果winc继续有效，当waddr等于raddr时，afull_n为0，立马时wfull为1.</p><h5 id="4-3-4-读与空"><a href="#4-3-4-读与空" class="headerlink" title="4.3.4  读与空"></a>4.3.4  读与空</h5><p>上面写满了，如果接下来要读，即rinc有效，读写地址不同了，afull_n为1，两个wclk之后，full无效。</p><p>如果inc接着有效，当raddr落后waddr一个地址空间时，，，后面不必详述了，差不多东西。</p><h4 id="4-4-空标志"><a href="#4-4-空标志" class="headerlink" title="4.4 空标志"></a>4.4 空标志</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> rptr_empty (rempty, rptr, aempty_n, rinc, rclk, rrst_n);<br><span class="hljs-keyword">parameter</span> ADDRSIZE = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">output</span> rempty;<br><span class="hljs-keyword">output</span> [ADDRSIZE-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] rptr;<br><span class="hljs-keyword">input</span> aempty_n;<br><span class="hljs-keyword">input</span> rinc, rclk, rrst_n;<br><span class="hljs-keyword">reg</span> [ADDRSIZE-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] rptr, rbin;<br><span class="hljs-keyword">reg</span> rempty, rempty2;<br><span class="hljs-keyword">wire</span> [ADDRSIZE-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] rgnext, rbnext;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-comment">// GRAYSTYLE2 pointer</span><br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> rclk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rrst_n)<br><span class="hljs-keyword">if</span> (!rrst_n) <span class="hljs-keyword">begin</span><br>rbin &lt;= <span class="hljs-number">0</span>;<br>rptr &lt;= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>rbin &lt;= rbnext;<br>rptr &lt;= rgnext;<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-comment">// increment the binary count if not empty</span><br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-keyword">assign</span> rbnext = !rempty ? rbin + rinc : rbin;<br><span class="hljs-keyword">assign</span> rgnext = (rbnext&gt;&gt;<span class="hljs-number">1</span>) ^ rbnext; <span class="hljs-comment">// binary-to-gray conversion</span><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> rclk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> aempty_n)<br><span class="hljs-keyword">if</span> (!aempty_n) &#123;rempty,rempty2&#125; &lt;= <span class="hljs-number">2&#x27;b11</span>;<br><span class="hljs-keyword">else</span> &#123;rempty,rempty2&#125; &lt;= &#123;rempty2,~aempty_n&#125;;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h4 id="4-5-满标志"><a href="#4-5-满标志" class="headerlink" title="4.5 满标志"></a>4.5 满标志</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> wptr_full (wfull, wptr, afull_n, winc, wclk, wrst_n);<br><span class="hljs-keyword">parameter</span> ADDRSIZE = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">output</span> wfull;<br><span class="hljs-keyword">output</span> [ADDRSIZE-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] wptr;<br><span class="hljs-keyword">input</span> afull_n;<br><span class="hljs-keyword">input</span> winc, wclk, wrst_n;<br><span class="hljs-keyword">reg</span> [ADDRSIZE-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] wptr, wbin;<br><span class="hljs-keyword">reg</span> wfull, wfull2;<br><span class="hljs-keyword">wire</span> [ADDRSIZE-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] wgnext, wbnext;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-comment">// GRAYSTYLE2 pointer</span><br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> wclk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> wrst_n)<br><span class="hljs-keyword">if</span> (!wrst_n) <span class="hljs-keyword">begin</span><br>wbin &lt;= <span class="hljs-number">0</span>;<br>wptr &lt;= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>wbin &lt;= wbnext;<br>wptr &lt;= wgnext;<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-comment">// increment the binary count if not full</span><br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-keyword">assign</span> wbnext = !wfull ? wbin + winc : wbin;<br><span class="hljs-keyword">assign</span> wgnext = (wbnext&gt;&gt;<span class="hljs-number">1</span>) ^ wbnext; <span class="hljs-comment">// binary-to-gray conversion</span><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> wclk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> wrst_n <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> afull_n)<br><span class="hljs-keyword">if</span> (!wrst_n ) &#123;wfull,wfull2&#125; &lt;= <span class="hljs-number">2&#x27;b00</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!afull_n) &#123;wfull,wfull2&#125; &lt;= <span class="hljs-number">2&#x27;b11</span>;<br><span class="hljs-keyword">else</span> &#123;wfull,wfull2&#125; &lt;= &#123;wfull2,~afull_n&#125;;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>Asynchronous</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>Asynchronous</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cummings——异步FIFO第一讲</title>
    <link href="/2019/07/16/IC/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F/Cummings%E2%80%94%E2%80%94%E5%BC%82%E6%AD%A5FIFO%E7%AC%AC%E4%B8%80%E8%AE%B2/"/>
    <url>/2019/07/16/IC/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F/Cummings%E2%80%94%E2%80%94%E5%BC%82%E6%AD%A5FIFO%E7%AC%AC%E4%B8%80%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="0-参考"><a href="#0-参考" class="headerlink" title="0. 参考"></a>0. 参考</h3><p><strong>Simulation and Synthesis Techniques for Asynchronous FIFO Design — Clifford E. Cummings, Sunburst Design</strong> </p><h3 id="1-异步FIFO"><a href="#1-异步FIFO" class="headerlink" title="1. 异步FIFO"></a>1. 异步FIFO</h3><p>在跨时钟域传输的时候容易发生亚稳态。当在不同时钟域之间传递的多个信号时，需要用到异步FIFO。</p><p>异步FIFO的难点在于生成读写地址和空满指示位。</p><h3 id="2-FIFO指针"><a href="#2-FIFO指针" class="headerlink" title="2. FIFO指针"></a>2. FIFO指针</h3><h4 id="2-1-同步fifo指针"><a href="#2-1-同步fifo指针" class="headerlink" title="2.1 同步fifo指针"></a>2.1 同步fifo指针</h4><p>​    对于同步FIFO而言，读写时钟相同，可以用一个计数器来表示FIFO的状态，如果只写数据，则计数增加；如果只读，则计数减少；级读又写，则计数不变。当计数到某个值，表示FIFO为满；计数为零，表示FIFO空。此时的读地址在每次读有效的时候增加就可以了，当读到最高为会回到零；写地址一样。</p><h4 id="2-2-异步FIFO指针"><a href="#2-2-异步FIFO指针" class="headerlink" title="2.2 异步FIFO指针"></a>2.2 异步FIFO指针</h4><p><strong>写指针：</strong>写指针指向下一个要写的地址。当FIFO reset之后，写指针为0。当写操作有效的时候，在下一个时钟沿出向写地址指向的位置写数据，然后写指针累加，指向下一个写地址。</p><p><strong>读地址：</strong>读指针也要指向下一个要读的地址，FIFO reset之后，读指针也为0，此时空标志位有效，当写了一个数据后，空表示为清零。读操作有效的时候，在下一个时钟沿，向读地址指示的位置读数据，并使读地址累加。</p><p><strong>满状态</strong>：如果写地址赶上读地址，此时读写地址相同，写地址将读地址套圈了，那么FIFO满了。</p><p><strong>空状态：</strong>reset之后是空；当读地址赶上写地址，FIFO空。</p><p><strong>地址上增加一位空满标志位：</strong>n位地址，最高位为标志位，低n-1位位真正的FIFO地址。除了最高位，读写地址相同，则为满；如果读写地址相同——最高位也相同，那么空。</p><h4 id="2-3-二进制的地址问题"><a href="#2-3-二进制的地址问题" class="headerlink" title="2.3 二进制的地址问题"></a>2.3 二进制的地址问题</h4><p>​    二进制地址累加时，相邻地址经常存在多位同时跳变比如01到10，有两位同时跳变。在异步采样时可能没有采样到同时跳变后的值，可能采样到00，11的情况。</p><p>解决：用格雷码表示地址</p><h3 id="3-格雷码计数器"><a href="#3-格雷码计数器" class="headerlink" title="3.格雷码计数器"></a>3.格雷码计数器</h3><h4 id="3-0-跨时钟域中使用格雷码的作用："><a href="#3-0-跨时钟域中使用格雷码的作用：" class="headerlink" title="3.0 跨时钟域中使用格雷码的作用："></a>3.0 跨时钟域中使用格雷码的作用：</h4><ol><li>相邻码只改变一位，降低亚稳态的发生。</li><li>减少地址翻转，降低功耗。</li><li>即使发生采样错误也不会产生功能错误。地址改变时，跨时钟采样可能采样到原来值，或者改变后的值。比如读地址同步到写时钟域，采样到了原来的值，产生最差的情况是不满的时候判断为满，只是会延迟一点写操作，不会产生功能错误。</li><li>并且，即使发生采样错误，读地址延迟了一个写时钟周期，那么在下一次采样读地址的时候，如果采样正确，那么不会存在地址延迟的情况；即使下一次还是采样到了亚稳态，那么地址还是延迟一个周期，并不是说延迟累加，两次采样错误延迟了两个周期。</li></ol><p><strong>特点</strong>：<br>1.相邻码只改变1bit<br>2.只能用来记2的指数倍数，不能记奇数个数</p><p>如下图：</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/asynchronous/gray0.png"></p><p>格雷码与二进制的转换：</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/%E5%BC%82%E6%AD%A5fifo/2.png"></p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/%E5%BC%82%E6%AD%A5fifo/3.png"></p><p><strong>格雷码计数器的功能</strong>：在写时钟域内，二进制地址累加，然后将二进制的写地址转换成格雷码地址，格雷码地址要传给读时钟域；在写时钟域中格雷码转换器将二进制的读地址转换成格雷码地址，格雷码地址要传给写时钟域。</p><h4 id="3-1-第一种格雷码计数器"><a href="#3-1-第一种格雷码计数器" class="headerlink" title="3.1  第一种格雷码计数器"></a>3.1  第一种格雷码计数器</h4><p>一种格雷码编码风格如下，只需要一组地址寄存器来保存地址：</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/asynchronous/gray1.png"></p><p>​    上图中上半部分表示生成n位的格雷码；下半部分红框部分将格雷码最高位与次高位异或，然后将生成的addrmsb与格雷码的低n-2位合并成一个N-1位的格雷码地址，不知有什么用？？</p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// 上半图的n位格雷码计数器</span><br><span class="hljs-keyword">wire</span> clk,rst_n;<br><span class="hljs-keyword">wire</span> [n-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] bin,bnext,gnext;<br><span class="hljs-keyword">wire</span> inc,full; <span class="hljs-comment">// 写时钟域的格雷码转换器</span><br><span class="hljs-keyword">reg</span> [n-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] ptr; <span class="hljs-comment">//输出的n位格雷码</span><br><span class="hljs-keyword">integer</span> i;<br><span class="hljs-keyword">always</span>@(ptr) <span class="hljs-keyword">begin</span>  <span class="hljs-comment">//格雷码转二进制</span><br>bin[n-<span class="hljs-number">1</span>] = ptr[n-<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span>(i=n-<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;i=i+<span class="hljs-number">1</span>)<br>bin[i] = bin[i+<span class="hljs-number">1</span>] ^ bin[i];<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">assign</span> bnext = bnext+(inc &amp;&amp; !full)?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br><span class="hljs-keyword">assign</span> gnext = (bnext&gt;&gt;<span class="hljs-number">1</span>) ^ bnext; <span class="hljs-comment">//二进制转格雷码</span><br><span class="hljs-keyword">always</span> @（<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rst_n) <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">if</span>(rst_n==<span class="hljs-number">1&#x27;b0</span>) ptr&lt;=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>ptr &lt;= bnext;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="3-2-第二种格雷码计数器"><a href="#3-2-第二种格雷码计数器" class="headerlink" title="3.2 第二种格雷码计数器"></a>3.2 第二种格雷码计数器</h4><p>用寄存器保存二进制码，去除格雷码到二进制的转换逻辑。</p><p>减小寄存器之间的组合逻辑长度，可以增加频率，特别是在FPGA中。</p><p>如下图：</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/asynchronous/gray2.png"></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> clk,rst_n;<br><span class="hljs-keyword">wire</span> [n-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] bnext,gnext;<br><span class="hljs-keyword">wire</span> inc,full; <span class="hljs-comment">// 写时钟域的格雷码转换器</span><br><span class="hljs-keyword">reg</span> [n-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] ptr; <span class="hljs-comment">//输出的n位格雷码</span><br><span class="hljs-keyword">reg</span> [n-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] bin;<br><span class="hljs-keyword">integer</span> i;<br><br><span class="hljs-keyword">assign</span> bnext = bnext+(inc &amp;&amp; !full)?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br><span class="hljs-keyword">assign</span> gnext = (bnext&gt;&gt;<span class="hljs-number">1</span>) ^ bnext; <span class="hljs-comment">//二进制转格雷码</span><br><span class="hljs-keyword">always</span> @（<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rst_n) <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">if</span>(rst_n==<span class="hljs-number">1&#x27;b0</span>) &#123;ptr,bin&#125;&lt;=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> &#123;ptr,bin&#125; &lt;=&#123;gnext,bnext&#125;;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="4-fifo结构图"><a href="#4-fifo结构图" class="headerlink" title="4. fifo结构图"></a>4. fifo结构图</h3><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/asynchronous/fifo.png"></p><h3 id="5-空满标志位"><a href="#5-空满标志位" class="headerlink" title="5. 空满标志位"></a>5. 空满标志位</h3><p><strong>空标志位在读时钟域产生；满标志位在写时钟域产生。</strong></p><h4 id="5-1-空标志位"><a href="#5-1-空标志位" class="headerlink" title="5.1 空标志位"></a>5.1 空标志位</h4><p>地址比实际地址增加一位。</p><p>读时钟域的格雷码读地址 与 同步过来的格雷码写地址相同，说明满</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> rempty_val = (rgraynext == rq2_wptr); <span class="hljs-comment">// 读时钟域的格雷码读地址 与 同步过来的格雷码写地址相同，说明满</span><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> rclk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rrst_n) <span class="hljs-comment">// 读时钟</span><br><span class="hljs-keyword">if</span> (!rrst_n) rempty &lt;= <span class="hljs-number">1&#x27;b1</span>;<br><span class="hljs-keyword">else</span> rempty &lt;= rempty_val;<br></code></pre></td></tr></table></figure><h4 id="5-2-满标志位"><a href="#5-2-满标志位" class="headerlink" title="5.2 满标志位"></a>5.2 满标志位</h4><p>地址比实际地址增加一位。</p><p>根据格雷码的特性，写时钟域与的格雷码写地址与同步过来的格雷码读地址相比，最高两位都不同，其他位相同，说明满了。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> wfull_val = (wgraynext==&#123;~wq2_rptr[ADDRSIZE:ADDRSIZE-<span class="hljs-number">1</span>],wq2_rptr[ADDRSIZE-<span class="hljs-number">2</span>:<span class="hljs-number">0</span>]&#125;);<br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> wclk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> wrst_n)<br><span class="hljs-keyword">if</span> (!wrst_n) wfull &lt;= <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">else</span> wfull &lt;= wfull_val;<br></code></pre></td></tr></table></figure><h4 id="5-3-不同时钟频率的考虑"><a href="#5-3-不同时钟频率的考虑" class="headerlink" title="5.3 不同时钟频率的考虑"></a>5.3 不同时钟频率的考虑</h4><p><strong>问题一：快时钟是慢时钟的两倍，那么快域地址变化两次，慢时钟域采样一次，前后采样值变化了两次，会产生多位同步的问题吗？</strong></p><p>​    不会。快时钟域第一次改变一位，比如从A到B，慢时钟域没有采样，当快时钟域改变第二次B到C之后，慢时钟域才采样，虽然这期间快时钟域的地址从A到C变了两次，但是慢时钟域只看到第二次B到C，只跳变了一位，因此不会产生多位同步问题。</p><p><strong>问题二：快时钟域是否会引起full+1的情况——写溢出，或者empty+1——读溢出？</strong></p><p>​    不会。对于满是在写时钟域产生，如果写时钟比读时钟快，如果waddr追上raddr，那么full有效，此时不能再写了，也就不会产生full+1情况。对于空是在写时钟域产生，如果读时钟比写时钟快，如果raddr赶上waddr，那么就不能再读，也就不会产生empty+1.</p><h4 id="5-4-空满标志位取消"><a href="#5-4-空满标志位取消" class="headerlink" title="5.4 空满标志位取消"></a>5.4 空满标志位取消</h4><p>​    空满的set是立即生效的。比如读时钟域中，将采样到的写时钟域的格雷码写地址 与当前的读地址比较，如果相等，则立马使empty有效；full类似。<strong>但是读写标志位clear是有延迟的。</strong></p><p>​    当empty有效的时候，读时钟域采样的写地址与读地址相同，如果此时写入数据，那么在写时钟域里写地址是增加的，但是这个增加了的写地址需要两个读时钟的同步才能让读时钟域里的地址比较器看到，所以empty的clear有<strong>两个读时钟周期</strong>的延迟；同样full的clear有<strong>两个写时钟周期</strong>的延迟。</p><p>​    但这不会使FIFO发生功能错误，可忽略。</p><h4 id="5-5-reset时候地址多位跳变"><a href="#5-5-reset时候地址多位跳变" class="headerlink" title="5.5 reset时候地址多位跳变"></a>5.5 reset时候地址多位跳变</h4><p>没影响，因为reset就表明FIFO里的数据是无效的，此时不对FIFO进行读写。</p><h3 id="6-代码"><a href="#6-代码" class="headerlink" title="6. 代码"></a>6. 代码</h3><p>这些代码是Cummings论文中给的。</p><h4 id="6-1-顶层"><a href="#6-1-顶层" class="headerlink" title="6.1 顶层"></a>6.1 顶层</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> fifo1 #(<span class="hljs-keyword">parameter</span> DSIZE = <span class="hljs-number">8</span>,<br><span class="hljs-keyword">parameter</span> ASIZE = <span class="hljs-number">4</span>)<br>(<span class="hljs-keyword">output</span> [DSIZE-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] rdata,<br><span class="hljs-keyword">output</span> wfull,<br><span class="hljs-keyword">output</span> rempty,<br><span class="hljs-keyword">input</span> [DSIZE-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] wdata,<br><span class="hljs-keyword">input</span> winc, wclk, wrst_n,<br><span class="hljs-keyword">input</span> rinc, rclk, rrst_n);<br><span class="hljs-keyword">wire</span> [ASIZE-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] waddr, raddr;<br><span class="hljs-keyword">wire</span> [ASIZE:<span class="hljs-number">0</span>] wptr, rptr, wq2_rptr, rq2_wptr;<br>sync_r2w sync_r2w (<span class="hljs-variable">.wq2_rptr</span>(wq2_rptr), <span class="hljs-variable">.rptr</span>(rptr),<br><span class="hljs-variable">.wclk</span>(wclk), <span class="hljs-variable">.wrst_n</span>(wrst_n));<br>sync_w2r sync_w2r (<span class="hljs-variable">.rq2_wptr</span>(rq2_wptr), <span class="hljs-variable">.wptr</span>(wptr),<br><span class="hljs-variable">.rclk</span>(rclk), <span class="hljs-variable">.rrst_n</span>(rrst_n));<br>fifomem <span class="hljs-variable">#(DSIZE, ASIZE)</span> fifomem<br>(<span class="hljs-variable">.rdata</span>(rdata), <span class="hljs-variable">.wdata</span>(wdata),<br><span class="hljs-variable">.waddr</span>(waddr), <span class="hljs-variable">.raddr</span>(raddr),<br><span class="hljs-variable">.wclken</span>(winc), <span class="hljs-variable">.wfull</span>(wfull),<br><span class="hljs-variable">.wclk</span>(wclk));<br>rptr_empty <span class="hljs-variable">#(ASIZE)</span> rptr_empty<br>(<span class="hljs-variable">.rempty</span>(rempty),<br><span class="hljs-variable">.raddr</span>(raddr),<br><span class="hljs-variable">.rptr</span>(rptr), <span class="hljs-variable">.rq2_wptr</span>(rq2_wptr),<br><span class="hljs-variable">.rinc</span>(rinc), <span class="hljs-variable">.rclk</span>(rclk),<br><span class="hljs-variable">.rrst_n</span>(rrst_n));<br>wptr_full <span class="hljs-variable">#(ASIZE)</span> wptr_full<br>(<span class="hljs-variable">.wfull</span>(wfull), <span class="hljs-variable">.waddr</span>(waddr),<br><span class="hljs-variable">.wptr</span>(wptr), <span class="hljs-variable">.wq2_rptr</span>(wq2_rptr),<br><span class="hljs-variable">.winc</span>(winc), <span class="hljs-variable">.wclk</span>(wclk),<br><span class="hljs-variable">.wrst_n</span>(wrst_n));<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h4 id="6-2-内存读写模块"><a href="#6-2-内存读写模块" class="headerlink" title="6.2 内存读写模块"></a>6.2 内存读写模块</h4><p>​    读数据是直接从mem中读，不需要时钟。读地址A指示的是下一次要读的地址——此时FIFO不为空,读A地址是有效的。当前rdata信号上保存的是下一次要读的数据。如果外部读时钟域打算读数据，那么给一个读有效rinc，在rclk上升沿就可以直接把rdata取走，在rinc上升沿FIFO内部会根据A+1地址判断是否empty。（可以参考3.2节）。</p><p>​    写数据winc有效时，下一个写时钟沿wclk要写入数据。满标志表示如果在下一个时钟沿写数据，就写到读地址处（读写地址相同）。如果满，则下一个时钟沿不能写。所以在下一个写时钟沿到来时要判断满标志，如果满了，则不能写。</p><p>​    同样，读地址表示下一个读时钟沿要读的数据，空表示下一个时钟沿是否可以读。对于读数据的设备，它需要在读的时候判断是否空了，至于FIFO的rdata输出端则不需要进行empty判断，FIFO将下一次要读的数据放在rdata处，如果读数据的设备要读，就在rclk时钟沿读就行了。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> fifomem #(<span class="hljs-keyword">parameter</span> DATASIZE = <span class="hljs-number">8</span>, <span class="hljs-comment">// Memory data word width</span><br><span class="hljs-keyword">parameter</span> ADDRSIZE = <span class="hljs-number">4</span>) <span class="hljs-comment">// Number of mem address bits</span><br>(<span class="hljs-keyword">output</span> [DATASIZE-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] rdata,<br><span class="hljs-keyword">input</span> [DATASIZE-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] wdata,<br><span class="hljs-keyword">input</span> [ADDRSIZE-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] waddr, raddr,<br><span class="hljs-keyword">input</span> wclken, wfull, wclk);<br><span class="hljs-meta">`<span class="hljs-keyword">ifdef</span> VENDORRAM</span><br><span class="hljs-comment">// instantiation of a vendor&#x27;s dual-port RAM</span><br>    vendor_ram mem (<span class="hljs-variable">.dout</span>(rdata), <span class="hljs-variable">.din</span>(wdata),  <span class="hljs-comment">//这一块不用管</span><br><span class="hljs-variable">.waddr</span>(waddr), <span class="hljs-variable">.raddr</span>(raddr),<br><span class="hljs-variable">.wclken</span>(wclken),<br><span class="hljs-variable">.wclken_n</span>(wfull), <span class="hljs-variable">.clk</span>(wclk));<br><span class="hljs-meta">`<span class="hljs-keyword">else</span></span><br><span class="hljs-comment">// RTL Verilog memory model</span><br><span class="hljs-keyword">localparam</span> DEPTH = <span class="hljs-number">1</span>&lt;&lt;ADDRSIZE; <span class="hljs-comment">//将地址位数转化成FIFO深度</span><br><span class="hljs-keyword">reg</span> [DATASIZE-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] mem [<span class="hljs-number">0</span>:DEPTH-<span class="hljs-number">1</span>];<br><span class="hljs-keyword">assign</span> rdata = mem[raddr]; <span class="hljs-comment">//直接读，empty标志位影响raddr的累加</span><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> wclk)<br>    <span class="hljs-keyword">if</span> (wclken &amp;&amp; !wfull) mem[waddr] &lt;= wdata;<span class="hljs-comment">//写需要判断full，并且在时钟沿处写</span><br><span class="hljs-meta">`<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h4 id="6-3-读地址到写时钟域同步"><a href="#6-3-读地址到写时钟域同步" class="headerlink" title="6.3 读地址到写时钟域同步"></a>6.3 读地址到写时钟域同步</h4><p><strong>写时钟控制，打两拍</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> sync_r2w #(<span class="hljs-keyword">parameter</span> ADDRSIZE = <span class="hljs-number">4</span>)<br>(<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [ADDRSIZE:<span class="hljs-number">0</span>] wq2_rptr,<br><span class="hljs-keyword">input</span> [ADDRSIZE:<span class="hljs-number">0</span>] rptr,<br><span class="hljs-keyword">input</span> wclk, wrst_n);<br><span class="hljs-keyword">reg</span> [ADDRSIZE:<span class="hljs-number">0</span>] wq1_rptr;<br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> wclk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> wrst_n)<br>    <span class="hljs-keyword">if</span> (!wrst_n) &#123;wq2_rptr,wq1_rptr&#125; &lt;= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> &#123;wq2_rptr,wq1_rptr&#125; &lt;= &#123;wq1_rptr,rptr&#125;;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h4 id="6-4-写地址到读时钟域同步"><a href="#6-4-写地址到读时钟域同步" class="headerlink" title="6.4 写地址到读时钟域同步"></a>6.4 写地址到读时钟域同步</h4><p><strong>读时钟控制，打两拍</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> sync_w2r #(<span class="hljs-keyword">parameter</span> ADDRSIZE = <span class="hljs-number">4</span>)<br>(<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [ADDRSIZE:<span class="hljs-number">0</span>] rq2_wptr,<br><span class="hljs-keyword">input</span> [ADDRSIZE:<span class="hljs-number">0</span>] wptr,<br><span class="hljs-keyword">input</span> rclk, rrst_n);<br><span class="hljs-keyword">reg</span> [ADDRSIZE:<span class="hljs-number">0</span>] rq1_wptr;<br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> rclk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rrst_n)<br>    <span class="hljs-keyword">if</span> (!rrst_n) &#123;rq2_wptr,rq1_wptr&#125; &lt;= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> &#123;rq2_wptr,rq1_wptr&#125; &lt;= &#123;rq1_wptr,wptr&#125;;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h4 id="6-5-空标志位产生"><a href="#6-5-空标志位产生" class="headerlink" title="6.5 空标志位产生"></a>6.5 空标志位产生</h4><p>产生空标志位、n-1位当前的二进制读地址、n位格雷码读地址</p><p>产生空标志位的结构框图如下：</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/asynchronous/gray00.png"></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">module</span> rptr_empty #(<span class="hljs-keyword">parameter</span> ADDRSIZE = <span class="hljs-number">4</span>)<br>(<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> rempty,<br><span class="hljs-keyword">output</span> [ADDRSIZE-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] raddr,<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [ADDRSIZE :<span class="hljs-number">0</span>] rptr,<br><span class="hljs-keyword">input</span> [ADDRSIZE :<span class="hljs-number">0</span>] rq2_wptr,<br><span class="hljs-keyword">input</span> rinc, rclk, rrst_n);<br><span class="hljs-keyword">reg</span> [ADDRSIZE:<span class="hljs-number">0</span>] rbin;<br><span class="hljs-keyword">wire</span> [ADDRSIZE:<span class="hljs-number">0</span>] rgraynext, rbinnext;<br><span class="hljs-keyword">wire</span> rempty_val;    <br><span class="hljs-comment">//-------------------</span><br><span class="hljs-comment">// GRAYSTYLE2 pointer</span><br><span class="hljs-comment">//-------------------</span><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> rclk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rrst_n)  <span class="hljs-comment">//格雷码计数器的第二种写法</span><br><span class="hljs-keyword">if</span> (!rrst_n) &#123;rbin, rptr&#125; &lt;= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> &#123;rbin, rptr&#125; &lt;= &#123;rbinnext, rgraynext&#125;;<br><span class="hljs-comment">// Memory read-address pointer (okay to use binary to address memory)</span><br><span class="hljs-keyword">assign</span> raddr = rbin[ADDRSIZE-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];<span class="hljs-comment">//给到memory模块</span><br><span class="hljs-keyword">assign</span> rbinnext = rbin + (rinc &amp; ~rempty);<br><span class="hljs-keyword">assign</span> rgraynext = (rbinnext&gt;&gt;<span class="hljs-number">1</span>) ^ rbinnext;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-comment">// FIFO empty when the next rptr == synchronized wptr or on reset</span><br><span class="hljs-comment">//---------------------------------------------------------------</span><br>    <span class="hljs-keyword">assign</span> rempty_val = (rgraynext == rq2_wptr);<span class="hljs-comment">//空判断是根据下一次要读的地址来判断的</span><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> rclk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rrst_n)<br>    <span class="hljs-keyword">if</span> (!rrst_n) rempty &lt;= <span class="hljs-number">1&#x27;b1</span>;<br>    <span class="hljs-keyword">else</span> rempty &lt;= rempty_val;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h4 id="6-6-满标志产生"><a href="#6-6-满标志产生" class="headerlink" title="6.6 满标志产生"></a>6.6 满标志产生</h4><p>产生满标志、n-1位当前写地址、n位格雷码写地址</p><p>产生满标志位的结构框图如下：</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/asynchronous/gray11.png"></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> wptr_full #(<span class="hljs-keyword">parameter</span> ADDRSIZE = <span class="hljs-number">4</span>)<br>(<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> wfull,<br><span class="hljs-keyword">output</span> [ADDRSIZE-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] waddr,<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [ADDRSIZE :<span class="hljs-number">0</span>] wptr,<br><span class="hljs-keyword">input</span> [ADDRSIZE :<span class="hljs-number">0</span>] wq2_rptr,<br><span class="hljs-keyword">input</span> winc, wclk, wrst_n);<br><span class="hljs-keyword">reg</span> [ADDRSIZE:<span class="hljs-number">0</span>] wbin;<br><span class="hljs-keyword">wire</span> [ADDRSIZE:<span class="hljs-number">0</span>] wgraynext, wbinnext;<br><span class="hljs-keyword">wire</span> wfull_val;    <br><span class="hljs-comment">// GRAYSTYLE2 pointer</span><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> wclk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> wrst_n)<br><span class="hljs-keyword">if</span> (!wrst_n) &#123;wbin, wptr&#125; &lt;= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> &#123;wbin, wptr&#125; &lt;= &#123;wbinnext, wgraynext&#125;;<br><span class="hljs-comment">// Memory write-address pointer (okay to use binary to address memory)</span><br><span class="hljs-keyword">assign</span> waddr = wbin[ADDRSIZE-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];<br><span class="hljs-keyword">assign</span> wbinnext = wbin + (winc &amp; ~wfull);<br><span class="hljs-keyword">assign</span> wgraynext = (wbinnext&gt;&gt;<span class="hljs-number">1</span>) ^ wbinnext;<br><span class="hljs-comment">//------------------------------------------------------------------</span><br><span class="hljs-comment">// Simplified version of the three necessary full-tests:</span><br><span class="hljs-comment">// assign wfull_val=((wgnext[ADDRSIZE] !=wq2_rptr[ADDRSIZE] ) &amp;&amp;</span><br><span class="hljs-comment">// (wgnext[ADDRSIZE-1] !=wq2_rptr[ADDRSIZE-1]) &amp;&amp;</span><br><span class="hljs-comment">// (wgnext[ADDRSIZE-2:0]==wq2_rptr[ADDRSIZE-2:0]));</span><br><span class="hljs-comment">//------------------------------------------------------------------</span><br><span class="hljs-keyword">assign</span> wfull_val = (wgraynext==&#123;~wq2_rptr[ADDRSIZE:ADDRSIZE-<span class="hljs-number">1</span>],wq2_rptr[ADDRSIZE-<span class="hljs-number">2</span>:<span class="hljs-number">0</span>]&#125;);<br>    <span class="hljs-comment">// 空判断是根据下一次要写的地址判断的。</span><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> wclk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> wrst_n)<br><span class="hljs-keyword">if</span> (!wrst_n) wfull &lt;= <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">else</span> wfull &lt;= wfull_val;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>Asynchronous</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>Asynchronous</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV——接口</title>
    <link href="/2019/07/15/Verification/SystemVerilog/SV%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3/"/>
    <url>/2019/07/15/Verification/SystemVerilog/SV%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="1-Interface概念"><a href="#1-Interface概念" class="headerlink" title="1. Interface概念"></a>1. Interface概念</h3><p>System Verilog中引入了接口定义，接口与module 等价的定义，是要在其他的接口、module中直接定义，不能写在块语句中，跟class是不同的。</p><p>​    接口是将一组线捆绑起来，可以将接口传递给module。</p><h3 id="2-接口的优点"><a href="#2-接口的优点" class="headerlink" title="2.  接口的优点"></a>2.  接口的优点</h3><p>一）通过接口在module之间或内部进行信号，模块的输入列表就是一个接口，这样简单，避免手动连线的错误。</p><p>二）如果需要增加模块的IO，只需要在接口中增加，不需要改变模块的输入列表，防止输入错误、少改了哪个模块的列表。</p><p>三）在UVM 中需要在不同的class之间传递信号，用接口的话，传递一组信号只需要uvm_config_db一个接口就可以了，如果不用接口，那么就需要好多条uvm_config_db语句。</p><p>四）接口中可以定义一些initial（生成时钟），always块，任务，函数，类的句柄。</p><h3 id="3-定义接口"><a href="#3-定义接口" class="headerlink" title="3. 定义接口"></a>3. 定义接口</h3><p>可以在接口中定义一些信号、函数、任务、class对象，也可以有always，initial语句块。</p><p>比如可以在initial块中生成时钟clk。</p><h4 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h4><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">interface</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">input</span> <span class="hljs-keyword">bit</span> clk);<br><span class="hljs-keyword">logic</span> data;<br><span class="hljs-keyword">logic</span> valid;<br><span class="hljs-keyword">logic</span> addr;<br><span class="hljs-keyword">endinterface</span><br></code></pre></td></tr></table></figure><h4 id="3-2-modport"><a href="#3-2-modport" class="headerlink" title="3.2 modport"></a>3.2 modport</h4><p>可以用modport将接口中的信号分组。</p><p>比如总线接口中，master、slave、arbiter需要的信号是不同的，输入输出也不同。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">interface</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">input</span> <span class="hljs-keyword">bit</span> clk);<br>    <span class="hljs-keyword">logic</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] data;<br><span class="hljs-keyword">logic</span> valid;<br>    <span class="hljs-keyword">logic</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] addr;<br><span class="hljs-keyword">logic</span> request;<br><span class="hljs-keyword">logic</span> grant;<br><span class="hljs-keyword">logic</span> command;<br><span class="hljs-keyword">logic</span> ready;<br><span class="hljs-keyword">modport</span> MASTER(<span class="hljs-keyword">output</span> request,addr,command);<br><span class="hljs-keyword">modport</span> SLAVE(<span class="hljs-keyword">input</span> request,addr,command,<span class="hljs-keyword">output</span> ready);<br><span class="hljs-keyword">modport</span> ARBITER(<span class="hljs-keyword">input</span> request,<span class="hljs-keyword">output</span> grant);<br><span class="hljs-keyword">endinterface</span><br><span class="hljs-keyword">module</span> Master (<span class="hljs-keyword">if</span><span class="hljs-variable">.MASTER</span> if_u);<br>...<br><span class="hljs-keyword">endmodule</span><br><span class="hljs-keyword">module</span> test;<br>    <span class="hljs-keyword">if</span> if_u;<br>    Master m_u(if_u<span class="hljs-variable">.MASTER</span>);<br><span class="hljs-keyword">endmodule</span>    <br></code></pre></td></tr></table></figure><h3 id="4-激励时序"><a href="#4-激励时序" class="headerlink" title="4. 激励时序"></a>4. 激励时序</h3><p>测试平台需要和设计之间的时序密切配合。</p><p>​    比如在同一个时间片内，一个信号需要被同时写入和读取，那么采样到新值还是旧值？非阻塞赋值可以解决这个问题，值的计算在active区域，值的更新在NBA区域——<strong>采样到的是旧值。</strong></p><h4 id="4-1-时钟块控制同步信号的时序"><a href="#4-1-时钟块控制同步信号的时序" class="headerlink" title="4.1 时钟块控制同步信号的时序"></a>4.1 时钟块控制同步信号的时序</h4><p>在接口中定义<strong>时钟块</strong>，时钟块中的任何信号都相对于时钟同步驱动和采样。<strong>时钟块大都在测试平台中使用。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">interface</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">input</span> <span class="hljs-keyword">bit</span> clk);<br>    <span class="hljs-keyword">logic</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] data;<br><span class="hljs-keyword">logic</span> valid;<br>    <span class="hljs-keyword">logic</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] addr;<br><span class="hljs-keyword">clocking</span> cb@(<span class="hljs-keyword">posedge</span> clk);<br><span class="hljs-keyword">input</span> valid;<br><span class="hljs-keyword">input</span> data;<br><span class="hljs-keyword">input</span> addr;<br><span class="hljs-keyword">endclocking</span><br>    <span class="hljs-keyword">modport</span> TEST(<span class="hljs-keyword">clocking</span> cb);<br>    <span class="hljs-keyword">modport</span> DUT(<span class="hljs-keyword">input</span> valid ,<span class="hljs-keyword">input</span> data);<br><span class="hljs-keyword">endinterface</span><br></code></pre></td></tr></table></figure><p>​    一个接口中可以有多个时钟块，但每个时钟块只有一个时钟表达式。如@(posedge clk)定义了单时钟；@(clk)定义了DDR时钟（双数据率，两个沿）。</p><h4 id="4-2-logic还是wire"><a href="#4-2-logic还是wire" class="headerlink" title="4.2 logic还是wire"></a>4.2 logic还是wire</h4><p>​    在测试平台中，如果用过程赋值语句驱动接口中的信号，那么信号要在接口中定义为logic，如果是连续赋值驱动，定义成wire。</p><p>定义成logic的一个好处是，如果多个信号驱动logic，那么编译器会报错，这样你就知道写错了，如果是wire，这个错误就隐藏了。</p><h4 id="4-3-对测试平台和DUT中事件的调度"><a href="#4-3-对测试平台和DUT中事件的调度" class="headerlink" title="4.3 对测试平台和DUT中事件的调度"></a>4.3 对测试平台和DUT中事件的调度</h4><p>​    如果没有用时钟块，测试平台对DUT的驱动和采样存在竞争，这是因为测试平台的事件和DUT的事件混合在同一个时间片中。</p><p>​    SV中将测试平台中的事件和DUT中的事件分离。</p><p>时间片划分：</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/07/SV/if0.png"></p><p>SV的主要调度区域：</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/07/SV/if1.png"></p><h4 id="4-4-设计和测试平台之间的时序"><a href="#4-4-设计和测试平台之间的时序" class="headerlink" title="4.4 设计和测试平台之间的时序"></a>4.4 设计和测试平台之间的时序</h4><p><strong>时钟块（测试平台）在#1step延时之后采样DUT，也就是采样上一个时间片postponed区域的数据。</strong>也就是前面讲的采样旧值。</p><p><strong>时钟块（测试平台）在#0延时之后驱动DUT信号。0延迟说明还在同一个time slot，DUT能够捕捉到变化。</strong></p><p>更细致的时间片划分：</p><table><thead><tr><th>time slot</th><th></th></tr></thead><tbody><tr><td>active</td><td>design</td></tr><tr><td>inactive</td><td>显示0延迟阻塞赋值；</td></tr><tr><td>observed</td><td>SVA</td></tr><tr><td>reactive</td><td>SV</td></tr><tr><td>postponed</td><td>SV 采样</td></tr></tbody></table><h3 id="5-接口采样和驱动信号的时序。"><a href="#5-接口采样和驱动信号的时序。" class="headerlink" title="5. 接口采样和驱动信号的时序。"></a>5. 接口采样和驱动信号的时序。</h3><p>为了同步接口中的信号，可以在时钟沿采样或者驱动接口信号。</p><p>可以在接口中定义时钟块来同步接口信号：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">interface</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">input</span> <span class="hljs-keyword">bit</span> clk);<br><span class="hljs-keyword">logic</span> data;<br><span class="hljs-keyword">logic</span> valid;<br><span class="hljs-keyword">logic</span> addr;<br><span class="hljs-keyword">clocking</span> cb@(<span class="hljs-keyword">posedge</span> clk);<br><span class="hljs-keyword">input</span> valid;<br><span class="hljs-keyword">input</span> data;<br><span class="hljs-keyword">input</span> addr;<br><span class="hljs-keyword">endclocking</span><br>    <span class="hljs-keyword">modport</span> TEST(<span class="hljs-keyword">clocking</span> cb);<br>    <span class="hljs-keyword">modport</span> DUT(<span class="hljs-keyword">input</span> valid ,<span class="hljs-keyword">input</span> data);<br><span class="hljs-keyword">endinterface</span><br></code></pre></td></tr></table></figure><p><strong>在测试平台中的信号才需要同步</strong>。</p><h4 id="5-1-接口信号采样时序"><a href="#5-1-接口信号采样时序" class="headerlink" title="5.1 接口信号采样时序"></a>5.1 接口信号采样时序</h4><p>如果时钟块中的信号采样DUT中的信号，采样的是上一个时间片（time slot）postponed区域的数据。</p><p>即如果DUT信号在时钟沿发生0-1跳变，那么采样到0。</p><p>DUT接口想要驱动TEST接口中时钟块里的信号，需要线给DUT接口信号赋值：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> dut(<span class="hljs-keyword">if</span><span class="hljs-variable">.DUT</span> if0);<br>....<br>#<span class="hljs-number">10</span> if0<span class="hljs-variable">.valid</span> = <span class="hljs-number">1</span>;<br>#<span class="hljs-number">10</span> if0<span class="hljs-variable">.valid</span> = <span class="hljs-number">2</span>;<br>....<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/07/SV/if2.png"></p><h4 id="5-2-接口信号驱动时序"><a href="#5-2-接口信号驱动时序" class="headerlink" title="5.2 接口信号驱动时序"></a>5.2 接口信号驱动时序</h4><p>如果时钟块驱动DUT信号，值会立即传入到设计中。</p><p>即如果时钟块中的信号在时钟沿发生0-1跳变，则时钟沿之后DUT中为1。</p><p>时钟块想要驱动DUT，需要在testbench给时钟块中的信号赋值，在tb中驱动时钟块中的信号需要同步驱动，用“&lt;&#x3D;”符号。时钟块中的信号驱动采样</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">program</span> tb(<span class="hljs-keyword">if</span><span class="hljs-variable">.TEST</span> if1);<br>...<br>#<span class="hljs-number">10</span> if1<span class="hljs-variable">.cb</span><span class="hljs-variable">.valid</span> &lt;= <span class="hljs-number">1</span>;<br>#<span class="hljs-number">10</span> if1<span class="hljs-variable">.cb</span><span class="hljs-variable">.valid</span> &lt;= <span class="hljs-number">0</span>;<br>...<br><span class="hljs-keyword">endprogram</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/07/SV/if3.png"></p><h3 id="6-使用虚接口"><a href="#6-使用虚接口" class="headerlink" title="6. 使用虚接口"></a>6. 使用虚接口</h3><p>之前介绍的接口都是跟module一样来描述硬件的；在SV中有面向对象的概念，在class里面使用虚接口——virtual interface。</p><p>虚接口是一个物理接口的句柄（handler），同这个句柄来访问硬件接口。</p><p><strong>虚接口是唯一链接动态对象和静态模块、接口的一种机制。</strong></p><h4 id="6-1-在测试平台中使用接口"><a href="#6-1-在测试平台中使用接口" class="headerlink" title="6.1 在测试平台中使用接口"></a>6.1 在测试平台中使用接口</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">interface</span> inf; <span class="hljs-comment">//定义接口</span><br>...<br><span class="hljs-keyword">endinterface</span><br><span class="hljs-keyword">program</span> test(inf if0); <span class="hljs-comment">// 接口传入测试平台</span><br>driver drv;<br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>        drv = <span class="hljs-keyword">new</span>(if0); <span class="hljs-comment">// 接口传给driver对象</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endprogram</span><br><span class="hljs-keyword">class</span> driver;<br><span class="hljs-keyword">virtual</span> vif;  <span class="hljs-comment">// 在class中为虚接口</span><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(inf i);<br>vif=i;<br><span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br><span class="hljs-keyword">module</span> top;<br>    inf inf0();  <span class="hljs-comment">// 例化接口</span><br>    test t1(inf0);<br>    dut d1(inf0);<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>也可以在tb中跨模块引用XMR（cross module reference）接口</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">program</span> test(); <span class="hljs-comment">//没有接口参数</span><br><span class="hljs-keyword">virtual</span> inf if0=top<span class="hljs-variable">.inf0</span>;<span class="hljs-comment">//top是顶层模块</span><br>...<br><span class="hljs-keyword">endprogram</span><br><span class="hljs-keyword">module</span> top;<br>    inf inf0();  <span class="hljs-comment">// 例化接口</span><br>    test t1(); <span class="hljs-comment">// tb无接口列表</span><br>    dut d1(inf0);<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h4 id="6-2-使用端口传递接口数组"><a href="#6-2-使用端口传递接口数组" class="headerlink" title="6.2 使用端口传递接口数组"></a>6.2 使用端口传递接口数组</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">interface</span> inf(<span class="hljs-keyword">input</span> clk);<br>...<br><span class="hljs-keyword">endinterface</span><br><span class="hljs-keyword">parameter</span> NUM=<span class="hljs-number">10</span>;<br><span class="hljs-keyword">module</span> top;<br>    inf xi[NUM](clk); <span class="hljs-comment">// 顶层例化多个接口,接口名后跟个数</span><br>    test t1(xi);<span class="hljs-comment">// 接口作为参数</span><br>dut...<br><span class="hljs-keyword">endmodule</span><br><span class="hljs-keyword">program</span> test(inf xi[NUM]); <span class="hljs-comment">// 接口参数列表</span><br><span class="hljs-keyword">virtual</span> inf vxi[NUM];<br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>vxi=xi;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endprogram</span><br></code></pre></td></tr></table></figure><p>也可以用跨模块引用。</p><h3 id="7-接口中的代码"><a href="#7-接口中的代码" class="headerlink" title="7. 接口中的代码"></a>7. 接口中的代码</h3><p><strong>接口中可以定义信号、函数、任务、class对象，也可以有always，initial语句块。</strong></p><p>下面给一个在《UVMPrimer》中的例子：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">interface</span> tinyalu_bfm;<br>   <span class="hljs-keyword">import</span> tinyalu_pkg::*;<br><br>   <span class="hljs-keyword">byte</span>         <span class="hljs-keyword">unsigned</span>        A;<br>   <span class="hljs-keyword">byte</span>         <span class="hljs-keyword">unsigned</span>        B;<br>   <span class="hljs-keyword">bit</span>          clk;<br>   <span class="hljs-keyword">bit</span>          reset_n;<br>   <span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>]   op;<br>   <span class="hljs-keyword">bit</span>          start;<br>   <span class="hljs-keyword">wire</span>         done;<br>   <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]  result;<br>   operation_t  op_set;<br><br>   <span class="hljs-keyword">assign</span> op = op_set;<br><br>   <span class="hljs-keyword">task</span> reset_alu();<br>      reset_n = <span class="hljs-number">1&#x27;b0</span>;<br>      @(<span class="hljs-keyword">negedge</span> clk);<br>      @(<span class="hljs-keyword">negedge</span> clk);<br>      reset_n = <span class="hljs-number">1&#x27;b1</span>;<br>      start = <span class="hljs-number">1&#x27;b0</span>;<br>   <span class="hljs-keyword">endtask</span> : reset_alu<br>   <br>   <span class="hljs-keyword">task</span> send_op(<span class="hljs-keyword">input</span> <span class="hljs-keyword">byte</span> iA, <span class="hljs-keyword">input</span> <span class="hljs-keyword">byte</span> iB, <span class="hljs-keyword">input</span> operation_t iop, <span class="hljs-keyword">shortint</span> result);<br>      <span class="hljs-keyword">if</span> (iop == rst_op) <span class="hljs-keyword">begin</span><br>         @(<span class="hljs-keyword">posedge</span> clk);<br>         reset_n = <span class="hljs-number">1&#x27;b0</span>;<br>         start = <span class="hljs-number">1&#x27;b0</span>;<br>         @(<span class="hljs-keyword">posedge</span> clk);<br>         #<span class="hljs-number">1</span>;<br>         reset_n = <span class="hljs-number">1&#x27;b1</span>;<br>      <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>         @(<span class="hljs-keyword">negedge</span> clk);<br>         op_set = iop;<br>         A = iA;<br>         B = iB;<br>         start = <span class="hljs-number">1&#x27;b1</span>;<br>         <span class="hljs-keyword">if</span> (iop == no_op) <span class="hljs-keyword">begin</span><br>            @(<span class="hljs-keyword">posedge</span> clk);<br>            #<span class="hljs-number">1</span>;<br>            start = <span class="hljs-number">1&#x27;b0</span>;           <br>         <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>            <span class="hljs-keyword">do</span><br>              @(<span class="hljs-keyword">negedge</span> clk);<br>            <span class="hljs-keyword">while</span> (done == <span class="hljs-number">0</span>);<br>            start = <span class="hljs-number">1&#x27;b0</span>;<br>         <span class="hljs-keyword">end</span><br>      <span class="hljs-keyword">end</span> <span class="hljs-comment">// else: !if(iop == rst_op)</span><br>      <br>   <span class="hljs-keyword">endtask</span> : send_op<br>   <br>   command_monitor command_monitor_h;<br><br>   <span class="hljs-keyword">function</span> operation_t op2enum();<br>      <span class="hljs-keyword">case</span>(op)<br>        <span class="hljs-number">3&#x27;b000</span> : <span class="hljs-keyword">return</span> no_op;<br>        <span class="hljs-number">3&#x27;b001</span> : <span class="hljs-keyword">return</span> add_op;<br>        <span class="hljs-number">3&#x27;b010</span> : <span class="hljs-keyword">return</span> and_op;<br>        <span class="hljs-number">3&#x27;b011</span> : <span class="hljs-keyword">return</span> xor_op;<br>        <span class="hljs-number">3&#x27;b100</span> : <span class="hljs-keyword">return</span> mul_op;<br>        <span class="hljs-keyword">default</span> : <span class="hljs-built_in">$fatal</span>(<span class="hljs-string">&quot;Illegal operation on op bus&quot;</span>);<br>      <span class="hljs-keyword">endcase</span> <span class="hljs-comment">// case (op)</span><br>   <span class="hljs-keyword">endfunction</span> : op2enum<br><br><br>   <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span> : op_monitor<br>      <span class="hljs-keyword">static</span> <span class="hljs-keyword">bit</span> in_command = <span class="hljs-number">0</span>;<br>      command_s command;<br>      <span class="hljs-keyword">if</span> (start) <span class="hljs-keyword">begin</span> : start_high<br>        <span class="hljs-keyword">if</span> (!in_command) <span class="hljs-keyword">begin</span> : new_command<br>           command<span class="hljs-variable">.A</span>  = A;<br>           command<span class="hljs-variable">.B</span>  = B;<br>           command<span class="hljs-variable">.op</span> = op2enum();<br>           command_monitor_h<span class="hljs-variable">.write_to_monitor</span>(command);<br>           in_command = (command<span class="hljs-variable">.op</span> != no_op);<br>        <span class="hljs-keyword">end</span> : new_command<br>      <span class="hljs-keyword">end</span> : start_high<br>      <span class="hljs-keyword">else</span> <span class="hljs-comment">// start low</span><br>        in_command = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">end</span> : op_monitor<br><br>   <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">negedge</span> reset_n) <span class="hljs-keyword">begin</span> : rst_monitor<br>      command_s command;<br>      command<span class="hljs-variable">.op</span> = rst_op;<br>      command_monitor_h<span class="hljs-variable">.write_to_monitor</span>(command);<br>   <span class="hljs-keyword">end</span> : rst_monitor<br>   <br>   result_monitor  result_monitor_h;<br><br>   <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span> : result_monitor_thread<br>      <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span><br>         @(<span class="hljs-keyword">posedge</span> clk) ;<br>         <span class="hljs-keyword">if</span> (done) <br>           result_monitor_h<span class="hljs-variable">.write_to_monitor</span>(result);<br>      <span class="hljs-keyword">end</span><br>   <span class="hljs-keyword">end</span> : result_monitor_thread<br>  <br>   <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>      clk = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span><br>         #<span class="hljs-number">10</span>;<br>         clk = ~clk;<br>      <span class="hljs-keyword">end</span><br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endinterface</span> : tinyalu_bfm<br></code></pre></td></tr></table></figure><p>函数使用的时候通过接口对象调用就行了</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">virtual</span> tinyalu_bfm inf;<br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>inf<span class="hljs-variable">.send_op</span>(..);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>debug——dumpboxing</title>
    <link href="/2019/07/15/Verification/simulation/dump%E6%B3%A2%E5%BD%A2/"/>
    <url>/2019/07/15/Verification/simulation/dump%E6%B3%A2%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>Simulation</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch1-What a testbench?</title>
    <link href="/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch01_Introduction/ch01_What%20is%20a%20Testbench/"/>
    <url>/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch01_Introduction/ch01_What%20is%20a%20Testbench/</url>
    
    <content type="html"><![CDATA[<p>2019-10-24</p><h2 id="What-are-abstraction-levels"><a href="#What-are-abstraction-levels" class="headerlink" title="What are abstraction levels ?"></a>What are abstraction levels ?</h2><p>​    In the Preface, you saw that we toggled the design using individual signals.</p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog">#<span class="hljs-number">5</span>  resetn &lt;= <span class="hljs-number">0</span>;<br>#<span class="hljs-number">20</span> resetn &lt;= <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>​    Instead, if you put these two signals in a task and call it “apply_reset” task, you have just created a component that <strong>can be re-used and hides the details</strong> of what signals and what time intervals it is being asserted. This is a feature we would like to have when developing the testbench - to hide away details - s<strong>o that the test writer need not bother about the how and instead focus on when and why these tasks should be put to use.</strong> A test writer finally uses tasks, configures environment and writes code to test the design.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb_top;<br> <br>  <span class="hljs-keyword">bit</span> resetn;<br> <br>  <span class="hljs-keyword">task</span> apply_reset ();<br>    #<span class="hljs-number">5</span>  resetn &lt;= <span class="hljs-number">0</span>;<br>    #<span class="hljs-number">20</span> resetn &lt;= <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">endtask</span><br> <br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    apply_reset();  <br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>将一些操作封装成方法，这样test writer就不需要知道具体如何对接口信号操作，只需要知道什么时候应该进行什么操作就行了。</p>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SV</tag>
      
      <tag>ChipVerif_Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch2-Enume</title>
    <link href="/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch02_Data%20type/ch02_Enumeration/"/>
    <url>/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch02_Data%20type/ch02_Enumeration/</url>
    
    <content type="html"><![CDATA[<p>2019-10-24</p><p>​    The user can assign any integer value for any of the enumerated <em>names</em>. If any <em>name</em> does not have an assigned value, <strong>then it automatically takes the incremented value of the previous <em>name</em>.</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">enum</span>          &#123;RED=<span class="hljs-number">3</span>, YELLOW, GREEN&#125;       light_3;         <span class="hljs-comment">// RED = 3, YELLOW = 4, GREEN = 5</span><br><span class="hljs-keyword">enum</span>          &#123;RED = <span class="hljs-number">4</span>, YELLOW = <span class="hljs-number">9</span>, GREEN&#125; light_4;         <span class="hljs-comment">// RED = 4, YELLOW = 9, GREEN = 10 (automatically assigned)</span><br><span class="hljs-keyword">enum</span>          &#123;RED = <span class="hljs-number">2</span>, YELLOW, GREEN = <span class="hljs-number">3</span>&#125; light_5;         <span class="hljs-comment">// Error : YELLOW and GREEN are both assigned 3</span><br> <br><span class="hljs-keyword">enum</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">0</span>:<span class="hljs-number">0</span>] &#123;RED, YELLOW, GREEN&#125; light_6;<br></code></pre></td></tr></table></figure><h2 id="Why-do-we-need-enumeration"><a href="#Why-do-we-need-enumeration" class="headerlink" title="Why do we need enumeration ?"></a>Why do we need enumeration ?</h2><p><strong>To make the code more simple and readable.</strong></p><p>Consider the following example without enumeration.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">bit</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] light;<br> <br>light = <span class="hljs-number">2&#x27;b00</span>;       <span class="hljs-comment">// Assume 00 stands for RED</span><br> <br><span class="hljs-comment">// After many lines of code we have to correlate what</span><br><span class="hljs-comment">// 00 stands for - is it RED, YELLOW or GREEN ?</span><br><span class="hljs-keyword">if</span> (light == <span class="hljs-number">2&#x27;b00</span>)    <br>  <span class="hljs-comment">// Do something</span><br> <br></code></pre></td></tr></table></figure><p>The following code is more readable because of the enumerated <em>names</em> RED, YELLOW and GREEN.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;RED, YELLOW, GREEN&#125; e_light;<br>e_light   light;<br> <br>light = RED;     <span class="hljs-comment">// Initialize light to RED</span><br> <br><span class="hljs-comment">// Even after many lines of code it&#x27;s easier to understand</span><br><span class="hljs-keyword">if</span> (light == RED) <br>  <span class="hljs-comment">// Do something</span><br></code></pre></td></tr></table></figure><h2 id="Enumerated-type-ranges"><a href="#Enumerated-type-ranges" class="headerlink" title="Enumerated-type ranges"></a>Enumerated-type ranges</h2><table><thead><tr><th>name</th><th>The next number will be associated with name</th></tr></thead><tbody><tr><td>name &#x3D; C</td><td>Associates the constant C to name</td></tr><tr><td>name[N]</td><td>Generates N named constants : name0, name1, …, nameN-1</td></tr><tr><td>name[N] &#x3D; C</td><td>First named constant gets value C and subsequent ones are associated to consecutive values</td></tr><tr><td>name[N:M]</td><td>First named constant will be nameN and last named constant nameM, where N and M are integers</td></tr><tr><td>name[N:M] &#x3D; C</td><td>First named constant, nameN will get C and subsequent ones are associated to consecutive values until nameM</td></tr></tbody></table><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>In the following example, we’ll try out each of the different styles shown in the table above.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb;<br>  <span class="hljs-comment">// name : The next number will be associated with name starting from 0</span><br>  <span class="hljs-comment">// GREEN = 0, YELLOW = 1, RED = 2, BLUE = 3</span><br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;GREEN, YELLOW, RED, BLUE&#125; color_set_1;<br> <br>  <span class="hljs-comment">// name = C : Associates the constant C to name</span><br>  <span class="hljs-comment">// MAGENTA = 2, VIOLET = 7, PURPLE = 8, PINK = 9</span><br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;MAGENTA=<span class="hljs-number">2</span>, VIOLET=<span class="hljs-number">7</span>, PURPLE, PINK&#125; color_set_2;<br> <br>  <span class="hljs-comment">// name[N] : Generates N named constants : name0, name1, ..., nameN-1</span><br>  <span class="hljs-comment">// BLACK0 = 0, BLACK1 = 1, BLACK2 = 2, BLACK3 = 3</span><br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;BLACK[<span class="hljs-number">4</span>]&#125; color_set_3;<br> <br>  <span class="hljs-comment">// name[N] = C : First named constant gets value C and subsequent ones </span><br>  <span class="hljs-comment">// are associated to consecutive values</span><br>  <span class="hljs-comment">// RED0 = 5, RED1 = 6, RED2 = 7</span><br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;RED[<span class="hljs-number">3</span>] = <span class="hljs-number">5</span>&#125; color_set_4;<br> <br>  <span class="hljs-comment">// name[N:M] : First named constant will be nameN and last named </span><br>  <span class="hljs-comment">// constant nameM, where N and M are integers</span><br>  <span class="hljs-comment">// YELLOW3 = 0, YELLOW4 = 1, YELLOW5 = 2</span><br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;YELLOW[<span class="hljs-number">3</span>:<span class="hljs-number">5</span>]&#125; color_set_5;<br> <br>  <span class="hljs-comment">// name[N:M] = C : First named constant, nameN will get C and </span><br>  <span class="hljs-comment">// subsequent ones are associated to consecutive values until nameM</span><br>  <span class="hljs-comment">// WHITE3 = 4, WHITE4 = 5, WHITE5 = 6</span><br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;WHITE[<span class="hljs-number">3</span>:<span class="hljs-number">5</span>] = <span class="hljs-number">4</span>&#125; color_set_6;<br> <br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-comment">// Create new variables for each enumeration style</span><br>    color_set_1 color1;<br>    color_set_2 color2;<br>    color_set_3 color3;<br>    color_set_4 color4;<br>    color_set_5 color5;<br>    color_set_6 color6;<br> <br>    color1 = YELLOW; <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;color1 = %0d, name = %s&quot;</span>, color1, color1<span class="hljs-variable">.name</span>());<br>    color2 = PURPLE; <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;color2 = %0d, name = %s&quot;</span>, color2, color2<span class="hljs-variable">.name</span>());<br>    color3 = BLACK3; <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;color3 = %0d, name = %s&quot;</span>, color3, color3<span class="hljs-variable">.name</span>());<br>    color4 = RED1;   <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;color4 = %0d, name = %s&quot;</span>, color4, color4<span class="hljs-variable">.name</span>());<br>    color5 = YELLOW3;<span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;color5 = %0d, name = %s&quot;</span>, color5, color5<span class="hljs-variable">.name</span>());<br>    color6 = WHITE4; <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;color6 = %0d, name = %s&quot;</span>, color6, color6<span class="hljs-variable">.name</span>());<br> <br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><p><strong>Simulation Log</strong></p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs delphi">ncsim&gt; run<br>color1 = <span class="hljs-number">1</span>, <span class="hljs-keyword">name</span> = YELLOW<br>color2 = <span class="hljs-number">8</span>, <span class="hljs-keyword">name</span> = PURPLE<br>color3 = <span class="hljs-number">3</span>, <span class="hljs-keyword">name</span> = BLACK3<br>color4 = <span class="hljs-number">6</span>, <span class="hljs-keyword">name</span> = RED1<br>color5 = <span class="hljs-number">0</span>, <span class="hljs-keyword">name</span> = YELLOW3<br>color6 = <span class="hljs-number">5</span>, <span class="hljs-keyword">name</span> = WHITE4<br>ncsim: *W,RNQUIE: Simulation <span class="hljs-keyword">is</span> complete.<br></code></pre></td></tr></table></figure><h2 id="numerated-Type-Methods"><a href="#numerated-Type-Methods" class="headerlink" title="numerated-Type Methods"></a>numerated-Type Methods</h2><p>SystemVerilog includes a set of specialized methods to enable iterating over the values of enumerated types.</p><table><thead><tr><th>first()</th><th>function enum first();</th><th>Returns the value of the first member of the enumeration</th></tr></thead><tbody><tr><td>last()</td><td>function enum last();</td><td>Returns the value of the last member of the enumeration</td></tr><tr><td>next()</td><td>function enum next (int unsigned N &#x3D; 1);</td><td>Returns the Nth next enumeration value starting from the current value of the given variable</td></tr><tr><td>prev()</td><td>function enum prev (int unsigned N &#x3D; 1);</td><td>Returns the Nth previous enumeration value starting from the current value of the given variable</td></tr><tr><td>num()</td><td>function int num();</td><td>Returns the number of elements in the given enumeration</td></tr><tr><td>name()</td><td>function string name();</td><td>Returns the string representation of the given enumeration value</td></tr></tbody></table><h2 id="Type-Checking"><a href="#Type-Checking" class="headerlink" title="Type Checking"></a>Type Checking</h2><p>​    <strong>Enumerated types are <em>strongly typed</em> and hence a variable of type <code>enum</code> cannot be assigned an integer value that lie outside the enumeration set unless an explicit cast is used.</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] &#123;RED, YELLOW, GREEN&#125; e_light;<br> <br><span class="hljs-keyword">module</span> tb;<br>  e_light light;<br> <br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    light = GREEN;        <br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;light = %s&quot;</span>, light<span class="hljs-variable">.name</span>());<br> <br>    <span class="hljs-comment">// Invalid because of strict typing rules</span><br>    light = <span class="hljs-number">0</span>;               <br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;light = %s&quot;</span>, light<span class="hljs-variable">.name</span>());<br> <br>    <span class="hljs-comment">// OK when explicitly cast</span><br>    light = e_light&#x27;(<span class="hljs-number">1</span>);      <br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;light = %s&quot;</span>, light<span class="hljs-variable">.name</span>());<br> <br>    <span class="hljs-comment">// OK. light is auto-cast to integer</span><br>    <span class="hljs-keyword">if</span> (light == RED | light == <span class="hljs-number">2</span>)<br>      <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;light is now %s&quot;</span>, light<span class="hljs-variable">.name</span>());<br> <br>  <span class="hljs-keyword">end</span>    <br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SV</tag>
      
      <tag>ChipVerif_Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch2-new data types</title>
    <link href="/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch02_Data%20type/ch02_New%20Data%20typeslogic,bit/"/>
    <url>/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch02_Data%20type/ch02_New%20Data%20typeslogic,bit/</url>
    
    <content type="html"><![CDATA[<p>2019-10-24</p><h2 id="2-state-data-types"><a href="#2-state-data-types" class="headerlink" title="2-state data types"></a>2-state data types</h2><p>​    <strong>When a 4-state value is converted to a 2-state value, any unknown or high-impedance bits shall be converted to zeros.</strong></p><p>The most important 2-state data type is <code>bit</code> which is used most often in testbenches. A variable of type <code>bit</code> can be either 0 or 1 which represents a single bit. A range from MSB to LSB should be provided to make it represent and store multiple bits</p>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SV</tag>
      
      <tag>ChipVerif_Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch2-Integers</title>
    <link href="/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch02_Data%20type/ch02_Signed%20integers,byte/"/>
    <url>/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch02_Data%20type/ch02_Signed%20integers,byte/</url>
    
    <content type="html"><![CDATA[<p>2019-10-24</p><h2 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h2><p>​    Integers are numbers without a fractional part or in other words, they are whole numbers. <strong>SystemVerilog has three new <em>signed</em> data types to hold integer values each with a different size.</strong> The smallest is <strong><code>shortint</code></strong> which can range from -32768 to 32767, and the largest is <strong><code>longint</code>.</strong> The sign can be explicitly defined using the keywords <strong><code>signed</code></strong> and <strong><code>unsigned</code>.</strong> Also they can be converted into one another by casting.</p><h3 id="Signed"><a href="#Signed" class="headerlink" title="Signed"></a>Signed</h3><p>​    By default**, integer variables are signed in nature** and hence can hold both positive and negative values.</p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-keyword">shortint</span>   var_a;      <br> <span class="hljs-keyword">int</span>     var_b;<br> <span class="hljs-keyword">longint</span>   var_c;<br></code></pre></td></tr></table></figure><h3 id="Unsigned"><a href="#Unsigned" class="headerlink" title="Unsigned"></a>Unsigned</h3><p>​    We’ll change variables declared in the example above to be of <strong><code>unsigned</code></strong> type and see how the results look like.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-keyword">shortint</span> <span class="hljs-keyword">unsigned</span>     var_a;      <br> <span class="hljs-keyword">int</span>      <span class="hljs-keyword">unsigned</span>    var_b;<br> <span class="hljs-keyword">longint</span>  <span class="hljs-keyword">unsigned</span>   var_c;<br></code></pre></td></tr></table></figure><h3 id="byte"><a href="#byte" class="headerlink" title="byte"></a>byte</h3><p>​    <strong>A <code>byte</code> is an even shorter version of an integer with a size of 8 bits</strong>. By default <code>byte</code> is a <strong>signed variable</strong> and has the same properties as an integer described in the previous section</p>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SV</tag>
      
      <tag>ChipVerif_Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch2-String</title>
    <link href="/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch02_Data%20type/ch02_Strings/"/>
    <url>/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch02_Data%20type/ch02_Strings/</url>
    
    <content type="html"><![CDATA[<p>2019-10-24</p><h2 id="How-are-strings-represented-in-Verilog"><a href="#How-are-strings-represented-in-Verilog" class="headerlink" title="How are strings represented in Verilog ?"></a>How are strings represented in Verilog ?</h2><p>​    A single ASCII character requires 8-bits (1 byte) and to store a string we would need as many bytes as there are number of characters in the string.</p><p><a href="https://www.chipverify.com/verilog/verilog-arrays-memories">Click here to learn about Verilog Arrays</a></p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-keyword">reg</span>  [<span class="hljs-number">16</span>*<span class="hljs-number">8</span>-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>]   my_string;           <span class="hljs-comment">// Can store 16 characters</span><br> <br>my_string = <span class="hljs-string">&quot;How are you&quot;</span>;             <span class="hljs-comment">// 5 zeros are padded from MSB, and 11 char are stored</span><br>my_string = <span class="hljs-string">&quot;How are you doing?&quot;</span>       <span class="hljs-comment">// 19 characters; my_string will get &quot; are you doing?&quot;</span><br> <br></code></pre></td></tr></table></figure><h2 id="Basic-String-Methods"><a href="#Basic-String-Methods" class="headerlink" title="Basic String Methods"></a>Basic String Methods</h2><p>​    SystemVerilog also includes a number of special methods to work with strings, which use built-in method notation.</p><table><thead><tr><th align="left">Usage</th><th align="left">Definition</th><th align="left">Comments</th></tr></thead><tbody><tr><td align="left">str.len()</td><td align="left">function int len()</td><td align="left">Returns the number of characters in the string</td></tr><tr><td align="left">str.putc()</td><td align="left">function void putc (int i, byte c);</td><td align="left">Replaces the ith character in the string with the given character</td></tr><tr><td align="left">str.getc()</td><td align="left">function byte getc (int i);</td><td align="left">Returns the ASCII code of the ith character in str</td></tr><tr><td align="left">str.tolower()</td><td align="left">function string tolower();</td><td align="left">Returns a string with characters in str converted to lowercase</td></tr><tr><td align="left">str.compare(s)</td><td align="left">function int compare (string s);</td><td align="left">Compares str and s, as in the ANSI C stcmp function</td></tr><tr><td align="left">str.icompare(s)</td><td align="left">function int icompare (string s);</td><td align="left">Compares str and s, like the ANSI C strcmp function</td></tr><tr><td align="left">str.substr (i, j)</td><td align="left">function string substr (int i, int j);</td><td align="left">Returns a new string that is a substring formed by characters in position i through j of str</td></tr></tbody></table><h2 id="String-Conversion-Methods"><a href="#String-Conversion-Methods" class="headerlink" title="String Conversion Methods"></a>String Conversion Methods</h2><p>(先存下，万一用上了呢)</p><table><thead><tr><th>str.atoi()</th><th>function integer atoi();</th><th>Returns the integer corresponding to the ASCII decimal representation in str</th></tr></thead><tbody><tr><td>str.atohex()</td><td>function integer atohex();</td><td>Interprets the string as hexadecimal</td></tr><tr><td>str.atooct()</td><td>function integer atooct();</td><td>Interprets the string as octal</td></tr><tr><td>str.atobin()</td><td>function integer atobin();</td><td>Interprets the string as binary</td></tr><tr><td>str.atoreal()</td><td>function real atoreal();</td><td>Returns the real number corresponding to the ASCII decimal representation in str</td></tr><tr><td>str.itoa(i)</td><td>function void itoa (integer i);</td><td>Stores the ASCII decimal representation of i into str</td></tr><tr><td>str.hextoa(i)</td><td>function void hextoa (integer i);</td><td>Stores the ASCII hexadecimal representation of i into str</td></tr><tr><td>str.octtoa(i)</td><td>function void octtoa (integer i);</td><td>Stores the ASCII octal representation of i into str</td></tr><tr><td>str.bintoa(i)</td><td>function void bintoa (integer i);</td><td>Stores the ASCII binary representation of i into str</td></tr><tr><td>str.realtoa(r)</td><td>function void realtoa (real r);</td><td>Stores the ASCII real representation of r into str</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SV</tag>
      
      <tag>ChipVerif_Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch2-Dynamic Arrays</title>
    <link href="/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch02_Data%20type/ch02_dynamic%20array/"/>
    <url>/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch02_Data%20type/ch02_dynamic%20array/</url>
    
    <content type="html"><![CDATA[<p>2019-10-24</p><h1 id="SystemVerilog-Dynamic-Array"><a href="#SystemVerilog-Dynamic-Array" class="headerlink" title="SystemVerilog Dynamic Array"></a>SystemVerilog Dynamic Array</h1><p>​    A <em>dynamic</em> array is an unpacked array whose size <strong>can be set or changed at run time,</strong> and hence is quite different from a static array where the size is pre-determined during declaration of the array. <strong>The default size of a dynamic array is zero until it is set by the <code>new()</code> constructor.</strong></p><h2 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h2><p>A <em>dynamic</em> array dimensions are specified by the empty square brackets <code>[ ]</code>.</p><figure class="highlight smali"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs smali">[data_type] [identifier_name]  [];<br> <br>bit [7:0]   stack [];     // A dynamic<span class="hljs-built_in"> array </span>of 8-bit vector<br>string     names [];     // A dynamic<span class="hljs-built_in"> array </span>that can contain strings <br> <br></code></pre></td></tr></table></figure><p><strong>The <code>new()</code> function is used to allocate a size for the array and initialize its elements if required.</strong></p><h2 id="Dynamic-Array-Example"><a href="#Dynamic-Array-Example" class="headerlink" title="Dynamic Array Example"></a>Dynamic Array Example</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb;<br>  <span class="hljs-comment">// Create a dynamic array that can hold elements of type int</span><br>  <span class="hljs-keyword">int</span>   array [];       <br> <br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-comment">// Create a size for the dynamic array -&gt; size here is 5</span><br>    <span class="hljs-comment">// so that it can hold 5 values</span><br>    array = <span class="hljs-keyword">new</span> [<span class="hljs-number">5</span>];       <br> <br>    <span class="hljs-comment">// Initialize the array with five values</span><br>    array = &#x27;&#123;<span class="hljs-number">31</span>, <span class="hljs-number">67</span>, <span class="hljs-number">10</span>, <span class="hljs-number">4</span>, <span class="hljs-number">99</span>&#125;;<br> <br>    <span class="hljs-comment">// Loop through the array and print their values</span><br>    <span class="hljs-keyword">foreach</span> (array[i]) <br>      <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;array[%0d] = %0d&quot;</span>, i, array[i]);<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="ynamic-Array-Methods"><a href="#ynamic-Array-Methods" class="headerlink" title="ynamic Array Methods"></a>ynamic Array Methods</h2><table><thead><tr><th align="left">Function</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">function int size ();</td><td align="left">Returns the current size of the array, 0 if array has not been created</td></tr><tr><td align="left">function void delete ();</td><td align="left">Empties the array resulting in a zero-sized array</td></tr></tbody></table><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb;<br>  <span class="hljs-comment">// Create a dynamic array that can hold elements of type string</span><br>  <span class="hljs-keyword">string</span>   fruits [];       <br> <br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-comment">// Create a size for the dynamic array -&gt; size here is 5</span><br>    <span class="hljs-comment">// so that it can hold 5 values</span><br>        fruits = <span class="hljs-keyword">new</span> [<span class="hljs-number">3</span>];       <br> <br>    <span class="hljs-comment">// Initialize the array with five values</span><br>        fruits = &#x27;&#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>, <span class="hljs-string">&quot;mango&quot;</span>&#125;;<br> <br>        <span class="hljs-comment">// Print size of the dynamic array</span><br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;fruits.size() = %0d&quot;</span>, fruits<span class="hljs-variable">.size</span>());<br> <br>    <span class="hljs-comment">// Empty the dynamic array by deleting all items</span><br>    fruits<span class="hljs-variable">.delete</span>();<br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;fruits.size() = %0d&quot;</span>, fruits<span class="hljs-variable">.size</span>());<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="How-to-add-new-items-to-a-dynamic-array"><a href="#How-to-add-new-items-to-a-dynamic-array" class="headerlink" title="How to add new items to a dynamic array ?"></a>How to add new items to a dynamic array ?</h2><p>​    Many times we may need to add new elements to an existing dyanmic array without losing its original contents. Since the <code>new()</code> operator is used to allocate a particular size for the array, <strong>we also have to copy the old array contents into the new one after creation.</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">int</span> array [];<br>array = <span class="hljs-keyword">new</span> [<span class="hljs-number">10</span>];<br> <br><span class="hljs-comment">// This creates one more slot in the array, while keeping old contents</span><br>array = <span class="hljs-keyword">new</span> [array<span class="hljs-variable">.size</span>() + <span class="hljs-number">1</span>] (array);   <br> <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SV</tag>
      
      <tag>ChipVerif_Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch2-Array Manipulation</title>
    <link href="/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch02_Data%20type/ch02_manipulation%20array/"/>
    <url>/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch02_Data%20type/ch02_manipulation%20array/</url>
    
    <content type="html"><![CDATA[<h1 id="SystemVerilog-Array-Manipulation"><a href="#SystemVerilog-Array-Manipulation" class="headerlink" title="SystemVerilog Array Manipulation"></a>SystemVerilog Array Manipulation</h1><p>There are many built-in methods in SystemVerilog to help in array searching and ordering.</p><p>Array manipulation methods simply iterate through the array elements and each element is used to evaluate the expression specified by the <code>with</code> clause. The <strong>iterator argument</strong> specifies a local variable that can be used within the <code>with</code> expression to refer to the current element in the iteration. <strong>If an argument is not provided, <em>item</em> is the name used by default.</strong></p><p>Specifying an iterator argument without the <code>with</code> clause is illegal.</p><h2 id="Array-Locator-Methods"><a href="#Array-Locator-Methods" class="headerlink" title="Array Locator Methods"></a>Array Locator Methods</h2><p>​    <strong>The <code>with</code> clause and expresison is mandatory for some of these methods and for some others its optional.</strong></p><h3 id="Mandatory-‘with’-clause"><a href="#Mandatory-‘with’-clause" class="headerlink" title="Mandatory ‘with’ clause"></a>Mandatory ‘with’ clause</h3><p>​    These methods are used to filter out certain elements from an existing array based on a given expression. <strong>All such elements that satisfy the given expression is put into an array and returned.</strong> Hence the <code>with</code> clause is mandatory for the following methods.</p><table><thead><tr><th align="left">Method name</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">find()</td><td align="left">Returns all elements satisfying the given expression</td></tr><tr><td align="left">find_index()</td><td align="left">Returns the indices of all elements satisfying the given expression</td></tr><tr><td align="left">find_first()</td><td align="left">Returns the first element satisfying the given expression</td></tr><tr><td align="left">find_first_index()</td><td align="left">Returns the index of the first element satisfying the given expression</td></tr><tr><td align="left">find_last()</td><td align="left">Returns the last element satisfying the given expression</td></tr><tr><td align="left">find_last_index()</td><td align="left">Returns the index of the last element satisfying the given expression</td></tr></tbody></table><p><strong>Example</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb;<br>  <span class="hljs-keyword">int</span> array[<span class="hljs-number">9</span>] = &#x27;&#123;<span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;;<br>  <span class="hljs-keyword">int</span> res[$];<br> <br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    res = array<span class="hljs-variable">.find</span>(x) <span class="hljs-keyword">with</span> (x &gt; <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;find(x)         : %p&quot;</span>, res);<br> <br>    res = array<span class="hljs-variable">.find_index</span> <span class="hljs-keyword">with</span> (item == <span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;find_index      : res[%0d] = 4&quot;</span>, res[<span class="hljs-number">0</span>]);<br> <br>    res = array<span class="hljs-variable">.find_first</span> <span class="hljs-keyword">with</span> (item &lt; <span class="hljs-number">5</span> &amp; item &gt;= <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;find_first      : %p&quot;</span>, res);<br> <br>    res = array<span class="hljs-variable">.find_first_index</span>(x) <span class="hljs-keyword">with</span> (x &gt; <span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;find_first_index: %p&quot;</span>, res);<br> <br>    res = array<span class="hljs-variable">.find_last</span> <span class="hljs-keyword">with</span> (item &lt;= <span class="hljs-number">7</span> &amp; item &gt; <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;find_last       : %p&quot;</span>, res);<br> <br>    res = array<span class="hljs-variable">.find_last_index</span>(x) <span class="hljs-keyword">with</span> (x &lt; <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;find_last_index : %p&quot;</span>, res);<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><p><strong>Simulation Log</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ncsim</span>&gt; run<br><span class="hljs-attribute">find</span>(x)         : &#x27;&#123;<span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>&#125;<br><span class="hljs-attribute">find_index</span>      : res[<span class="hljs-number">0</span>] = <span class="hljs-number">4</span><br><span class="hljs-attribute">find_first</span>      : &#x27;&#123;<span class="hljs-number">4</span>&#125;<br><span class="hljs-attribute">find_first_index</span>: &#x27;&#123;<span class="hljs-number">1</span>&#125;<br><span class="hljs-attribute">find_last</span>       : &#x27;&#123;<span class="hljs-number">6</span>&#125;<br><span class="hljs-attribute">find_last_index</span> : &#x27;&#123;<span class="hljs-number">8</span>&#125;<br><span class="hljs-attribute">ncsim</span>: *W,RNQUIE: Simulation is complete.<br></code></pre></td></tr></table></figure><p><a href="https://www.edaplayground.com/x/2mgN">Click to try this example in a simulator!  <img src="https://www.chipverify.com/images/site/eda-playground-logo.png" alt="img"></a></p><h3 id="Optional-‘with’-clause"><a href="#Optional-‘with’-clause" class="headerlink" title="Optional ‘with’ clause"></a>Optional ‘with’ clause</h3><table><thead><tr><th align="left">Methods</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">min()</td><td align="left">Returns the element with minimum value or whose expression evaluates to a minimum</td></tr><tr><td align="left">max()</td><td align="left">Returns the element with maximum value or whose expression evaluates to a maximum</td></tr><tr><td align="left">unique()</td><td align="left">Returns all elements with unique values or whose expression evaluates to a unique value</td></tr><tr><td align="left">unique_index()</td><td align="left">Returns the indices of all elements with unique values or whose expression evaluates to a unique value</td></tr></tbody></table><p><strong>Example</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb;<br>  <span class="hljs-keyword">int</span> array[<span class="hljs-number">9</span>] = &#x27;&#123;<span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">int</span> res[$];<span class="hljs-comment">// 返回的类型是队列</span><br> <br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>   <br>    res = array<span class="hljs-variable">.min</span>();<br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;min          : %p&quot;</span>, res);<br> <br>    res = array<span class="hljs-variable">.max</span>();<br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;max          : %p&quot;</span>, res);<br> <br>    res = array<span class="hljs-variable">.unique</span>();<br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;unique       : %p&quot;</span>, res);<br> <br>    res = array<span class="hljs-variable">.unique</span>(x) <span class="hljs-keyword">with</span> (x &lt; <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;unique       : %p&quot;</span>, res);<br> <br>    res = array<span class="hljs-variable">.unique_index</span>;<br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;unique_index : %p&quot;</span>, res);<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><p><strong>Simulation Log</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ncsim</span>&gt; run<br><span class="hljs-attribute">min</span>          : &#x27;&#123;<span class="hljs-number">1</span>&#125;<br><span class="hljs-attribute">max</span>          : &#x27;&#123;<span class="hljs-number">7</span>&#125;<br><span class="hljs-attribute">unique</span>       : &#x27;&#123;<span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>&#125;<br><span class="hljs-attribute">unique</span>       : &#x27;&#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>&#125;<br><span class="hljs-attribute">unique_index</span> : &#x27;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;<br><span class="hljs-attribute">ncsim</span>: *W,RNQUIE: Simulation is complete.<br></code></pre></td></tr></table></figure><p><a href="https://www.edaplayground.com/x/3_vk">Click to try this example in a simulator!  <img src="https://www.chipverify.com/images/site/eda-playground-logo.png" alt="img"></a></p><h2 id="Array-Ordering-Methods"><a href="#Array-Ordering-Methods" class="headerlink" title="Array Ordering Methods"></a>Array Ordering Methods</h2><p>These methods operate and alter the array directly.</p><table><thead><tr><th align="left">Method</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">reverse()</td><td align="left">Reverses the order of elements in the array</td></tr><tr><td align="left">sort()</td><td align="left">Sorts the array in ascending order, optionally using <code>with</code> clause</td></tr><tr><td align="left">rsort()</td><td align="left">Sorts the array in descending order, optionally using <code>with</code> clause</td></tr><tr><td align="left">shuffle()</td><td align="left">Randomizes the order of the elements in the array. <code>with</code> clause is not allowed here.</td></tr></tbody></table><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb;<br>  <span class="hljs-keyword">int</span> array[<span class="hljs-number">9</span>] = &#x27;&#123;<span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;;<br> <br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>   <br>    array<span class="hljs-variable">.reverse</span>();<br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;reverse  : %p&quot;</span>, array);<br> <br>    array<span class="hljs-variable">.sort</span>();<br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;sort     : %p&quot;</span>, array);<br> <br>    array<span class="hljs-variable">.rsort</span>();<br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;rsort    : %p&quot;</span>, array);<br> <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) <span class="hljs-keyword">begin</span><br>      array<span class="hljs-variable">.shuffle</span>();<br>      <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;shuffle Iter:%0d  = %p&quot;</span>, i, array);<br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><p><strong>Simulation Log</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ncsim</span>&gt; run<br><span class="hljs-attribute">reverse</span>  : &#x27;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>&#125;<br><span class="hljs-attribute">sort</span>     : &#x27;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>&#125;<br><span class="hljs-attribute">rsort</span>    : &#x27;&#123;<span class="hljs-number">7</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;<br><span class="hljs-attribute">shuffle</span> Iter:<span class="hljs-number">0</span>  = &#x27;&#123;<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-attribute">shuffle</span> Iter:<span class="hljs-number">1</span>  = &#x27;&#123;<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>&#125;<br><span class="hljs-attribute">shuffle</span> Iter:<span class="hljs-number">2</span>  = &#x27;&#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-attribute">shuffle</span> Iter:<span class="hljs-number">3</span>  = &#x27;&#123;<span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;<br><span class="hljs-attribute">shuffle</span> Iter:<span class="hljs-number">4</span>  = &#x27;&#123;<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;<br><span class="hljs-attribute">ncsim</span>: *W,RNQUIE: Simulation is complete.<br></code></pre></td></tr></table></figure><p><a href="https://www.edaplayground.com/x/5Ytv">Click to try this example in a simulator!  <img src="https://www.chipverify.com/images/site/eda-playground-logo.png" alt="img"></a></p><h3 id="Using-array-ordering-on-classes"><a href="#Using-array-ordering-on-classes" class="headerlink" title="Using array ordering on classes"></a>Using array ordering on classes</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> Register;<br>  <span class="hljs-keyword">string</span> name;<br>  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] rank;<br>  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] pages;<br> <br>  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span> (<span class="hljs-keyword">string</span> name);<br>    <span class="hljs-keyword">this</span><span class="hljs-variable">.name</span> = name;<br>  <span class="hljs-keyword">endfunction</span><br> <br>  <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> print();<br>    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;name=%s rank=%0d pages=%0d&quot;</span>, name, rank, pages);<br>  <span class="hljs-keyword">endfunction</span><br> <br><span class="hljs-keyword">endclass</span><br> <br><span class="hljs-keyword">module</span> tb;<br>  Register rt[<span class="hljs-number">4</span>];<br>  <span class="hljs-keyword">string</span> name_arr[<span class="hljs-number">4</span>] = &#x27;&#123;<span class="hljs-string">&quot;alexa&quot;</span>, <span class="hljs-string">&quot;siri&quot;</span>, <span class="hljs-string">&quot;google home&quot;</span>, <span class="hljs-string">&quot;cortana&quot;</span>&#125;;<br> <br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;\n-------- Initial Values --------&quot;</span>);<br>    <span class="hljs-keyword">foreach</span> (rt[i]) <span class="hljs-keyword">begin</span><br>      rt[i] = <span class="hljs-keyword">new</span> (name_arr[i]);<br>      rt[i]<span class="hljs-variable">.randomize</span>();<br>      rt[i]<span class="hljs-variable">.print</span>();<br>    <span class="hljs-keyword">end</span><br> <br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;\n--------- Sort by name ------------&quot;</span>);<br> <span class="hljs-comment">// 根据class中的数据对类对象排序</span><br>    rt<span class="hljs-variable">.sort</span>(x) <span class="hljs-keyword">with</span> (x<span class="hljs-variable">.name</span>);<br>    <span class="hljs-keyword">foreach</span> (rt[i]) rt[i]<span class="hljs-variable">.print</span>();<br> <br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;\n--------- Sort by rank, pages -----------&quot;</span>);<br> <br>    rt<span class="hljs-variable">.sort</span>(x) <span class="hljs-keyword">with</span> ( &#123;x<span class="hljs-variable">.rank</span>, x<span class="hljs-variable">.pages</span>&#125;);<br>    <span class="hljs-keyword">foreach</span> (rt[i]) rt[i]<span class="hljs-variable">.print</span>();<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><p><strong>Simulation Log</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs routeros">ncsim&gt; <span class="hljs-built_in">run</span><br><br>-------- Initial Values --------<br><span class="hljs-attribute">name</span>=alexa <span class="hljs-attribute">rank</span>=12 <span class="hljs-attribute">pages</span>=13<br><span class="hljs-attribute">name</span>=siri <span class="hljs-attribute">rank</span>=6 <span class="hljs-attribute">pages</span>=12<br><span class="hljs-attribute">name</span>=google home <span class="hljs-attribute">rank</span>=12 <span class="hljs-attribute">pages</span>=13<br><span class="hljs-attribute">name</span>=cortana <span class="hljs-attribute">rank</span>=7 <span class="hljs-attribute">pages</span>=11<br><br>--------- Sort by name ------------<br><span class="hljs-attribute">name</span>=alexa <span class="hljs-attribute">rank</span>=12 <span class="hljs-attribute">pages</span>=13<br><span class="hljs-attribute">name</span>=cortana <span class="hljs-attribute">rank</span>=7 <span class="hljs-attribute">pages</span>=11<br><span class="hljs-attribute">name</span>=google home <span class="hljs-attribute">rank</span>=12 <span class="hljs-attribute">pages</span>=13<br><span class="hljs-attribute">name</span>=siri <span class="hljs-attribute">rank</span>=6 <span class="hljs-attribute">pages</span>=12<br><br>--------- Sort by rank, pages -----------<br><span class="hljs-attribute">name</span>=siri <span class="hljs-attribute">rank</span>=6 <span class="hljs-attribute">pages</span>=12<br><span class="hljs-attribute">name</span>=cortana <span class="hljs-attribute">rank</span>=7 <span class="hljs-attribute">pages</span>=11<br><span class="hljs-attribute">name</span>=alexa <span class="hljs-attribute">rank</span>=12 <span class="hljs-attribute">pages</span>=13<br><span class="hljs-attribute">name</span>=google home <span class="hljs-attribute">rank</span>=12 <span class="hljs-attribute">pages</span>=13<br>ncsim: *W,RNQUIE: Simulation is complete.<br></code></pre></td></tr></table></figure><p><a href="https://www.edaplayground.com/x/4XQa">Click to try this example in a simulator!  <img src="https://www.chipverify.com/images/site/eda-playground-logo.png" alt="img"></a></p><h2 id="Array-Reduction-Methods"><a href="#Array-Reduction-Methods" class="headerlink" title="Array Reduction Methods"></a>Array Reduction Methods</h2><table><thead><tr><th align="left">Method</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">sum()</td><td align="left">Returns the sum of all array elements</td></tr><tr><td align="left">product()</td><td align="left">Returns the product of all array elements</td></tr><tr><td align="left">and()</td><td align="left">Returns the bitwise AND (&amp;) of all array elements</td></tr><tr><td align="left">or()</td><td align="left">Returns the bitwise OR (|) of all array elements</td></tr><tr><td align="left">xor()</td><td align="left">Returns the bitwise XOR (^) of all array elements</td></tr></tbody></table><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb;<br>  <span class="hljs-keyword">int</span> array[<span class="hljs-number">4</span>] = &#x27;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>  <span class="hljs-keyword">int</span> res[$];<br> <br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;sum     = %0d&quot;</span>, array<span class="hljs-variable">.sum</span>());    <br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;product = %0d&quot;</span>, array<span class="hljs-variable">.product</span>());    <br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;and     = 0x%0h&quot;</span>, array<span class="hljs-variable">.and</span>());<br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;or      = 0x%0h&quot;</span>, array<span class="hljs-variable">.or</span>());    <br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;xor     = 0x%0h&quot;</span>, array<span class="hljs-variable">.xor</span>());   <br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><p><strong>Simulation Log</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile">ncsim&gt; run<br>sum     = 10<br>product = 24<br>and     = 0x0<br>or      = 0x7<br>xor     = 0x4<br><span class="hljs-section">ncsim: *W,RNQUIE: Simulation is complete.</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SV</tag>
      
      <tag>ChipVerif_Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch2-Associative Arrays</title>
    <link href="/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch02_Data%20type/ch02_associative%20array/"/>
    <url>/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch02_Data%20type/ch02_associative%20array/</url>
    
    <content type="html"><![CDATA[<p>2019-10-24</p><h1 id="SystemVerilog-Associative-Arrays"><a href="#SystemVerilog-Associative-Arrays" class="headerlink" title="SystemVerilog Associative Arrays"></a>SystemVerilog Associative Arrays</h1><p>​    When size of a collection is unknown or the data space is sparse, an associative array is a better option. <strong>Associative arrays do not have any storage allocated until it is used, and the index expression is not restricted to integral expressions, but can be of any type.</strong></p><p>​    An associative array implements a look-up table of the elements of its declared type. The data type to be used as an index serves as the lookup key and imposes an ordering.</p><h2 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h2><figure class="highlight abnf"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs abnf">// Value     Array_Name          [ key ]<span class="hljs-comment">;</span><br>data_type    array_identifier    [ index_type ]<span class="hljs-comment">;</span><br> <br></code></pre></td></tr></table></figure><h2 id="Initialization-Example"><a href="#Initialization-Example" class="headerlink" title="Initialization Example"></a>Initialization Example</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb;<br> <br>  <span class="hljs-keyword">int</span>     array1 [<span class="hljs-keyword">int</span>];       <span class="hljs-comment">// An integer array with integer index</span><br>  <span class="hljs-keyword">int</span>     array2 [<span class="hljs-keyword">string</span>];     <span class="hljs-comment">// An integer array with string index</span><br>  <span class="hljs-keyword">string</span>  array3 [<span class="hljs-keyword">string</span>];     <span class="hljs-comment">// A string array with string index</span><br> <br>    <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>        <span class="hljs-comment">// Initialize each dynamic array with some values</span><br>      array1 = &#x27;&#123; <span class="hljs-number">1</span> : <span class="hljs-number">22</span>,<br>                <span class="hljs-number">6</span> : <span class="hljs-number">34</span> &#125;;<br> <br>    array2 = &#x27;&#123; <span class="hljs-string">&quot;Ross&quot;</span> : <span class="hljs-number">100</span>,<br>                <span class="hljs-string">&quot;Joey&quot;</span> : <span class="hljs-number">60</span> &#125;;<br> <br>    array3 = &#x27;&#123; <span class="hljs-string">&quot;Apples&quot;</span> : <span class="hljs-string">&quot;Oranges&quot;</span>,<br>                <span class="hljs-string">&quot;Pears&quot;</span> : <span class="hljs-string">&quot;44&quot;</span> &#125;;<br> <br>        <span class="hljs-comment">// Print each array</span><br>      <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;array1 = %p&quot;</span>, array1);<br>      <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;array2 = %p&quot;</span>, array2);<br>      <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;array3 = %p&quot;</span>, array3);<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><h2 id="Associative-Array-Methods"><a href="#Associative-Array-Methods" class="headerlink" title="Associative Array Methods"></a>Associative Array Methods</h2><table><thead><tr><th align="left">Function</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">function int num ();</td><td align="left">Returns the number of entries in the associative array</td></tr><tr><td align="left">function int <strong>size</strong> ();</td><td align="left">Also returns the number of entries, if empty 0 is returned</td></tr><tr><td align="left">function void <strong>delete</strong> ( [input index] );</td><td align="left"><em>index</em> when specified deletes the entry at that index, else the whole array is deleted</td></tr><tr><td align="left">function int <strong>exists</strong> (input index);</td><td align="left">Checks whether an element exists at specified index; returns 1 if it does, else 0</td></tr><tr><td align="left">function int first (ref index);</td><td align="left">Assigns to the given index variable the value of the first index; returns 0 for empty array</td></tr><tr><td align="left">function int last (ref index);</td><td align="left">Assigns to given index variable the value of the last index; returns 0 for empty array</td></tr><tr><td align="left">function int next (ref index);</td><td align="left">Finds the smallest index whose value is greater than the given index</td></tr><tr><td align="left">function int prev (ref index);</td><td align="left">Finds the largest index whose value is smaller than the given index</td></tr></tbody></table><h2 id="Creating-a-dynamic-array-of-associative-arrays"><a href="#Creating-a-dynamic-array-of-associative-arrays" class="headerlink" title="Creating a dynamic array of associative arrays"></a>Creating a dynamic array of associative arrays</h2><p>dynamic array的每一个元素都是associative array</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb;<br>  <span class="hljs-comment">// Create an associative array with key of type string and value of type int</span><br>  <span class="hljs-comment">// for each index in a dynamic array</span><br>  <span class="hljs-keyword">int</span> fruits [] [<span class="hljs-keyword">string</span>];<br> <br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-comment">// Create a dynamic array with size 2</span><br>    fruits = <span class="hljs-keyword">new</span> [<span class="hljs-number">2</span>];<br> <br>    <span class="hljs-comment">// Initialize the associative array inside each dynamic array index</span><br>    fruits [<span class="hljs-number">0</span>] = &#x27;&#123; <span class="hljs-string">&quot;apple&quot;</span> : <span class="hljs-number">1</span>, <span class="hljs-string">&quot;grape&quot;</span> : <span class="hljs-number">2</span> &#125;;<br>    fruits [<span class="hljs-number">1</span>] = &#x27;&#123; <span class="hljs-string">&quot;melon&quot;</span> : <span class="hljs-number">3</span>, <span class="hljs-string">&quot;cherry&quot;</span> : <span class="hljs-number">4</span> &#125;;<br> <br>    <span class="hljs-comment">// Iterate through each index of dynamic array</span><br>    <span class="hljs-keyword">foreach</span> (fruits[i])<br>      <span class="hljs-comment">// Iterate through each key of the current index in dynamic array</span><br>      <span class="hljs-keyword">foreach</span> (fruits[i][fruit])<br>        <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;fruits[%0d][%s] = %0d&quot;</span>, i, fruit, fruits[i][fruit]);<br> <br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="Embedding-a-dynamic-array-within-each-index-of-an-associative-array"><a href="#Embedding-a-dynamic-array-within-each-index-of-an-associative-array" class="headerlink" title="Embedding a dynamic array within each index of an associative array"></a>Embedding a dynamic array within each index of an associative array</h2><p>每个associative array的元素都是一个dynamic array</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// Create a new typedef that represents a dynamic array</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> int_da [];<br> <br><span class="hljs-keyword">module</span> tb;<br>  <span class="hljs-comment">// Create an associative array where key is a string </span><br>  <span class="hljs-comment">// and value is a dynamic array</span><br>  int_da fruits [<span class="hljs-keyword">string</span>];<br> <br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-comment">// For key &quot;apple&quot;, create a dynamic array that can hold 2 items </span><br>    fruits [<span class="hljs-string">&quot;apple&quot;</span>] = <span class="hljs-keyword">new</span> [<span class="hljs-number">2</span>];<br> <br>    <span class="hljs-comment">// Initialize the dynamic array with some values</span><br>    fruits [<span class="hljs-string">&quot;apple&quot;</span>] = &#x27;&#123; <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br> <br>    <span class="hljs-comment">// Iterate through each key, where key represented by str1</span><br>    <span class="hljs-keyword">foreach</span> (fruits[str1]) <br>      <span class="hljs-comment">// Iterate through each item inside the current dynamic array ie.fruits[str1]</span><br>      <span class="hljs-keyword">foreach</span> (fruits[str1][i])<br>        <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;fruits[%s][%0d] = %0d&quot;</span>, str1, i, fruits[str1][i]);<br> <br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SV</tag>
      
      <tag>ChipVerif_Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch2-Packed array</title>
    <link href="/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch02_Data%20type/ch02_packed%20array/"/>
    <url>/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch02_Data%20type/ch02_packed%20array/</url>
    
    <content type="html"><![CDATA[<p>2019-10-24</p><h1 id="SystemVerilog-Packed-Arrays"><a href="#SystemVerilog-Packed-Arrays" class="headerlink" title="SystemVerilog Packed Arrays"></a>SystemVerilog Packed Arrays</h1><p>There are two types of arrays in SystemVerilog - packed and <a href="https://www.chipverify.com/systemverilog/systemverilog-unpacked-arrays">unpacked</a> arrays.</p><p>​    <strong>A <em>packed</em> array is used to refer to dimensions declared before the variable name.</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">bit</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]   data;       <span class="hljs-comment">// Packed array or vector</span><br><span class="hljs-keyword">logic</span>     queue [<span class="hljs-number">9</span>:<span class="hljs-number">0</span>];   <span class="hljs-comment">// Unpacked array</span><br> <br></code></pre></td></tr></table></figure><p>​    A <em>packed</em> array is guaranteed to be represented as a contiguous set of bits. <strong>They can be made of only the single bit data types like <code>bit</code>, <code>logic</code>, and other recursively packed arrays.</strong></p><h2 id="Single-Dimensional-Packed-Arrays"><a href="#Single-Dimensional-Packed-Arrays" class="headerlink" title="Single Dimensional Packed Arrays"></a>Single Dimensional Packed Arrays</h2><p>A one-dimensional packed array is also called as a <a href="https://www.chipverify.com/verilog/verilog-data-types">vector</a>.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb;<br>  <span class="hljs-keyword">bit</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]   m_data;   <span class="hljs-comment">// A vector or 1D packed array</span><br> <br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-comment">// 1. Assign a value to the vector</span><br>    m_data = <span class="hljs-number">8&#x27;hA2</span>; <br> <br>    <span class="hljs-comment">// 2. Iterate through each bit of the vector and print value</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">$size</span>(m_data); i++) <span class="hljs-keyword">begin</span><br>      <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;m_data[%0d] = %b&quot;</span>, i, m_data[i]);<br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="Multidimensional-Packed-Arrays"><a href="#Multidimensional-Packed-Arrays" class="headerlink" title="Multidimensional Packed Arrays"></a>Multidimensional Packed Arrays</h2><p>​    <strong>A <em>multidimensional</em> packed array is still a set of contiguous bits but are also segmented into smaller groups</strong>.</p><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example #1"></a>Example #1</h3><p>The code shown below declares a 2D packed array that occupies 32-bits or 4 bytes and iterates through the segments and prints its value.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb;<br>  <span class="hljs-keyword">bit</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>][<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]   m_data;   <span class="hljs-comment">// A MDA, 4 bytes</span><br> <br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-comment">// 1. Assign a value to the MDA</span><br>    m_data = <span class="hljs-number">32&#x27;hface_cafe</span>;<br> <br>      <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;m_data = 0x%0h&quot;</span>, m_data);<br> <br>    <span class="hljs-comment">// 2. Iterate through each segment of the MDA and print value</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">$size</span>(m_data); i++) <span class="hljs-keyword">begin</span><br>        <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;m_data[%0d] = %b (0x%0h)&quot;</span>, i, m_data[i], m_data[i]);<br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><p><strong>Simulation Log</strong></p><p>注意上面遍历的索引范围是4，代表4个byte。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">ncsim&gt; </span><span class="language-bash">run</span><br>m_data = 0xfacecafe<br>m_data[0] = 11111110 (0xfe)<br>m_data[1] = 11001010 (0xca)<br>m_data[2] = 11001110 (0xce)<br>m_data[3] = 11111010 (0xfa)<br>ncsim: *W,RNQUIE: Simulation is complete.<br></code></pre></td></tr></table></figure><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example #2"></a>Example #2</h3><p>Let us see a 3D packed array now.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb;<br>  <span class="hljs-keyword">bit</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>][<span class="hljs-number">3</span>:<span class="hljs-number">0</span>][<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]   m_data;   <span class="hljs-comment">// An MDA, 12 bytes</span><br> <br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-comment">// 1. Assign a value to the MDA</span><br>      m_data[<span class="hljs-number">0</span>] = <span class="hljs-number">32&#x27;hface_cafe</span>;<br>      m_data[<span class="hljs-number">1</span>] = <span class="hljs-number">32&#x27;h1234_5678</span>;<br>      m_data[<span class="hljs-number">2</span>] = <span class="hljs-number">32&#x27;hc0de_fade</span>;<br> <br>      <span class="hljs-comment">// m_data gets a packed value</span><br>      <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;m_data = 0x%0h&quot;</span>, m_data);<br> <br>    <span class="hljs-comment">// 2. Iterate through each segment of the MDA and print value</span><br>      <span class="hljs-keyword">foreach</span> (m_data[i]) <span class="hljs-keyword">begin</span><br>        <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;m_data[%0d] = 0x%0h&quot;</span>, i, m_data[i]);<br>        <span class="hljs-keyword">foreach</span> (m_data[i][j]) <span class="hljs-keyword">begin</span><br>          <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;m_data[%0d][%0d] = 0x%0h&quot;</span>, i, j, m_data[i][j]);<br>        <span class="hljs-keyword">end</span><br>      <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><p><strong>Simulation Log</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs verilog">ncsim&gt; run<br>m_data = <span class="hljs-number">0</span>xc0defade12345678facecafe<br>m_data[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>xc0defade<br>m_data[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>xc0<br>m_data[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>xde<br>m_data[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>xfa<br>m_data[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>xde<br>m_data[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>x12345678<br>m_data[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>x12<br>m_data[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>x34<br>m_data[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>x56<br>m_data[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>x78<br>m_data[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>xfacecafe<br>m_data[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>xfa<br>m_data[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>xce<br>m_data[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>xca<br>m_data[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>xfe<br>ncsim: *W,RNQUIE: Simulation is complete.<br></code></pre></td></tr></table></figure><p><a href="https://www.edaplayground.com/x/2JWy">Click to try this example in a simulator!  <img src="https://www.chipverify.com/images/site/eda-playground-logo.png" alt="img"></a></p>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SV</tag>
      
      <tag>ChipVerif_Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch2-Queues</title>
    <link href="/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch02_Data%20type/ch02_queue/"/>
    <url>/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch02_Data%20type/ch02_queue/</url>
    
    <content type="html"><![CDATA[<p>2019-10-24</p><h1 id="SystemVerilog-Queues"><a href="#SystemVerilog-Queues" class="headerlink" title="SystemVerilog Queues"></a>SystemVerilog Queues</h1><p>​    A SystemVerilog <em>queue</em> is a <em>First In First Out</em> scheme which can have a variable size to store elements of the same data type.</p><h2 id="Queue-Syntax"><a href="#Queue-Syntax" class="headerlink" title="Queue Syntax"></a>Queue Syntax</h2><p>A queue is distinguished by it’s specification of the size using <strong>$</strong> operator.</p><h2 id="SystemVerilog-Queue-Example"><a href="#SystemVerilog-Queue-Example" class="headerlink" title="SystemVerilog Queue Example"></a>SystemVerilog Queue Example</h2><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb;<br>    <span class="hljs-comment">// Create a queue that can store &quot;string&quot; values</span><br>    <span class="hljs-keyword">string</span>   fruits[$] =  &#123; <span class="hljs-string">&quot;orange&quot;</span>, <span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;kiwi&quot;</span> &#125;;<br> <br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>       <span class="hljs-comment">// Iterate and access each queue element</span><br>      <span class="hljs-keyword">foreach</span> (fruits[i]) <br>        <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;fruits[%0d] = %s&quot;</span>, i, fruits[i]);<br> <br>      <span class="hljs-comment">// Display elements in a queue</span><br>      <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;fruits = %p&quot;</span>, fruits);<br> <br>        <span class="hljs-comment">// Delete all elements in the queue</span><br>        fruits = &#123;&#125;;<br>        <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;After deletion, fruits = %p&quot;</span>, fruits);<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="What-are-queue-slice-expressions"><a href="#What-are-queue-slice-expressions" class="headerlink" title="What are queue slice expressions ?"></a>What are queue slice expressions ?</h2><p>A slice expression selects a subset of the existing variable. Queue elements can be selected using slice expressions as shown in the example below.</p><p><strong>Some simulators provide different results, hence using queue methods is recommended.</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb;<br>  <span class="hljs-comment">// Create a queue that can store &quot;string&quot; values</span><br>  <span class="hljs-keyword">string</span>   fruits[$] =  &#123; <span class="hljs-string">&quot;orange&quot;</span>, <span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;lemon&quot;</span>, <span class="hljs-string">&quot;kiwi&quot;</span> &#125;;<br> <br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-comment">// Select a subset of the queue</span><br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;citrus fruits = %p&quot;</span>, fruits[<span class="hljs-number">1</span>:<span class="hljs-number">2</span>]);<br> <br>    <span class="hljs-comment">// Get elements from index 1 to end of queue</span><br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;fruits = %p&quot;</span>, fruits[<span class="hljs-number">1</span>:$]);<br> <br>    <span class="hljs-comment">// Add element to the end of queue</span><br>    fruits[$+<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;pineapple&quot;</span>;<br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;fruits = %p&quot;</span>, fruits);<br> <br>    <span class="hljs-comment">// Delete first element</span><br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;Remove orange, fruits = %p&quot;</span>, fruits[<span class="hljs-number">1</span>:$]);<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><h2 id="Queue-Methods-Example"><a href="#Queue-Methods-Example" class="headerlink" title="Queue Methods Example"></a>Queue Methods Example</h2><p><img src="https://www.chipverify.com/images/sv/queue.png" alt="queue-methods"></p><p>In addition to array operators, queues provide several built-in methods.</p><table><thead><tr><th align="left">Function</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">function int size ();</td><td align="left">Returns the number of items in the queue, 0 if empty</td></tr><tr><td align="left">function void insert (input integer index, input element_t item);</td><td align="left">Inserts the given item at the specified index position</td></tr><tr><td align="left">function void delete ( [input integer index] );</td><td align="left">Deletes the element at the specified index, and if not provided all elements will be deleted</td></tr><tr><td align="left">function element_t pop_front ();</td><td align="left">Removes and returns the first element of the queue</td></tr><tr><td align="left">function element_t pop_back ();</td><td align="left">Removes and returns the last element of the queue</td></tr><tr><td align="left">function void push_front (input element_t item);</td><td align="left">Inserts the given element at the front of the queue</td></tr><tr><td align="left">function void push_back (input element_t item);</td><td align="left">Inserts the given element at the end of the queues</td></tr></tbody></table><h2 id="How-to-create-a-queue-of-dynamic-arrays-in-SystemVerilog"><a href="#How-to-create-a-queue-of-dynamic-arrays-in-SystemVerilog" class="headerlink" title="How to create a queue of dynamic arrays in SystemVerilog ?"></a>How to create a queue of dynamic arrays in SystemVerilog ?</h2><p><img src="https://www.chipverify.com/images/sv/queue_of_dynamic_arrays.png" alt="queue of dynamic arrays"></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// Declare a dynamic array to store strings as a datatype</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">string</span> str_da [];<br> <br><span class="hljs-keyword">module</span> tb;<br>  <span class="hljs-comment">// This is a queue of dynamic arrays</span><br>  str_da list [$];<br> <br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-comment">// Initialize separate dynamic arrays with some values</span><br>    str_da marvel = &#x27;&#123;<span class="hljs-string">&quot;Spiderman&quot;</span>, <span class="hljs-string">&quot;Hulk&quot;</span>, <span class="hljs-string">&quot;Captain America&quot;</span>, <span class="hljs-string">&quot;Iron Man&quot;</span>&#125;;<br>    str_da dcWorld = &#x27;&#123;<span class="hljs-string">&quot;Batman&quot;</span>, <span class="hljs-string">&quot;Superman&quot;</span> &#125;;<br> <br>    <span class="hljs-comment">// Push the previously created dynamic arrays to queue</span><br>    list<span class="hljs-variable">.push_back</span> (marvel);<br>    list<span class="hljs-variable">.push_back</span> (dcWorld);<br> <br>    <span class="hljs-comment">// Iterate through the queue and access dynamic array elements</span><br>    <span class="hljs-keyword">foreach</span> (list[i])<br>      <span class="hljs-keyword">foreach</span> (list[i][j])<br>        <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;list[%0d][%0d] = %s&quot;</span>, i, j, list[i][j]);<br> <br>    <span class="hljs-comment">// Simply print the queue</span><br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;list = %p&quot;</span>, list);<br>  <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SV</tag>
      
      <tag>ChipVerif_Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch2-Struct</title>
    <link href="/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch02_Data%20type/ch02_struct/"/>
    <url>/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch02_Data%20type/ch02_struct/</url>
    
    <content type="html"><![CDATA[<p>2019-10-24</p><h2 id="What-is-the-need-to-typedef-a-structure"><a href="#What-is-the-need-to-typedef-a-structure" class="headerlink" title="What is the need to typedef a structure ?"></a>What is the need to typedef a structure ?</h2><p>​    Only one variable was created in the example above, but if there’s a need to create multiple structure variables with the same constituents, it’ll be better to create a user defined data type of the structure by <strong><code>typedef</code>.</strong> Then st_fruit will become a data-type which can then be used to create variables of that type.</p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb;  <br>    <span class="hljs-comment">// Create a structure called &quot;st_fruit&quot;</span><br>  <span class="hljs-comment">// which to store the fruit&#x27;s name, count and expiry date in days.</span><br>    <span class="hljs-comment">// Note: this structure declaration can also be placed outside the module</span><br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>      <span class="hljs-keyword">string</span> fruit;<br>      <span class="hljs-keyword">int</span>    count;<br>      <span class="hljs-keyword">byte</span>    expiry;  <br>  &#125; st_fruit;<br> <br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-comment">// st_fruit is a data type, so we need to declare a variable of this data type</span><br>    st_fruit fruit1 = &#x27;&#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>&#125;;<br>    st_fruit fruit2;<br> <br>    <span class="hljs-comment">// Display the structure variable</span><br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;fruit1 = %p fruit2 = %p&quot;</span>, fruit1, fruit2);<br> <br>    <span class="hljs-comment">// Assign one structure variable to another and print</span><br>    <span class="hljs-comment">// Note that contents of this variable is copied into the other</span><br>     fruit2 = fruit1;<br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;fruit1 = %p fruit2 = %p&quot;</span>, fruit1, fruit2);<br> <br>    <span class="hljs-comment">// Change fruit1 to see if fruit2 is affected</span><br>    fruit1<span class="hljs-variable">.fruit</span> = <span class="hljs-string">&quot;orange&quot;</span>;<br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;fruit1 = %p fruit2 = %p&quot;</span>, fruit1, fruit2);<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><p><strong>Simulation Log</strong><a href="https://www.edaplayground.com/x/2wzi">Click to try this example in a simulator!  <img src="https://www.chipverify.com/images/site/eda-playground-logo.png" alt="img"></a></p><h2 id="Packed-Structures"><a href="#Packed-Structures" class="headerlink" title="Packed Structures"></a>Packed Structures</h2><p>A packed structure is a mechanism for subdividing a vector into fields that can be accessed as members and are packed together in memory without gaps. The first member in the structure is the most significant and subsequent members follow in decreasing order of significance.</p><p>A structure is declared packed using the <code>packed</code> keyword which by default is unsigned.</p><p><strong>看下面注释</strong></p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// Create a &quot;packed&quot; structure data type which is similar to creating </span><br><span class="hljs-comment">// bit [7:0]  ctrl_reg;</span><br><span class="hljs-comment">// ctrl_reg [0]   represents en</span><br><span class="hljs-comment">// ctrl_reg [3:1] represents cfg</span><br><span class="hljs-comment">// ctrl_reg [7:4] represents mode</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-keyword">packed</span> &#123;<br>  <span class="hljs-keyword">bit</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] mode;<br>  <span class="hljs-keyword">bit</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] cfg;<br>  <span class="hljs-keyword">bit</span>       en;<br>&#125; st_ctrl;<br> <br><span class="hljs-keyword">module</span> tb;<br>  st_ctrl    ctrl_reg;<br> <br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span> <br>    <span class="hljs-comment">// Initialize packed structure variable</span><br>    ctrl_reg = &#x27;&#123;<span class="hljs-number">4&#x27;ha</span>, <span class="hljs-number">3&#x27;h5</span>, <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;ctrl_reg = %p&quot;</span>, ctrl_reg);<br> <br>    <span class="hljs-comment">// Change packed structure member to something else</span><br>    ctrl_reg<span class="hljs-variable">.mode</span> = <span class="hljs-number">4&#x27;h3</span>;<br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;ctrl_reg = %p&quot;</span>, ctrl_reg);<br> <br>    <span class="hljs-comment">// Assign a packed value to the structure variable</span><br>    ctrl_reg = <span class="hljs-number">8&#x27;hfa</span>;<br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;ctrl_reg = %p&quot;</span>, ctrl_reg);<br>  <span class="hljs-keyword">end</span>  <br><span class="hljs-keyword">endmodule</span>  <br> <br></code></pre></td></tr></table></figure><p><strong>Simulation Log</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada">ncsim&gt; run<br>ctrl_reg = &#x27;&#123;mode:<span class="hljs-symbol">&#x27;ha</span>, cfg:<span class="hljs-symbol">&#x27;h5</span>, en:<span class="hljs-symbol">&#x27;h1</span>&#125;<br>ctrl_reg = &#x27;&#123;mode:<span class="hljs-symbol">&#x27;h3</span>, cfg:<span class="hljs-symbol">&#x27;h5</span>, en:<span class="hljs-symbol">&#x27;h1</span>&#125;<br>ctrl_reg = &#x27;&#123;mode:<span class="hljs-symbol">&#x27;hf</span>, cfg:<span class="hljs-symbol">&#x27;h5</span>, en:<span class="hljs-symbol">&#x27;h0</span>&#125;<br>ncsim: *W,RNQUIE: Simulation <span class="hljs-keyword">is</span> complete.<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SV</tag>
      
      <tag>ChipVerif_Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch2-Unpacked array</title>
    <link href="/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch02_Data%20type/ch02_unpacked%20array/"/>
    <url>/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch02_Data%20type/ch02_unpacked%20array/</url>
    
    <content type="html"><![CDATA[<p>2019-10-24</p><h2 id="Multidimensional-Unpacked-Array"><a href="#Multidimensional-Unpacked-Array" class="headerlink" title="Multidimensional Unpacked Array"></a>Multidimensional Unpacked Array</h2><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb;<br>  <span class="hljs-keyword">byte</span>   stack [<span class="hljs-number">2</span>][<span class="hljs-number">4</span>];     <span class="hljs-comment">// 2 rows, 4 cols</span><br> <br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-comment">// Assign random values to each slot of the stack</span><br>    <span class="hljs-keyword">foreach</span> (stack[i])<br>          <span class="hljs-keyword">foreach</span> (stack[i][j]) <span class="hljs-keyword">begin</span><br>            stack[i][j] = <span class="hljs-built_in">$random</span>;<br>            <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;stack[%0d][%0d] = 0x%0h&quot;</span>, i, j, stack[i][j]);<br>      <span class="hljs-keyword">end</span><br> <br>    <span class="hljs-comment">// Print contents of the stack</span><br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;stack = %p&quot;</span>, stack);<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="Packed-Unpacked-Array"><a href="#Packed-Unpacked-Array" class="headerlink" title="Packed + Unpacked Array"></a>Packed + Unpacked Array</h2><p>The example shown below illustrates a multidimensional packed + unpacked array.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb;<br>  <span class="hljs-keyword">bit</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>][<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]   stack [<span class="hljs-number">2</span>][<span class="hljs-number">4</span>];     <span class="hljs-comment">// 2 rows, 4 cols</span><br> <br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-comment">// Assign random values to each slot of the stack</span><br>    <span class="hljs-keyword">foreach</span> (stack[i])<br>          <span class="hljs-keyword">foreach</span> (stack[i][j]) <span class="hljs-keyword">begin</span><br>            stack[i][j] = <span class="hljs-built_in">$random</span>;<br>            <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;stack[%0d][%0d] = 0x%0h&quot;</span>, i, j, stack[i][j]);<br>      <span class="hljs-keyword">end</span><br> <br>    <span class="hljs-comment">// Print contents of the stack</span><br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;stack = %p&quot;</span>, stack);<br> <br>    <span class="hljs-comment">// Print content of a given index</span><br>        <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;stack[0][0][2] = 0x%0h&quot;</span>, stack[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]);<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><p>​    <strong>In a multidimensional declaration, the dimensions declared before the name vary more faster than the dimensions following the name</strong>.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">bit</span>   [<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]     m_var   [<span class="hljs-number">1</span>:<span class="hljs-number">5</span>]      <span class="hljs-comment">// 1:4 varies faster than 1:5 </span><br><span class="hljs-keyword">bit</span>         m_var2   [<span class="hljs-number">1</span>:<span class="hljs-number">5</span>] [<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]    <span class="hljs-comment">// 1:3 varies faster than 1:5</span><br><span class="hljs-keyword">bit</span>   [<span class="hljs-number">1</span>:<span class="hljs-number">3</span>] [<span class="hljs-number">1</span>:<span class="hljs-number">7</span>] m_var3;         <span class="hljs-comment">// 1:7 varies faster than 1:3</span><br> <br><span class="hljs-keyword">bit</span>   [<span class="hljs-number">1</span>:<span class="hljs-number">3</span>] [<span class="hljs-number">1</span>:<span class="hljs-number">2</span>] m_var4 [<span class="hljs-number">1</span>:<span class="hljs-number">7</span>] [<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]     <span class="hljs-comment">// 1:2 varies most rapidly, followed by 1:3, then 0:2 and then 1:7</span><br> <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SV</tag>
      
      <tag>ChipVerif_Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch3-Case</title>
    <link href="/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch03_Control%20Flow/ch03_case/"/>
    <url>/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch03_Control%20Flow/ch03_case/</url>
    
    <content type="html"><![CDATA[<p>2019-10-24</p><h2 id="unique-unique0-case"><a href="#unique-unique0-case" class="headerlink" title="unique,unique0 case"></a>unique,unique0 case</h2><p>​    All case statements can be qualified by <code>unique</code> or <code>unique0</code> keywords to perform violation checks like we saw in <a href="https://www.chipverify.com/systemverilog/systemverilog-unique-priority-if-else">if-else-if</a> construct.</p><p>​    <code>unique</code> and <code>unique0</code> ensure that there is no overlapping case items and hence can be evaluated in parallel. If there are overlapping case items, then a violation is reported.</p><ul><li>If more than one case item is found to match the given expression, then a violation is reported and the first matching expression is executed</li><li>If no case item is found to match the given expression, then a violation is reported only for <code>unqiue</code></li></ul><p><strong><em>unique</em>0 does not report a violation if no items match the expression</strong></p><h2 id="priority-case"><a href="#priority-case" class="headerlink" title="priority case"></a>priority case</h2><p>类似priority if，如果匹配到零个分支，报错；匹配到第一个分支就退出。</p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb;<br>  <span class="hljs-keyword">bit</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] abc;<br>  <br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    abc = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// First match is executed</span><br>    <span class="hljs-keyword">priority</span> <span class="hljs-keyword">case</span> (abc)<br>      <span class="hljs-number">0</span> : <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;Found to be 0&quot;</span>);<br>      <span class="hljs-number">0</span> : <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;Again found to be 0&quot;</span>);<br>      <span class="hljs-number">2</span> : <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;Found to be 2&quot;</span>);<br>    <span class="hljs-keyword">endcase</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p><strong>Simulation Log</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">ncsim&gt; run<br>Found <span class="hljs-keyword">to</span> <span class="hljs-keyword">be</span> <span class="hljs-number">0</span><br>ncsim: *W,RNQUIE: Simulation <span class="hljs-keyword">is</span> <span class="hljs-built_in">complete</span>.<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SV</tag>
      
      <tag>ChipVerif_Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch3-Event</title>
    <link href="/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch03_Control%20Flow/ch03_event/"/>
    <url>/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch03_Control%20Flow/ch03_event/</url>
    
    <content type="html"><![CDATA[<p>2019-10-24</p><h1 id="SystemVerilog-Event"><a href="#SystemVerilog-Event" class="headerlink" title="SystemVerilog Event"></a>SystemVerilog Event</h1><p>An <code>event</code> is a static object handle <strong>to synchronize</strong> between two or more concurrently active processes. One process will <em>trigger</em> the event, and another process <em>waits</em> for the event.</p><ul><li><p><strong>Can be assigned or compared to other event variables</strong></p></li><li><ul><li><strong>Can be assigned to <code>null</code></strong></li><li><strong>When assigned to another event, both variables point to same synchronization object</strong></li></ul></li><li><p><strong>Can be passed to queues, functions and tasks</strong></p></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">event</span>  over;                     <span class="hljs-comment">// a new event is created called over</span><br><span class="hljs-keyword">event</span>  over_again = over;        <span class="hljs-comment">// over_again becomes an alias to over</span><br><span class="hljs-keyword">event</span>  empty = <span class="hljs-literal">null</span>;             <span class="hljs-comment">// event variable with no synchronization object</span><br> <br></code></pre></td></tr></table></figure><h2 id="How-to-trigger-and-wait-for-an-event"><a href="#How-to-trigger-and-wait-for-an-event" class="headerlink" title="How to trigger and wait for an event?"></a>How to trigger and wait for an event?</h2><ul><li>Named events can be triggered using <code>-&gt;</code> or <code>-&gt;&gt;</code> operator</li><li>Processes can wait for an event using <code>@</code> operator or <code>.triggered</code></li></ul><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb;<br> <br>  <span class="hljs-comment">// Create an event variable that processes can use to trigger and wait</span><br>  <span class="hljs-keyword">event</span> event_a;<br> <br>  <span class="hljs-comment">// Thread1: Triggers the event using &quot;-&gt;&quot; operator</span><br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    #<span class="hljs-number">20</span> -&gt;event_a;<br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t] Thread1: triggered event_a&quot;</span>, <span class="hljs-built_in">$time</span>);<br>  <span class="hljs-keyword">end</span><br> <br>  <span class="hljs-comment">// Thread2: Waits for the event using &quot;@&quot; operator</span><br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t] Thread2: waiting for trigger &quot;</span>, <span class="hljs-built_in">$time</span>);<br>    @(event_a);<br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t] Thread2: received event_a trigger &quot;</span>, <span class="hljs-built_in">$time</span>);<br>  <span class="hljs-keyword">end</span><br> <br>  <span class="hljs-comment">// Thread3: Waits for the event using &quot;.triggered&quot;</span><br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t] Thread3: waiting for trigger &quot;</span>, <span class="hljs-built_in">$time</span>);<br>    <span class="hljs-keyword">wait</span>(event_a<span class="hljs-variable">.triggered</span>);<br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t] Thread3: received event_a trigger&quot;</span>, <span class="hljs-built_in">$time</span>);<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span>  <br> <br></code></pre></td></tr></table></figure><p><strong>Simulation Log</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">ncsim&gt; run<br><span class="hljs-string">[0]</span> Thread2: waiting <span class="hljs-keyword">for</span> trigger <br><span class="hljs-string">[0]</span> Thread3: waiting <span class="hljs-keyword">for</span> trigger <br><span class="hljs-string">[20]</span> Thread1: triggered event_a<br><span class="hljs-string">[20]</span> Thread2: received event_a trigger <br><span class="hljs-string">[20]</span> Thread3: received event_a trigger<br>ncsim: *W,RNQUIE: Simulation <span class="hljs-keyword">is</span> complete.<br></code></pre></td></tr></table></figure><p><a href="https://www.edaplayground.com/x/eX_">Click to try this example in a simulator!  <img src="https://www.chipverify.com/images/site/eda-playground-logo.png" alt="img"></a></p><h2 id="What-is-the-difference-between-and-triggered"><a href="#What-is-the-difference-between-and-triggered" class="headerlink" title="What is the difference between @ and .triggered ?"></a>What is the difference between @ and .triggered ?</h2><p>​    <strong>An event’s <code>triggered</code> state persists throughout the time step（triggered状态在时间片内都敏感）</strong>, until simulation advances. <strong>Hence if both <code>wait</code> for the event and trigger of the event happens at the same time there will be a race condition and the <code>triggered</code> property helps to avoid that.</strong></p><p>A process that waits on the <code>triggered</code> state always unblocks, regardless of the order of wait and trigger.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb;<br> <br>  <span class="hljs-comment">// Create an event variable that processes can use to trigger and wait</span><br>  <span class="hljs-keyword">event</span> event_a;<br> <br>  <span class="hljs-comment">// Thread1: Triggers the event using &quot;-&gt;&quot; operator at 20ns</span><br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    #<span class="hljs-number">20</span> -&gt;event_a;<br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t] Thread1: triggered event_a&quot;</span>, <span class="hljs-built_in">$time</span>);<br>  <span class="hljs-keyword">end</span><br> <br>  <span class="hljs-comment">// Thread2: Starts waiting for the event using &quot;@&quot; operator at 20ns</span><br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t] Thread2: waiting for trigger &quot;</span>, <span class="hljs-built_in">$time</span>);<br>    #<span class="hljs-number">20</span> @(event_a);<br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t] Thread2: received event_a trigger &quot;</span>, <span class="hljs-built_in">$time</span>);<br>  <span class="hljs-keyword">end</span><br> <br>  <span class="hljs-comment">// Thread3: Starts waiting for the event using &quot;.triggered&quot; at 20ns</span><br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t] Thread3: waiting for trigger &quot;</span>, <span class="hljs-built_in">$time</span>);<br>    #<span class="hljs-number">20</span> <span class="hljs-keyword">wait</span>(event_a<span class="hljs-variable">.triggered</span>);<br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t] Thread3: received event_a trigger&quot;</span>, <span class="hljs-built_in">$time</span>);<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><p>Note that Thread2 never received a trigger, because of the race condition between <code>@</code> and <code>-&gt;</code> operations.<strong>（但是triggered状态能够采样到-&gt;操作）</strong></p><p><strong>Simulation Log</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">ncsim&gt; run<br><span class="hljs-string">[0]</span> Thread2: waiting <span class="hljs-keyword">for</span> trigger <br><span class="hljs-string">[0]</span> Thread3: waiting <span class="hljs-keyword">for</span> trigger <br><span class="hljs-string">[20]</span> Thread1: triggered event_a<br><span class="hljs-string">[20]</span> Thread3: received event_a trigger<br>ncsim: *W,RNQUIE: Simulation <span class="hljs-keyword">is</span> complete.<br></code></pre></td></tr></table></figure><p><a href="https://www.edaplayground.com/x/4uCK">Click to try this example in a simulator!  <img src="https://www.chipverify.com/images/site/eda-playground-logo.png" alt="img"></a></p><h2 id="wait-order（顺序触发）"><a href="#wait-order（顺序触发）" class="headerlink" title="wait_order（顺序触发）"></a>wait_order（顺序触发）</h2><p>Waits for events to be triggered in the given order, and issues an error if any event executes out of order.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb;<br>  <span class="hljs-comment">// Declare three events that can be triggered separately</span><br>  <span class="hljs-keyword">event</span> a, b, c;<br> <br>  <span class="hljs-comment">// This block triggers each event one by one</span><br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    #<span class="hljs-number">10</span> -&gt; a;<br>    #<span class="hljs-number">10</span> -&gt; b;<br>    #<span class="hljs-number">10</span> -&gt; c;<br>  <span class="hljs-keyword">end</span><br> <br>  <span class="hljs-comment">// This block waits until each event is triggered in the given order</span><br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br> <br>    <span class="hljs-keyword">wait_order</span> (a,b,c) <br>      <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;Events were executed in the correct order&quot;</span>);<br>    <span class="hljs-keyword">else</span> <br>        <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;Events were NOT executed in the correct order !&quot;</span>);  <br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><p><strong>Simulation Log</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Compiler</span> version J-<span class="hljs-number">2014</span>.<span class="hljs-number">12</span>-SP1-<span class="hljs-number">1</span>; Runtime version J-<span class="hljs-number">2014</span>.<span class="hljs-number">12</span>-SP1-<span class="hljs-number">1</span>;<br><span class="hljs-attribute">Events</span> were executed in the correct order<br>           <span class="hljs-attribute">V</span> C S   S i m u l a t i o n   R e p o r t <br></code></pre></td></tr></table></figure><p><a href="https://www.edaplayground.com/x/4TZp">Click to try this example in a simulator!  <img src="https://www.chipverify.com/images/site/eda-playground-logo.png" alt="img"></a></p><h2 id="Merging-Events"><a href="#Merging-Events" class="headerlink" title="Merging Events"></a>Merging Events</h2><p>When one event variable is assigned to another, all processes waiting for the first event to trigger will wait until the second variable is triggered.（这句话不知道是什么鸟语，看下面程序的执行结果和自己的理解，就是事件赋值而已）。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb;<br> <br>  <span class="hljs-comment">// Create event variables</span><br>  <span class="hljs-keyword">event</span> event_a, event_b;<br> <br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">fork</span><br>      <span class="hljs-comment">// Thread1: waits for event_a to be triggered</span><br>      <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">wait</span>(event_a<span class="hljs-variable">.triggered</span>);<br>        <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t] Thread1: Wait for event_a is over&quot;</span>, <span class="hljs-built_in">$time</span>);<br>      <span class="hljs-keyword">end</span><br>      <span class="hljs-comment">// Thread2: waits for event_b to be triggered    </span><br>      <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">wait</span>(event_b<span class="hljs-variable">.triggered</span>);<br>        <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t] Thread2: Wait for event_b is over&quot;</span>, <span class="hljs-built_in">$time</span>);<br>      <span class="hljs-keyword">end</span><br> <br>      <span class="hljs-comment">// Thread3: triggers event_a at 20ns</span><br>      #<span class="hljs-number">20</span> -&gt;event_a;<br> <br>      <span class="hljs-comment">// Thread4: triggers event_b at 30ns</span><br>      #<span class="hljs-number">30</span> -&gt;event_b;<br> <br>      <span class="hljs-comment">// Thread5: Assigns event_b to event_a at 10ns</span><br>      <span class="hljs-keyword">begin</span><br>        <span class="hljs-comment">// Comment code below and try again to see Thread2 finish later</span><br>        #<span class="hljs-number">10</span> event_b = event_a;<br>      <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">join</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><p><strong>Simulation Log</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog">ncsim&gt; run<br>[<span class="hljs-number">20</span>] Thread1: Wait <span class="hljs-keyword">for</span> event_a is over<br>[<span class="hljs-number">20</span>] Thread2: Wait <span class="hljs-keyword">for</span> event_b is over<br>ncsim: *W,RNQUIE: Simulation is complete.<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SV</tag>
      
      <tag>ChipVerif_Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch3-Function</title>
    <link href="/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch03_Control%20Flow/ch03_function/"/>
    <url>/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch03_Control%20Flow/ch03_function/</url>
    
    <content type="html"><![CDATA[<p>2019-10-24</p><h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><p>The primary purpose of a <code>function</code> is to <strong>return a value</strong> that can be used in an expression and <strong>cannot</strong> consume simulation time.</p><ul><li><strong>A function cannot have time controlled statements like <code>@</code>, <code>#</code>, <code>fork join</code>, or <code>wait</code></strong></li><li><strong>A function cannot start a task since tasks are allowed to consume simulation time</strong></li></ul><p><a href="https://www.chipverify.com/verilog/verilog-functions">Click here to refresh functions in Verilog !</a></p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb;<br> <br>    <span class="hljs-comment">// There are two ways to call the function:</span><br>    <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>      <span class="hljs-comment">// 1. Call function and assign value to a variable, and then use variable</span><br>      <span class="hljs-keyword">int</span> s = sum(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>      <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;sum(3,4) = %0d&quot;</span>, s);<br> <br>      <span class="hljs-comment">// 2. Call function and directly use value returned</span><br>      <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;sum(5,9) = %0d&quot;</span>, sum(<span class="hljs-number">5</span>,<span class="hljs-number">9</span>));<br> <br>      <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;mul(3,1) = %0d&quot;</span>, mul(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">end</span><br> <br>    <span class="hljs-comment">// This function returns value of type &quot;byte&quot;, and accepts two </span><br>    <span class="hljs-comment">// arguments &quot;x&quot; and &quot;y&quot;. A return variable of the same name as</span><br>    <span class="hljs-comment">// function is implicitly declared and hence &quot;sum&quot; can be directly</span><br>    <span class="hljs-comment">// assigned without having to declare a separate return variable</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-keyword">byte</span> sum (<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y);<br>    sum = x + y;<br>  <span class="hljs-keyword">endfunction</span><br> <br>    <span class="hljs-comment">// Instead of assigning to &quot;mul&quot;, the computed value can be returned</span><br>    <span class="hljs-comment">// using &quot;return&quot; keyword</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">byte</span> mul (<span class="hljs-keyword">int</span> x, y);<br>        <span class="hljs-keyword">return</span> x * y;<br>    <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><p><strong>Simulation Log</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ncsim</span>&gt; run<br><span class="hljs-attribute">sum</span>(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>) = <span class="hljs-number">7</span><br><span class="hljs-attribute">sum</span>(<span class="hljs-number">5</span>,<span class="hljs-number">9</span>) = <span class="hljs-number">14</span><br><span class="hljs-attribute">mul</span>(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>) = <span class="hljs-number">3</span><br><span class="hljs-attribute">ncsim</span>: *W,RNQUIE: Simulation is complete.<br></code></pre></td></tr></table></figure><p><a href="https://www.edaplayground.com/x/5JTp">Click to try this example in a simulator!  <img src="https://www.chipverify.com/images/site/eda-playground-logo.png" alt="img"></a></p><h3 id="Using-declarations-and-directions"><a href="#Using-declarations-and-directions" class="headerlink" title="Using declarations and directions"></a>Using declarations and directions</h3><p>​    Although ANSI-C style declaration was later introduced in Verilog, the old style declaration of port directions are still valid. SystemVerilog functions can have arguments declared as input and output ports as shown in the example below.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb;<br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">int</span> res, s;<br>        s = sum(<span class="hljs-number">5</span>,<span class="hljs-number">9</span>);<br>      <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;s = %0d&quot;</span>, sum(<span class="hljs-number">5</span>,<span class="hljs-number">9</span>));<br>        <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;sum(5,9) = %0d&quot;</span>, sum(<span class="hljs-number">5</span>,<span class="hljs-number">9</span>));<br>        <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;mul(3,1) = %0d&quot;</span>, mul(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,res));<br>        <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;res = %0d&quot;</span>, res);<br>    <span class="hljs-keyword">end</span><br> <br>  <span class="hljs-comment">// Function has an 8-bit return value and accepts two inputs</span><br>    <span class="hljs-comment">// and provides the result through its output port and return val</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] sum;<br>        <span class="hljs-keyword">input</span> <span class="hljs-keyword">int</span> x, y;<br>        <span class="hljs-keyword">output</span> sum;<br>    sum = x + y;<br>  <span class="hljs-keyword">endfunction</span><br> <br>    <span class="hljs-comment">// Same as above but ports are given inline</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">byte</span> mul (<span class="hljs-keyword">input</span> <span class="hljs-keyword">int</span> x, y, <span class="hljs-keyword">output</span> <span class="hljs-keyword">int</span> res);<br>      res = x*y + <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">return</span> x * y;<br>    <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endmodule</span>  <br></code></pre></td></tr></table></figure><p><strong>参数方向：input、output、inout、ref四种。</strong></p><h2 id="Difference-between-function-and-task"><a href="#Difference-between-function-and-task" class="headerlink" title="Difference between function and task"></a>Difference between <code>function</code> and <code>task</code></h2><table><thead><tr><th align="left">Function</th><th align="left">Task</th></tr></thead><tbody><tr><td align="left">Cannot have time-controlling statements&#x2F;delay, and hence executes in the same simulation time unit</td><td align="left">Can contain time-controlling statements&#x2F;delay and may only complete at some other time</td></tr><tr><td align="left">Cannot enable a task</td><td align="left">Can enable other tasks and functions</td></tr><tr><td align="left">Should have atleast one input argument and cannot have output or inout arguments</td><td align="left">Can have zero or more arguments of any type</td></tr><tr><td align="left">Can return only a single value</td><td align="left">Cannot return a value, but can achieve the same effect using output arguments</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SV</tag>
      
      <tag>ChipVerif_Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch3-If else</title>
    <link href="/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch03_Control%20Flow/ch03_if_else/"/>
    <url>/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch03_Control%20Flow/ch03_if_else/</url>
    
    <content type="html"><![CDATA[<p>2019-10-24</p><h1 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h1><h2 id="unique-if-unique0-if"><a href="#unique-if-unique0-if" class="headerlink" title="unique-if, unique0-if"></a>unique-if, unique0-if</h2><p><code>unique-if</code> evaluates conditions in any order and does the following :</p><ul><li>report an error when none of the <code>if</code> conditions match unless there is an explicit <code>else</code>.</li><li>report an erorr when there is more than 1 match found in the <code>if else</code> conditions</li></ul><p><strong>Unlike <em>unique-if</em>, <em>unique0-if</em> does not report a violation if none of the conditions match</strong></p><p><strong>unique-if：有且只有一个分支匹配。</strong></p><p><strong>unique0-if：有一个或者零个分支被匹配。</strong></p><h3 id="No-else-block-for-unique-if"><a href="#No-else-block-for-unique-if" class="headerlink" title="No else block for unique-if"></a>No else block for unique-if</h3><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb;<br>  <span class="hljs-keyword">int</span> x = <span class="hljs-number">4</span>;<br> <br>    <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>        <span class="hljs-comment">// This if else if construct is declared to be &quot;unique&quot;</span><br>    <span class="hljs-comment">// Error is not reported here because there is a &quot;else&quot;</span><br>        <span class="hljs-comment">// clause in the end which will be triggered when none of</span><br>        <span class="hljs-comment">// the conditions match</span><br>      <span class="hljs-keyword">unique</span> <span class="hljs-keyword">if</span> (x == <span class="hljs-number">3</span>) <br>          <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;x is %0d&quot;</span>, x);<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x == <span class="hljs-number">5</span>)<br>          <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;x is %0d&quot;</span>, x);<br>        <span class="hljs-keyword">else</span><br>          <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;x is neither 3 nor 5&quot;</span>);      <br> <br>        <span class="hljs-comment">// When none of the conditions become true and there</span><br>        <span class="hljs-comment">// is no &quot;else&quot; clause, then an error is reported</span><br>      <span class="hljs-keyword">unique</span> <span class="hljs-keyword">if</span> (x == <span class="hljs-number">3</span>) <br>          <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;x is %0d&quot;</span>, x);<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x == <span class="hljs-number">5</span>)<br>          <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;x is %0d&quot;</span>, x);<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span>  <br> <br></code></pre></td></tr></table></figure><p><strong>Simulation Log</strong></p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">ncsim&gt; run<br>x <span class="hljs-keyword">is</span> neither <span class="hljs-number">3</span> <span class="hljs-keyword">nor</span> <span class="hljs-number">5</span><br>ncsim: *W,NOCOND: Unique <span class="hljs-keyword">if</span> violation:  Every <span class="hljs-keyword">if</span> clause was <span class="hljs-literal">false</span>.<br>            <span class="hljs-keyword">File</span>: ./testbench.sv, <span class="hljs-literal">line</span> = <span class="hljs-number">18</span>, pos = <span class="hljs-number">13</span><br>           Scope: tb<br>            <span class="hljs-built_in">Time</span>: <span class="hljs-number">0</span> FS + <span class="hljs-number">1</span><br><br>ncsim: *W,RNQUIE: Simulation <span class="hljs-keyword">is</span> complete.<br></code></pre></td></tr></table></figure><h2 id="priority-if"><a href="#priority-if" class="headerlink" title="priority-if"></a>priority-if</h2><p><code>priority-if</code> evaluates all conditions in sequential order and a violation is reported when:</p><ul><li><strong>None of the conditions are true or if there’s no <code>else</code> clause to the final <code>if</code> construct</strong></li></ul><p><strong>第一次匹配成功立即退出if-else。</strong></p><h3 id="No-else-clause-in-priority-if"><a href="#No-else-clause-in-priority-if" class="headerlink" title="No else clause in priority-if"></a>No else clause in priority-if</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb;<br>  <span class="hljs-keyword">int</span> x = <span class="hljs-number">4</span>;<br> <br>    <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>        <span class="hljs-comment">// This if else if construct is declared to be &quot;unique&quot;</span><br>    <span class="hljs-comment">// Error is not reported here because there is a &quot;else&quot;</span><br>        <span class="hljs-comment">// clause in the end which will be triggered when none of</span><br>        <span class="hljs-comment">// the conditions match</span><br>      <span class="hljs-keyword">priority</span> <span class="hljs-keyword">if</span> (x == <span class="hljs-number">3</span>) <br>          <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;x is %0d&quot;</span>, x);<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x == <span class="hljs-number">5</span>)<br>          <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;x is %0d&quot;</span>, x);<br>        <span class="hljs-keyword">else</span><br>          <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;x is neither 3 nor 5&quot;</span>);      <br> <br>        <span class="hljs-comment">// When none of the conditions become true and there</span><br>        <span class="hljs-comment">// is no &quot;else&quot; clause, then an error is reported</span><br>      <span class="hljs-keyword">priority</span> <span class="hljs-keyword">if</span> (x == <span class="hljs-number">3</span>) <br>          <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;x is %0d&quot;</span>, x);<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x == <span class="hljs-number">5</span>)<br>          <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;x is %0d&quot;</span>, x);<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span>  <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SV</tag>
      
      <tag>ChipVerif_Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch4-Fork join</title>
    <link href="/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch04_process/ch04_fork_join/"/>
    <url>/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch04_process/ch04_fork_join/</url>
    
    <content type="html"><![CDATA[<p>2019-10-24</p><h1 id="三种fork"><a href="#三种fork" class="headerlink" title="三种fork"></a>三种fork</h1><h2 id="What-are-different-fork-join-styles"><a href="#What-are-different-fork-join-styles" class="headerlink" title="What are different fork - join styles ?"></a>What are different fork - join styles ?</h2><p>We have three different styles of <code>fork join</code> in SystemVerilog.</p><p><img src="https://www.chipverify.com/images/uvm-tutorial/fork-join.png" alt="fork-join"></p><table><thead><tr><th><a href="https://www.chipverify.com/systemverilog/systemverilog-threads#fork-join-example">fork join</a></th><th>Finishes when all child threads are over</th></tr></thead><tbody><tr><td><a href="https://www.chipverify.com/systemverilog/systemverilog-threads#fork-join-any-example">fork join_any</a></td><td>Finishes when any child thread gets over</td></tr><tr><td><a href="https://www.chipverify.com/systemverilog/systemverilog-threads#fork-join-none-example">fork join_none</a></td><td>Finishes soon after child threads are spawned</td></tr></tbody></table><h1 id="disable-fork"><a href="#disable-fork" class="headerlink" title="disable fork"></a>disable fork</h1><h2 id="What-happens-when-fork-is-disabled"><a href="#What-happens-when-fork-is-disabled" class="headerlink" title="What happens when fork is disabled ?"></a>What happens when fork is disabled ?</h2><p>The same example is taken from above, and <code>disable fork</code> is added towards the end.</p><p>Note that Thread2 and Thread3 got killed because of <code>disable fork</code></p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb_top;<br> <br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>       <span class="hljs-comment">// Fork off 3 sub-threads in parallel and the currently executing main thread</span><br>        <span class="hljs-comment">// will finish when any of the 3 sub-threads have finished.</span><br>    <span class="hljs-keyword">fork</span><br> <br>         <span class="hljs-comment">// Thread1 : Will finish first at time 40ns</span><br>         #<span class="hljs-number">40</span> <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t ns] Show #40 $display statement&quot;</span>, <span class="hljs-built_in">$time</span>);    <br> <br>         <span class="hljs-comment">// Thread2 : Will finish at time 70ns</span><br>         <span class="hljs-keyword">begin</span><br>            #<span class="hljs-number">20</span> <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t ns] Show #20 $display statement&quot;</span>, <span class="hljs-built_in">$time</span>);<br>            #<span class="hljs-number">50</span> <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t ns] Show #50 $display statement&quot;</span>, <span class="hljs-built_in">$time</span>);<br>         <span class="hljs-keyword">end</span><br> <br>         <span class="hljs-comment">// Thread3 : Will finish at time 60ns</span><br>          #<span class="hljs-number">60</span> <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t ns] TIMEOUT&quot;</span>, <span class="hljs-built_in">$time</span>);<br>      <span class="hljs-keyword">join_any</span><br> <br>      <span class="hljs-comment">// Display as soon as the fork is done</span><br>      <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0tns] Fork join is done, let&#x27;s disable fork&quot;</span>, <span class="hljs-built_in">$time</span>);      <br> <br>      <span class="hljs-keyword">disable</span> <span class="hljs-keyword">fork</span>;<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><p><strong>Simulation Log</strong></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gauss">ncsim&gt; <span class="hljs-keyword">run</span><br>[<span class="hljs-number">20</span> ns] <span class="hljs-keyword">Show</span> <span class="hljs-meta">#20 $display statement</span><br>[<span class="hljs-number">40</span> ns] <span class="hljs-keyword">Show</span> <span class="hljs-meta">#40 $display statement</span><br>[<span class="hljs-number">40</span>ns] Fork join is done, <span class="hljs-keyword">let</span>&#x27;s <span class="hljs-keyword">disable</span> fork<br>ncsim: *W,RNQUIE: Simulation is complete.<br>ncsim&gt; exit<br></code></pre></td></tr></table></figure><h1 id="wait-fork"><a href="#wait-fork" class="headerlink" title="wait fork"></a>wait fork</h1><p><strong><code>wait fork</code> allows the main process to <em>wait</em> until all forked processes are over.</strong> This is useful in cases where the main process has to spawn multiple threads, and perform some function before waiting for all threads to finish.</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb_top;<br> <br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-comment">// Fork off 3 sub-threads in parallel and the currently executing main thread</span><br>    <span class="hljs-comment">// will finish when any of the 3 sub-threads have finished.</span><br>    <span class="hljs-keyword">fork</span><br> <br>      <span class="hljs-comment">// Thread1 : Will finish first at time 40ns</span><br>      #<span class="hljs-number">40</span> <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t ns] Show #40 $display statement&quot;</span>, <span class="hljs-built_in">$time</span>);    <br> <br>      <span class="hljs-comment">// Thread2 : Will finish at time 70ns</span><br>      <span class="hljs-keyword">begin</span><br>        #<span class="hljs-number">20</span> <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t ns] Show #20 $display statement&quot;</span>, <span class="hljs-built_in">$time</span>);<br> <br>        #<span class="hljs-number">50</span> <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t ns] Show #50 $display statement&quot;</span>, <span class="hljs-built_in">$time</span>);<br>      <span class="hljs-keyword">end</span><br> <br>      <span class="hljs-comment">// Thread3 : Will finish at time 60ns</span><br>      #<span class="hljs-number">60</span> <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t ns] TIMEOUT&quot;</span>, <span class="hljs-built_in">$time</span>);<br>    <span class="hljs-keyword">join_any</span><br> <br>        <span class="hljs-comment">// Display as soon as the fork is done</span><br>        <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t ns] Fork join is done, wait fork to end&quot;</span>, <span class="hljs-built_in">$time</span>);<br> <br>        <span class="hljs-comment">// Fork two more processes</span><br>        <span class="hljs-keyword">fork</span><br>          #<span class="hljs-number">10</span> <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t ns] Wait for 10&quot;</span>, <span class="hljs-built_in">$time</span>);<br>          #<span class="hljs-number">20</span> <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t ns] Wait for 20&quot;</span>, <span class="hljs-built_in">$time</span>);<br>        <span class="hljs-keyword">join_any</span><br> <br>        <span class="hljs-comment">// Wait until ALL forked processes are over</span><br>        <span class="hljs-keyword">wait</span> <span class="hljs-keyword">fork</span>;<br>        <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t ns] Fork join is over&quot;</span>, <span class="hljs-built_in">$time</span>);<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><p><strong>Simulation Log</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp">ncsim&gt; run<br>[<span class="hljs-meta">20 ns</span>] Show <span class="hljs-meta">#20 $display statement</span><br>[<span class="hljs-meta">40 ns</span>] Show <span class="hljs-meta">#40 $display statement</span><br>[<span class="hljs-meta">40 ns</span>] Fork <span class="hljs-keyword">join</span> <span class="hljs-keyword">is</span> done, wait fork to end<br>[<span class="hljs-meta">50 ns</span>] Wait <span class="hljs-keyword">for</span> <span class="hljs-number">10</span><br>[<span class="hljs-meta">60 ns</span>] TIMEOUT<br>[<span class="hljs-meta">60 ns</span>] Wait <span class="hljs-keyword">for</span> <span class="hljs-number">20</span><br>[<span class="hljs-meta">70 ns</span>] Show <span class="hljs-meta">#50 $display statement</span><br>[<span class="hljs-meta">70 ns</span>] Fork <span class="hljs-keyword">join</span> <span class="hljs-keyword">is</span> over<br>ncsim: *W,RNQUIE: Simulation <span class="hljs-keyword">is</span> complete.<br></code></pre></td></tr></table></figure><p><a href="https://www.edaplayground.com/x/3q6s">Click to try this example in a simulator!  <img src="https://www.chipverify.com/images/site/eda-playground-logo.png" alt="img"></a></p>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SV</tag>
      
      <tag>ChipVerif_Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch5-Semaphore</title>
    <link href="/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch05_communication/ch05_Semaphore/"/>
    <url>/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch05_communication/ch05_Semaphore/</url>
    
    <content type="html"><![CDATA[<p>2019-10-30</p><h1 id="SystemVerilog-Semaphore"><a href="#SystemVerilog-Semaphore" class="headerlink" title="SystemVerilog Semaphore"></a>SystemVerilog Semaphore</h1><p>​    Semaphore is just like a bucket with a fixed number of keys. Processes that use a semaphore must first get a key from the bucket before they can continue to exectute. Other proceses must wait until keys are available in the bucket for them to use. In a sense, they are best used for mutual exclusion, access control to shared resources and basic synchronization.</p><h2 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h2><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog">semaphore   [identifier_name];<br> <br></code></pre></td></tr></table></figure><p>Note that <code>semaphore</code> is a <strong>built-in class</strong> and hence it should be used just like any other class object. It has a few methods with which we can allocate the number of keys for that <code>semaphore</code> object, get and put keys into the bucket.</p><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><table><thead><tr><th align="left">Name</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">function new (int keyCount &#x3D; 0);</td><td align="left">Specifies number of keys initially allocated to the semaphore bucket</td></tr><tr><td align="left"><strong>function</strong> void put (int keyCount &#x3D; 1);</td><td align="left">Specifies the number of keys being returned to the semaphore</td></tr><tr><td align="left"><strong>task</strong> get (int keyCount &#x3D; 1);</td><td align="left">Specifies the number of keys to obtain from the semaphore</td></tr><tr><td align="left">function int try_get (int keyCount &#x3D; 1);</td><td align="left">Specifies the required number of keys to obtain from the semaphore</td></tr></tbody></table><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb_top;<br>   semaphore key;<br> <br>   <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span> <br>      key = <span class="hljs-keyword">new</span> (<span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">fork</span><br>         personA ();<br>         personB ();<br>         #<span class="hljs-number">25</span> personA ();<br>      <span class="hljs-keyword">join_none</span><br>   <span class="hljs-keyword">end</span><br> <br>   <span class="hljs-keyword">task</span> getRoom (<span class="hljs-keyword">bit</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] id);<br>      <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t] Trying to get a room for id[%0d] ...&quot;</span>, <span class="hljs-built_in">$time</span>, id);<br>      key<span class="hljs-variable">.get</span> (<span class="hljs-number">1</span>);<br>      <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t] Room Key retrieved for id[%0d]&quot;</span>, <span class="hljs-built_in">$time</span>, id);<br>   <span class="hljs-keyword">endtask</span><br> <br>   <span class="hljs-keyword">task</span> putRoom (<span class="hljs-keyword">bit</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] id);<br>      <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t] Leaving room id[%0d] ...&quot;</span>, <span class="hljs-built_in">$time</span>, id);<br>      key<span class="hljs-variable">.put</span> (<span class="hljs-number">1</span>);<br>      <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t] Room Key put back id[%0d]&quot;</span>, <span class="hljs-built_in">$time</span>, id);<br>   <span class="hljs-keyword">endtask</span><br> <br>   <span class="hljs-keyword">task</span> personA ();<br>      getRoom (<span class="hljs-number">1</span>);<br>      #<span class="hljs-number">20</span> putRoom (<span class="hljs-number">1</span>);<br>   <span class="hljs-keyword">endtask</span><br> <br>   <span class="hljs-keyword">task</span> personB ();<br>      #<span class="hljs-number">5</span>  getRoom (<span class="hljs-number">2</span>);<br>      #<span class="hljs-number">10</span> putRoom (<span class="hljs-number">2</span>);<br>   <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><p><strong>Simulation Log</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[0]</span> Trying to get a <span class="hljs-keyword">room</span> for id<span class="hljs-comment">[1]</span> ...<br><span class="hljs-comment">[0]</span> <span class="hljs-keyword">Room</span> Key retrieved for id<span class="hljs-comment">[1]</span><br><span class="hljs-comment">[5]</span> Trying to get a <span class="hljs-keyword">room</span> for id<span class="hljs-comment">[2]</span> ...<br><span class="hljs-comment">[20]</span> Leaving <span class="hljs-keyword">room</span> id<span class="hljs-comment">[1]</span> ...<br><span class="hljs-comment">[20]</span> <span class="hljs-keyword">Room</span> Key put back id<span class="hljs-comment">[1]</span><br><span class="hljs-comment">[20]</span> <span class="hljs-keyword">Room</span> Key retrieved for id<span class="hljs-comment">[2]</span><br><span class="hljs-comment">[25]</span> Trying to get a <span class="hljs-keyword">room</span> for id<span class="hljs-comment">[1]</span> ...<br><span class="hljs-comment">[30]</span> Leaving <span class="hljs-keyword">room</span> id<span class="hljs-comment">[2]</span> ...<br><span class="hljs-comment">[30]</span> <span class="hljs-keyword">Room</span> Key put back id<span class="hljs-comment">[2]</span><br><span class="hljs-comment">[30]</span> <span class="hljs-keyword">Room</span> Key retrieved for id<span class="hljs-comment">[1]</span><br><span class="hljs-comment">[50]</span> Leaving <span class="hljs-keyword">room</span> id<span class="hljs-comment">[1]</span> ...<br><span class="hljs-comment">[50]</span> <span class="hljs-keyword">Room</span> Key put back id<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SV</tag>
      
      <tag>ChipVerif_Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch5-Interprocess Communication</title>
    <link href="/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch05_communication/ch05_Interprocess%20Communication/"/>
    <url>/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch05_communication/ch05_Interprocess%20Communication/</url>
    
    <content type="html"><![CDATA[<p>2019-10-24</p><h1 id="SystemVerilog-Interprocess-Communication"><a href="#SystemVerilog-Interprocess-Communication" class="headerlink" title="SystemVerilog Interprocess Communication"></a>SystemVerilog Interprocess Communication</h1><p>​    Components in a testbench often need to communicate with each other to exchange data and check output values of the design. A few mechanisms that allow components or threads to affect the control flow of data are shown in the table below.</p><table><thead><tr><th>Events</th><th>Different threads synchronize with each other via event handles in a testbench</th></tr></thead><tbody><tr><td>Semaphores</td><td>Different threads might need to access the same resource; they take turns by using a semaphore</td></tr><tr><td>Mailbox</td><td>Threads&#x2F;Components need to exchange data with each other; data is put in a mailbox and sent</td></tr></tbody></table><h2 id="What-are-Events"><a href="#What-are-Events" class="headerlink" title="What are Events ?"></a>What are Events ?</h2><p>An event is a way to synchronize two or more different processes. One process waits for the <em>event</em> to happen while another process triggers the event. When the <code>event</code> is triggered, the process waiting for the event will resume execution.</p><p><strong>1. Create an event using</strong> </p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">event</span>   eventA;    <span class="hljs-comment">// Creates an event called &quot;eventA&quot;</span><br></code></pre></td></tr></table></figure><p><strong>2. Trigger an event using <code>-&gt;</code> operator</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog">-&gt;eventA;     <span class="hljs-comment">// Any process that has access to &quot;eventA&quot; can trigger the event</span><br> <br></code></pre></td></tr></table></figure><p><strong>3. Wait for event to happen</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog">@eventA;             <span class="hljs-comment">// Use &quot;@&quot; operator to wait for an event</span><br>  <span class="hljs-keyword">wait</span> (eventA<span class="hljs-variable">.triggered</span>);    <span class="hljs-comment">// Or use the wait statement with &quot;eventA.triggered&quot; </span><br></code></pre></td></tr></table></figure><p><strong>4. Pass events as arguments to functions</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb_top;<br>  <span class="hljs-keyword">event</span> eventA;     <span class="hljs-comment">// Declare an event handle called  &quot;eventA&quot;</span><br> <br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>     <br>    <span class="hljs-keyword">fork</span> <br>      waitForTrigger (eventA);    <span class="hljs-comment">// Task waits for eventA to happen</span><br>      #<span class="hljs-number">5</span> -&gt;eventA;                <span class="hljs-comment">// Triggers eventA</span><br>    <span class="hljs-keyword">join</span><br>  <span class="hljs-keyword">end</span><br> <br>  <span class="hljs-comment">// The event is passed as an argument to this task. It simply waits for the event </span><br>  <span class="hljs-comment">// to be triggered</span><br>  <span class="hljs-keyword">task</span> waitForTrigger (<span class="hljs-keyword">event</span> eventA);<br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t] Waiting for EventA to be triggered&quot;</span>, <span class="hljs-built_in">$time</span>);<br>    <span class="hljs-keyword">wait</span> (eventA<span class="hljs-variable">.triggered</span>);<br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t] EventA has triggered&quot;</span>, <span class="hljs-built_in">$time</span>);<br>  <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><p><strong>Simulation Log</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">[<span class="hljs-number">20</span>] Waiting <span class="hljs-keyword">for</span> EventA <span class="hljs-keyword">to</span> <span class="hljs-keyword">be</span> triggered<br>[<span class="hljs-number">25</span>] EventA <span class="hljs-built_in">has</span> triggered<br>ncsim: *W,RNQUIE: Simulation <span class="hljs-keyword">is</span> <span class="hljs-built_in">complete</span>.<br></code></pre></td></tr></table></figure><h2 id="What’s-a-semaphore"><a href="#What’s-a-semaphore" class="headerlink" title="What’s a semaphore ?"></a>What’s a semaphore ?</h2><p>Let’s say you wanted to rent a room in the library for a few hours. The admin desk will give you a key to use the room for the time you have requested access. After you are done with your work, you will return the key to the admin, which will then be given to someone else who wants to use the same room. This way two people will not be allowed to use the room at the same time. The <em>key</em> is a <code>semaphore</code> in this context.</p><p>A semaphore is used to control access to a resource and is known as a mutex (mutually exclusive) because only one entity can have the semaphore at a time.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb_top;<br>   semaphore key;         <span class="hljs-comment">// Create a semaphore handle called &quot;key&quot;</span><br> <br>   <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span> <br>      key = <span class="hljs-keyword">new</span> (<span class="hljs-number">1</span>);       <span class="hljs-comment">// Create only a single key; multiple keys are also possible</span><br>      <span class="hljs-keyword">fork</span><br>         personA ();       <span class="hljs-comment">// personA tries to get the room and puts it back after work</span><br>         personB ();       <span class="hljs-comment">// personB also tries to get the room and puts it back after work</span><br>         #<span class="hljs-number">25</span> personA ();     <span class="hljs-comment">// personA tries to get the room a second time</span><br>      <span class="hljs-keyword">join_none</span><br>   <span class="hljs-keyword">end</span><br> <br>   <span class="hljs-keyword">task</span> getRoom (<span class="hljs-keyword">bit</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] id);<br>      <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t] Trying to get a room for id[%0d] ...&quot;</span>, <span class="hljs-built_in">$time</span>, id);<br>      key<span class="hljs-variable">.get</span> (<span class="hljs-number">1</span>);<br>      <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t] Room Key retrieved for id[%0d]&quot;</span>, <span class="hljs-built_in">$time</span>, id);<br>   <span class="hljs-keyword">endtask</span><br> <br>   <span class="hljs-keyword">task</span> putRoom (<span class="hljs-keyword">bit</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] id);<br>      <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t] Leaving room id[%0d] ...&quot;</span>, <span class="hljs-built_in">$time</span>, id);<br>      key<span class="hljs-variable">.put</span> (<span class="hljs-number">1</span>);<br>      <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t] Room Key put back id[%0d]&quot;</span>, <span class="hljs-built_in">$time</span>, id);<br>   <span class="hljs-keyword">endtask</span><br> <br>   <span class="hljs-comment">// This person tries to get the room immediately and puts </span><br>   <span class="hljs-comment">// it back 20 time units later</span><br>   <span class="hljs-keyword">task</span> personA ();       <br>      getRoom (<span class="hljs-number">1</span>);<br>      #<span class="hljs-number">20</span> putRoom (<span class="hljs-number">1</span>);<br>   <span class="hljs-keyword">endtask</span><br> <br>  <span class="hljs-comment">// This person tries to get the room after 5 time units and puts it back after</span><br>  <span class="hljs-comment">// 10 time units</span><br>   <span class="hljs-keyword">task</span> personB ();<br>      #<span class="hljs-number">5</span>  getRoom (<span class="hljs-number">2</span>);<br>      #<span class="hljs-number">10</span> putRoom (<span class="hljs-number">2</span>);<br>   <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><p><strong>Simulation Log</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[0]</span> Trying to get a <span class="hljs-keyword">room</span> for id<span class="hljs-comment">[1]</span> ...<br><span class="hljs-comment">[0]</span> <span class="hljs-keyword">Room</span> Key retrieved for id<span class="hljs-comment">[1]</span><br><span class="hljs-comment">[5]</span> Trying to get a <span class="hljs-keyword">room</span> for id<span class="hljs-comment">[2]</span> ...<br><span class="hljs-comment">[20]</span> Leaving <span class="hljs-keyword">room</span> id<span class="hljs-comment">[1]</span> ...<br><span class="hljs-comment">[20]</span> <span class="hljs-keyword">Room</span> Key put back id<span class="hljs-comment">[1]</span><br><span class="hljs-comment">[20]</span> <span class="hljs-keyword">Room</span> Key retrieved for id<span class="hljs-comment">[2]</span><br><span class="hljs-comment">[25]</span> Trying to get a <span class="hljs-keyword">room</span> for id<span class="hljs-comment">[1]</span> ...<br><span class="hljs-comment">[30]</span> Leaving <span class="hljs-keyword">room</span> id<span class="hljs-comment">[2]</span> ...<br><span class="hljs-comment">[30]</span> <span class="hljs-keyword">Room</span> Key put back id<span class="hljs-comment">[2]</span><br><span class="hljs-comment">[30]</span> <span class="hljs-keyword">Room</span> Key retrieved for id<span class="hljs-comment">[1]</span><br><span class="hljs-comment">[50]</span> Leaving <span class="hljs-keyword">room</span> id<span class="hljs-comment">[1]</span> ...<br><span class="hljs-comment">[50]</span> <span class="hljs-keyword">Room</span> Key put back id<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p>Note the following about semaphores.</p><ul><li>A semaphore object <strong>key</strong> is <strong>declared and created using <code>new ()</code> function.</strong> Argument to <code>new ()</code> defines the number of keys.</li><li>You get the key by using the <code>get ()</code> keyword which will wait until a key is available (blocking)</li><li>You put the key back using the <code>put ()</code> keyword</li></ul><p><a href="https://www.chipverify.com/systemverilog/systemverilog-semaphore">Click here to read more about a SystemVerilog semaphore !</a></p><h2 id="What’s-a-mailbox"><a href="#What’s-a-mailbox" class="headerlink" title="What’s a mailbox ?"></a>What’s a mailbox ?</h2><p>A mailbox is like a dedicated channel established to <strong>send data between two components.</strong></p><p>For example, a <code>mailbox</code> can be created and the handles be passed to a data <em>generator</em> and a <em>driver</em>. The generator can push the data object into the mailbox and the driver will be able to retrieve the packet and drive the signals onto the bus.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// Data packet in this environment</span><br><span class="hljs-keyword">class</span> transaction;<br>   <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] data;<br> <br>   <span class="hljs-keyword">function</span> display ();<br>      <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t] Data = 0x%0h&quot;</span>, <span class="hljs-built_in">$time</span>, data);<br>   <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br> <br><span class="hljs-comment">// Generator class - Generate a transaction object and put into mailbox</span><br><span class="hljs-keyword">class</span> generator;<br>   mailbox mbx;<br> <br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span> (mailbox mbx);<br>      <span class="hljs-keyword">this</span><span class="hljs-variable">.mbx</span> = mbx;<br>   <span class="hljs-keyword">endfunction</span><br> <br>   <span class="hljs-keyword">task</span> genData ();<br>      transaction trns = <span class="hljs-keyword">new</span> ();<br>      trns<span class="hljs-variable">.randomize</span> ();<br>      trns<span class="hljs-variable">.display</span> ();<br>      <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t] [Generator] Going to put data packet into mailbox&quot;</span>, <span class="hljs-built_in">$time</span>);<br>      mbx<span class="hljs-variable">.put</span> (trns);<br>      <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t] [Generator] Data put into mailbox&quot;</span>, <span class="hljs-built_in">$time</span>);<br>   <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br> <br><span class="hljs-comment">// Driver class - Get the transaction object from Generator</span><br><span class="hljs-keyword">class</span> driver;<br>   mailbox mbx;<br> <br>   <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span> (mailbox mbx);<br>      <span class="hljs-keyword">this</span><span class="hljs-variable">.mbx</span> = mbx;<br>   <span class="hljs-keyword">endfunction</span><br> <br>   <span class="hljs-keyword">task</span> drvData ();<br>      transaction drvTrns = <span class="hljs-keyword">new</span> ();<br>      <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t] [Driver] Waiting for available data&quot;</span>, <span class="hljs-built_in">$time</span>);<br>      mbx<span class="hljs-variable">.get</span> (drvTrns);<br>      <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;[%0t] [Driver] Data received from Mailbox&quot;</span>, <span class="hljs-built_in">$time</span>);<br>      drvTrns<span class="hljs-variable">.display</span> ();<br>   <span class="hljs-keyword">endtask</span><br><span class="hljs-keyword">endclass</span><br> <br><span class="hljs-comment">// Top Level environment that will connect Gen and Drv with a mailbox</span><br><span class="hljs-keyword">module</span> tb_top;<br>   mailbox   mbx;<br>   generator Gen;<br>   driver    Drv;<br> <br>   <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>      mbx = <span class="hljs-keyword">new</span> ();<br>      Gen = <span class="hljs-keyword">new</span> (mbx);<br>      Drv = <span class="hljs-keyword">new</span> (mbx);<br> <br>      <span class="hljs-keyword">fork</span> <br>         #<span class="hljs-number">10</span> Gen<span class="hljs-variable">.genData</span> ();<br>         Drv<span class="hljs-variable">.drvData</span> ();<br>      <span class="hljs-keyword">join_none</span><br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><p><strong>Simulation Log</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[0]</span> <span class="hljs-comment">[Driver]</span> Waiting for available data<br><span class="hljs-comment">[10]</span> Data = 0x9d<br><span class="hljs-comment">[10]</span> <span class="hljs-comment">[Generator]</span> Put data packet into mailbox<br><span class="hljs-comment">[10]</span> <span class="hljs-comment">[Generator]</span> Data put into mailbox<br><span class="hljs-comment">[10]</span> <span class="hljs-comment">[Driver]</span> Data received from Mailbox<br><span class="hljs-comment">[10]</span> Data = 0x9d<br>ncsim: *W,RNQUIE: Simulation <span class="hljs-keyword">is</span> complete.<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SV</tag>
      
      <tag>ChipVerif_Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch7-local</title>
    <link href="/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch07_class/ch07_local/"/>
    <url>/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch07_class/ch07_local/</url>
    
    <content type="html"><![CDATA[<p>2019-11-12</p><h1 id="SystemVerilog-local"><a href="#SystemVerilog-local" class="headerlink" title="SystemVerilog local"></a>SystemVerilog local</h1><p>​    <strong>A member declared as <code>local</code> is available only to the methods of the same class, and are not accessible by child classes. However, nonlocal methods that access <code>local</code> members can be inherited and overridden by child class.</strong></p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>​    In the following example, we will declare two variables - one <code>public</code> and another <code>local</code>. <strong>We expect to see an error when a local member of the class is accessed from somewhere outside the class.</strong> This is because the keyword <code>local</code> is used to keep members <em>local</em> and visible only within the same class.</p><h3 id="When-accessed-from-outside-the-class"><a href="#When-accessed-from-outside-the-class" class="headerlink" title="When accessed from outside the class"></a>When accessed from outside the class</h3><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> ABC;<br>  <span class="hljs-comment">// By default, all variables are public and for this example,</span><br>  <span class="hljs-comment">// let&#x27;s create two variables - one public and the other &quot;local&quot;</span><br>  <span class="hljs-keyword">byte</span>      public_var;   <br>  <span class="hljs-keyword">local</span> <span class="hljs-keyword">byte</span> local_var;   <br> <br>  <span class="hljs-comment">// This function simply prints these variable contents</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> display();<br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;public_var=0x%0h, local_var=0x%0h&quot;</span>, public_var, local_var); <br>  <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br> <br><span class="hljs-keyword">module</span> tb;<br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br> <br>    <span class="hljs-comment">// Create a new class object, and call display method</span><br>    ABC abc = <span class="hljs-keyword">new</span>();<br>    abc<span class="hljs-variable">.display</span>();<br> <br>    <span class="hljs-comment">// Public variables can be accessed via the class handle</span><br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;public_var = 0x%0h&quot;</span>, abc<span class="hljs-variable">.public_var</span>);<br> <br>    <span class="hljs-comment">// However, local variables cannot be accessed from outside</span><br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;local_var = 0x%0h&quot;</span>, abc<span class="hljs-variable">.local_var</span>);<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><p>​    As expected, the compiler gives out a compilation error pointing to the line where a local member is accessed from outside the class.</p><p><strong>Simulation Log</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">    $display (<span class="hljs-string">&quot;local_var = 0x%0h&quot;</span>, abc.local_var);<br>                                               |<br>ncvlog: *E,CLSNLO (testbench.sv,<span class="hljs-number">24</span>|<span class="hljs-number">47</span>): Access <span class="hljs-keyword">to</span> <span class="hljs-keyword">local</span> member &#x27;local_var&#x27; <span class="hljs-keyword">in</span> <span class="hljs-built_in">class</span> &#x27;ABC&#x27; <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> allowed here.<br>irun: *E,VLGERR: An <span class="hljs-keyword">error</span> occurred during parsing.  Review <span class="hljs-keyword">the</span> <span class="hljs-built_in">log</span> <span class="hljs-built_in">file</span> <span class="hljs-keyword">for</span> errors <span class="hljs-keyword">with</span> <span class="hljs-keyword">the</span> code *E <span class="hljs-keyword">and</span> fix those identified problems <span class="hljs-keyword">to</span> proceed.  Exiting <span class="hljs-keyword">with</span> code (status <span class="hljs-number">1</span>).<br></code></pre></td></tr></table></figure><p><a href="https://www.edaplayground.com/x/6Esf">Click to try this example in a simulator!   <img src="https://www.chipverify.com/images/site/eda-playground-logo.png" alt="img"></a></p><p>​    In the above example, we can remove the line that causes a compilation error and see that we get a good output. The only other function that accesses the <code>local</code> member is the display() function.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb;<br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br> <br>    ABC abc = <span class="hljs-keyword">new</span>();<br> <br>    <span class="hljs-comment">// This should be able to print local members of class ABC</span><br>    <span class="hljs-comment">// because display() is a member of ABC also</span><br>    abc<span class="hljs-variable">.display</span>();<br> <br>    <span class="hljs-comment">// Public variables can always be accessed via the class handle</span><br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;public_var = 0x%0h&quot;</span>, abc<span class="hljs-variable">.public_var</span>);<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><p><strong>Simulation Log</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">ncsim&gt; <span class="hljs-built_in">run</span><br><span class="hljs-attribute">public_var</span>=0x0, <span class="hljs-attribute">local_var</span>=0x0<br>public_var = 0x0<br>ncsim: *W,RNQUIE: Simulation is complete.<br></code></pre></td></tr></table></figure><p><a href="https://www.edaplayground.com/x/5yX7">Click to try this example in a simulator!   <img src="https://www.chipverify.com/images/site/eda-playground-logo.png" alt="img"></a></p><h3 id="When-accessed-by-child-classes"><a href="#When-accessed-by-child-classes" class="headerlink" title="When accessed by child classes"></a>When accessed by child classes</h3><p>​    In this example, let us try to access the <code>local</code> member from within a child class. We expect to see an error here also because <code>local</code> is not visible to child classes either.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// Define a base class and let the variable be &quot;local&quot; to this class</span><br><span class="hljs-keyword">class</span> ABC;<br>  <span class="hljs-keyword">local</span> <span class="hljs-keyword">byte</span> local_var;   <br><span class="hljs-keyword">endclass</span><br> <br><span class="hljs-comment">// Define another class that extends ABC and have a function that tries</span><br><span class="hljs-comment">// to access the local variable in ABC</span><br><span class="hljs-keyword">class</span> DEF <span class="hljs-keyword">extends</span> ABC;  <br>  <span class="hljs-keyword">function</span> show();<br>    <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;local_var = 0x%0h&quot;</span>, local_var);<br>  <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endclass</span><br> <br><span class="hljs-keyword">module</span> tb;<br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br> <br>    <span class="hljs-comment">// Create a new object of the child class, and call the show method</span><br>    <span class="hljs-comment">// This will give a compile time error because child classes cannot access</span><br>    <span class="hljs-comment">// base class &quot;local&quot; variables and methods</span><br>    DEF def = <span class="hljs-keyword">new</span>();<br>    def<span class="hljs-variable">.show</span>();<br> <br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><p><strong>As expected, child classes cannot access the <code>local</code> members of their parent class.</strong></p><p><strong>Simulation Log</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">    $display (<span class="hljs-string">&quot;local_var = 0x%0h&quot;</span>, local_var);<br>                                           |<br>ncvlog: *E,CLSNLO (testbench.sv,<span class="hljs-number">10</span>|<span class="hljs-number">43</span>): Access <span class="hljs-keyword">to</span> <span class="hljs-keyword">local</span> member &#x27;local_var&#x27; <span class="hljs-keyword">in</span> <span class="hljs-built_in">class</span> &#x27;ABC&#x27; <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> allowed here.<br>irun: *E,VLGERR: An <span class="hljs-keyword">error</span> occurred during parsing.  Review <span class="hljs-keyword">the</span> <span class="hljs-built_in">log</span> <span class="hljs-built_in">file</span> <span class="hljs-keyword">for</span> errors <span class="hljs-keyword">with</span> <span class="hljs-keyword">the</span> code *E <span class="hljs-keyword">and</span> fix those identified problems <span class="hljs-keyword">to</span> proceed.  Exiting <span class="hljs-keyword">with</span> code (status <span class="hljs-number">1</span>).<br></code></pre></td></tr></table></figure><p><a href="https://www.edaplayground.com/x/2WVQ">Click to try this example in a simulator!   <img src="https://www.chipverify.com/images/site/eda-playground-logo.png" alt="img"></a></p><p><a href="https://www.chipverify.com/systemverilog/systemverilog-extern">  Prev Article</a></p>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SV</tag>
      
      <tag>ChipVerif_Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch6-Interrface</title>
    <link href="/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch06_Interface/ch06_Interface/"/>
    <url>/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch06_Interface/ch06_Interface/</url>
    
    <content type="html"><![CDATA[<p>2019-10-31</p><h1 id="SystemVerilog-Interface"><a href="#SystemVerilog-Interface" class="headerlink" title="SystemVerilog Interface"></a>SystemVerilog Interface</h1><h2 id="What-is-an-Interface"><a href="#What-is-an-Interface" class="headerlink" title="What is an Interface ?"></a>What is an Interface ?</h2><p>An Interface is a way to encapsulate signals into a block. All related signals are grouped together to form an interface block so that the same <code>interface</code> can be re-used for other projects. Also it becomes easier to connect with the DUT and other verification components.</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>APB bus protocol signals are put together in the given interface. Note that signals are declared within <code>interface</code> and <code>endinterface</code>.</p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">interface</span> apb_if (<span class="hljs-keyword">input</span> pclk);<br>  <span class="hljs-keyword">logic</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>]    paddr;<br>  <span class="hljs-keyword">logic</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>]    pwdata;<br>  <span class="hljs-keyword">logic</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>]    prdata;<br>  <span class="hljs-keyword">logic</span>           penable;<br>  <span class="hljs-keyword">logic</span>           pwrite;<br>  <span class="hljs-keyword">logic</span>           psel;<br><span class="hljs-keyword">endinterface</span><br> <br></code></pre></td></tr></table></figure><h2 id="Why-are-signals-declared-logic"><a href="#Why-are-signals-declared-logic" class="headerlink" title="Why are signals declared logic ?"></a>Why are signals declared <code>logic</code> ?</h2><p><code>    logic</code> is a new data type that lets you drive signals of this type via assign statements and in a procedural block. Remember that in verilog, you could drive a <code>reg</code> only in procedural block and a <code>wire</code> only in <em>assign</em> statement. But this is only one reason.</p><p><strong>Signals connected to the DUT should support 4-states so that X&#x2F;Z values can be caught. If these signals were <code>bit</code> then the X&#x2F;Z would have shown up as 0, and you would have missed that DUT had a X&#x2F;Z value.</strong></p><h2 id="How-to-define-port-directions"><a href="#How-to-define-port-directions" class="headerlink" title="How to define port directions ?"></a>How to define port directions ?</h2><p>​    Interface signals can be used within various verification components as well as the DUT, and hence <code>modport</code> is used to define signal directions. Different modport definitions can be passed to different components that allows us to define different input-output directions for each component.</p><p><strong>modport中不需要指定port width</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// Filename : myBus.sv</span><br><span class="hljs-keyword">interface</span> myBus (<span class="hljs-keyword">input</span> clk);<br>  <span class="hljs-keyword">logic</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]  data;<br>  <span class="hljs-keyword">logic</span>      enable;<br> <br>  <span class="hljs-comment">// From TestBench perspective, &#x27;data&#x27; is input and &#x27;write&#x27; is output</span><br>  <span class="hljs-keyword">modport</span> TB  (<span class="hljs-keyword">input</span> data, <span class="hljs-keyword">output</span> enable);  <br> <br>  <span class="hljs-comment">// From DUT perspective, &#x27;data&#x27; is output and &#x27;enable&#x27; is input</span><br>  <span class="hljs-keyword">modport</span> DUT (<span class="hljs-keyword">output</span> data, <span class="hljs-keyword">input</span> enable); <br><span class="hljs-keyword">endinterface</span><br> <br></code></pre></td></tr></table></figure><p><a href="https://www.chipverify.com/systemverilog/systemverilog-modport">Click here to read more on SystemVerilog modports !</a></p><h2 id="How-to-connect-an-interface-with-DUT"><a href="#How-to-connect-an-interface-with-DUT" class="headerlink" title="How to connect an interface with DUT ?"></a>How to connect an interface with DUT ?</h2><p>​    An interface object should be created in the top testbench module where DUT is instantiated, and passed to DUT. It is essential to ensure that the correct modport is assigned to DUT.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// Filename : dut.sv</span><br><span class="hljs-keyword">module</span> dut (myBus<span class="hljs-variable">.DUT</span> busIf);<br>  <span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">posedge</span> clk) <br>    <span class="hljs-keyword">if</span> (busIf<span class="hljs-variable">.enable</span>)<br>      busIf<span class="hljs-variable">.data</span> &lt;= busIf<span class="hljs-variable">.data</span>+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <br>      busIf<span class="hljs-variable">.data</span> &lt;= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">endmodule</span> <br> <br> <br><span class="hljs-comment">// Filename : tb_top.sv</span><br><span class="hljs-keyword">module</span> tb_top;<br>  <span class="hljs-keyword">bit</span> clk;<br>  <span class="hljs-keyword">bit</span> enable;<br> <br>  <span class="hljs-comment">// Create a clock</span><br>  <span class="hljs-keyword">always</span> #<span class="hljs-number">10</span> clk = ~clk;<br> <br>  <span class="hljs-comment">// Create an interface object</span><br>  myBus busIf (clk);<br> <br>  <span class="hljs-comment">// Instantiate the DUT; pass modport DUT of busIf</span><br>  dut dut0 (busIf<span class="hljs-variable">.DUT</span>);<br> <br>  <span class="hljs-comment">// Testbench code : let&#x27;s wiggle enable</span><br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    enable  &lt;= <span class="hljs-number">0</span>;<br>    #<span class="hljs-number">10</span> enable &lt;= <span class="hljs-number">1</span>;<br>    #<span class="hljs-number">40</span> enable &lt;= <span class="hljs-number">0</span>;<br>    #<span class="hljs-number">20</span> enable &lt;= <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><h2 id="What-are-the-advantages"><a href="#What-are-the-advantages" class="headerlink" title="What are the advantages ?"></a>What are the advantages ?</h2><p>​    Interfaces can contain tasks, functions, parameters, variables, functional coverage, and assertions. This enables us to monitor and record the transactions via the interface within this block. It also becomes easier to connect to design regardless of the number of ports it has since that information is encapsulated in an interface.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">//Before interface</span><br>dut dut0  (<span class="hljs-variable">.data</span> (data),<br>           <span class="hljs-variable">.enable</span> (enable),<br>           <span class="hljs-comment">//  all other signals</span><br>           );<br> <br><span class="hljs-comment">// With interface - higher level of abstraction possible</span><br>dut dut0  (busIf<span class="hljs-variable">.DUT</span>);<br> <br></code></pre></td></tr></table></figure><h2 id="How-to-parameterize-an-interface"><a href="#How-to-parameterize-an-interface" class="headerlink" title="How to parameterize an interface ?"></a>How to parameterize an interface ?</h2><p>The same way you would do for a <em>module</em>.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">interface</span> myBus #(<span class="hljs-keyword">parameter</span> D_WIDTH=<span class="hljs-number">31</span>) (<span class="hljs-keyword">input</span> clk);<br>  <span class="hljs-keyword">logic</span> [D_WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] data;<br>  <span class="hljs-keyword">logic</span>               enable;<br><span class="hljs-keyword">endinterface</span><br> <br></code></pre></td></tr></table></figure><h2 id="What-are-clocking-blocks"><a href="#What-are-clocking-blocks" class="headerlink" title="What are clocking blocks ?"></a>What are clocking blocks ?</h2><p>Signals that are specified inside a clocking block will be sampled&#x2F;driven with respect to that clock. There can be mulitple clocking blocks in an interface. Note that this is for testbench related signals. You want to control when the TB drives and samples signals from DUT. Solves some part of the race condition, but not entirely. You can also parameterize the skew values.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">interface</span> my_int (<span class="hljs-keyword">input</span> <span class="hljs-keyword">bit</span> clk);<br>  <span class="hljs-comment">// Rest of interface code</span><br> <br>  <span class="hljs-keyword">clocking</span> cb_clk @(<span class="hljs-keyword">posedge</span> clk);<br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">input</span> #<span class="hljs-number">3</span>ns <span class="hljs-keyword">output</span> #<span class="hljs-number">2</span>ns;<br>    <span class="hljs-keyword">input</span> enable;<br>    <span class="hljs-keyword">output</span> data;<br>  <span class="hljs-keyword">endclocking</span><br><span class="hljs-keyword">endinterface</span><br> <br></code></pre></td></tr></table></figure><p><strong>In the above example, we have specified that by default, input should be sampled 3ns before posedge of clk, and output should be driven 2ns after posedge of clk.</strong></p><p> <strong>驱动延时（output，如2ps）或者采样延时(input，如10ps)的意思；驱动延时是正值，表示在时钟沿后2ps驱动信号，采样延时是负值，表示在时钟沿前10ps采样</strong> </p><h2 id="How-to-use-a-clocking-block"><a href="#How-to-use-a-clocking-block" class="headerlink" title="How to use a clocking block ?"></a>How to use a clocking block ?</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// To wait for posedge of clock</span><br>@busIf<span class="hljs-variable">.cb_clk</span>;<br> <br><span class="hljs-comment">// To use clocking block signals</span><br>busIf<span class="hljs-variable">.cb_clk</span><span class="hljs-variable">.enable</span> = <span class="hljs-number">1</span>;<br> <br></code></pre></td></tr></table></figure><p>As you can see, you don’t have to wait for the posedge of clk, before you assign 1 to enable. This way, you are assured that enable will be driven 2ns after the next posedge clk.</p>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SV</tag>
      
      <tag>ChipVerif_Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch6-Modport</title>
    <link href="/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch06_Interface/ch06_Modport/"/>
    <url>/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch06_Interface/ch06_Modport/</url>
    
    <content type="html"><![CDATA[<p>2019-11-02</p><h1 id="SystemVerilog-Modport"><a href="#SystemVerilog-Modport" class="headerlink" title="SystemVerilog Modport"></a>SystemVerilog Modport</h1><p>​    Modport lists with directions are defined in an interface to impose certain restrictions on interface access within a module. The keyword <code>modport</code> indicates that the <strong>directions</strong> are declared as if inside the module.</p><h2 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h2><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">modport</span>  [identifier]  (<br>  <span class="hljs-keyword">input</span>  [port_list],<br>  <span class="hljs-keyword">output</span> [port_list]<br>);<br> <br></code></pre></td></tr></table></figure><p>Shown below is the definition of an interface myInterface which has a few signals and two <code>modport</code> declarations. The modport dut0 essentially states that the signals ack and sel are inputs and gnt and irq0 are outputs to whatever module uses this particular modport.</p><p>Similarly, another modport called dut1 is declared which states that gnt and irq0 are inputs and the other two are outputs for any module that uses modport dut1.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">interface</span>   myInterface;<br>  <span class="hljs-keyword">logic</span>   ack;<br>  <span class="hljs-keyword">logic</span>   gnt;<br>  <span class="hljs-keyword">logic</span>   sel;<br>  <span class="hljs-keyword">logic</span>   irq0;<br> <br>  <span class="hljs-comment">// ack and sel are inputs to the dut0, while gnt and irq0 are outputs</span><br>  <span class="hljs-keyword">modport</span>  dut0 (<br>    <span class="hljs-keyword">input</span>   ack, sel,<br>    <span class="hljs-keyword">output</span>   gnt, irq0<br>  );<br> <br>  <span class="hljs-comment">// ack and sel are outputs from dut1, while gnt and irq0 are inputs</span><br>  <span class="hljs-keyword">modport</span>  dut1 (<br>    <span class="hljs-keyword">input</span>   gnt, irq0,<br>    <span class="hljs-keyword">output</span>   ack, sel<br>  );<br><span class="hljs-keyword">endinterface</span><br> <br></code></pre></td></tr></table></figure><h2 id="Example-of-named-port-bundle"><a href="#Example-of-named-port-bundle" class="headerlink" title="Example of named port bundle"></a>Example of named port bundle</h2><p>In this style, the design will take the required correct modport definition from the interface object as mentioned in its port list. The testbench only needs to provide the whole interface object to the design.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> dut0  ( myinterface<span class="hljs-variable">.dut0</span>  _if);<br>  ...<br><span class="hljs-keyword">endmodule</span><br> <br><span class="hljs-keyword">module</span> dut1  ( myInterface<span class="hljs-variable">.dut1</span> _if);<br>  ...<br><span class="hljs-keyword">endmodule</span><br> <br><span class="hljs-keyword">module</span> tb;<br>  myInterface   _if;<br>  dut0    d0   ( .* );<br>  dut1   d1   ( .* );<br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><h2 id="Example-of-connecting-port-bundle"><a href="#Example-of-connecting-port-bundle" class="headerlink" title="Example of connecting port bundle"></a>Example of connecting port bundle</h2><p>In this style, the design simply accepts whatever directional information is given to it. Hence testbench is responsible to provide the correct modport values to the design.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> dut0  ( myinterface  _if);<br>  ...<br><span class="hljs-keyword">endmodule</span><br> <br><span class="hljs-keyword">module</span> dut1  ( myInterface _if);<br>  ...<br><span class="hljs-keyword">endmodule</span><br> <br><span class="hljs-keyword">module</span> tb;<br>  myInterface   _if;<br>  dut0    d0   ( <span class="hljs-variable">._if</span> (_if<span class="hljs-variable">.dut0</span>));<br>  dut1   d1   ( <span class="hljs-variable">._if</span> (_if<span class="hljs-variable">.dut1</span>));<br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><h2 id="What-is-the-need-for-a-modport"><a href="#What-is-the-need-for-a-modport" class="headerlink" title="What is the need for a modport ?"></a>What is the need for a modport ?</h2><p>​    <strong>Nets declared within a simple interface is <code>inout</code> by default</strong> and hence any module connected to the same net, can either drive values or take values from it. In simple words, there are no restrictions on direction of value propagation. <strong>You could end up with an X on the net because both the testbench and the design are driving two different values to the same interface net.</strong> Special care should be taken by the testbench writer to ensure that such a situation does not happen. This can be inherently avoided by the use of <em>modports</em>.</p><h2 id="Example-of-connecting-to-generic-interface"><a href="#Example-of-connecting-to-generic-interface" class="headerlink" title="Example of connecting to generic interface"></a>Example of connecting to generic interface</h2><p>A <code>module</code> can also have a <em>generic</em> interface as the portlist. The generic handle can accept any modport passed to it from the hierarchy above.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> dut0  ( <span class="hljs-keyword">interface</span>  _if);<br>  ...<br><span class="hljs-keyword">endmodule</span><br> <br><span class="hljs-keyword">module</span> dut1  ( <span class="hljs-keyword">interface</span> _if);<br>  ...<br><span class="hljs-keyword">endmodule</span><br> <br><span class="hljs-keyword">module</span> tb;<br>  myInterface   _if;<br>  dut0    d0   ( <span class="hljs-variable">._if</span> (_if<span class="hljs-variable">.dut0</span>));<br>  dut1   d1   ( <span class="hljs-variable">._if</span> (_if<span class="hljs-variable">.dut1</span>));<br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><h2 id="Design-Example"><a href="#Design-Example" class="headerlink" title="Design Example"></a>Design Example</h2><p>​    Lets consider two modules master and slave connected by a very simple bus structure. Assume that the <em>bus</em> is capable of sending an address and data which the slave is expected to capture and update the information in its internal registers. So the master always has to initiate the transfer and the slave is capable of indicating to the master whether it is ready to accept the data by its sready signal.</p><h3 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h3><p>Shown below is an <code>interface</code> definition that is shared between the <em>master</em> and <em>slave</em>modules.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">interface</span> ms_if (<span class="hljs-keyword">input</span> clk);][][]<br>  <span class="hljs-keyword">logic</span> sready;      <span class="hljs-comment">// Indicates if slave is ready to accept data</span><br>  <span class="hljs-keyword">logic</span> rstn;        <span class="hljs-comment">// Active low reset</span><br>  <span class="hljs-keyword">logic</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] addr;  <span class="hljs-comment">// Address </span><br>  <span class="hljs-keyword">logic</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] data;  <span class="hljs-comment">// Data</span><br> <br>  <span class="hljs-keyword">modport</span> slave ( <span class="hljs-keyword">input</span> addr, data, rstn, clk,<br>                 <span class="hljs-keyword">output</span> sready);<br> <br>  <span class="hljs-keyword">modport</span> master ( <span class="hljs-keyword">output</span> addr, data,<br>                  <span class="hljs-keyword">input</span>  clk, sready, rstn);<br><span class="hljs-keyword">endinterface</span><br> <br></code></pre></td></tr></table></figure><h3 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h3><p>​    Assume that the <em>master</em> simply iterates the address from 0 to 3 and sends data equal to the address multiplied by 4. The master should only send when the slave is ready to accept and is indicated by the sready signal.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// This module accepts an interface with modport &quot;master&quot;</span><br><span class="hljs-comment">// Master sends transactions in a pipelined format</span><br><span class="hljs-comment">// CLK    1   2   3   4   5   6</span><br><span class="hljs-comment">// ADDR   A0  A1  A2  A3  A0  A1</span><br><span class="hljs-comment">// DATA       D0  D1  D2  D3  D4</span><br><span class="hljs-keyword">module</span> master ( ms_if<span class="hljs-variable">.master</span> mif);<br>  <span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">posedge</span> mif<span class="hljs-variable">.clk</span>) <span class="hljs-keyword">begin</span><br> <br>    <span class="hljs-comment">// If reset is applied, set addr and data to default values</span><br>    <span class="hljs-keyword">if</span> (! mif<span class="hljs-variable">.rstn</span>) <span class="hljs-keyword">begin</span><br>      mif<span class="hljs-variable">.addr</span> &lt;= <span class="hljs-number">0</span>;<br>      mif<span class="hljs-variable">.data</span> &lt;= <span class="hljs-number">0</span>;<br> <br>    <span class="hljs-comment">// Else increment addr, and assign data accordingly if slave is ready</span><br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-comment">// Send new addr and data only if slave is ready</span><br>      <span class="hljs-keyword">if</span> (mif<span class="hljs-variable">.sready</span>) <span class="hljs-keyword">begin</span><br>        mif<span class="hljs-variable">.addr</span> &lt;= mif<span class="hljs-variable">.addr</span> + <span class="hljs-number">1</span>;<br>        mif<span class="hljs-variable">.data</span> &lt;= (mif<span class="hljs-variable">.addr</span> * <span class="hljs-number">4</span>);<br> <br>     <span class="hljs-comment">// Else maintain current addr and data</span><br>      <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>        mif<span class="hljs-variable">.addr</span> &lt;= mif<span class="hljs-variable">.addr</span>;<br>        mif<span class="hljs-variable">.data</span> &lt;= mif<span class="hljs-variable">.data</span>;<br>      <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><p>Assume that the slave accepts data for every addr and assigns them to internal registers. When the address wraps from 3 to 0, the slave requires 1 additional clock to become ready.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> slave (ms_if<span class="hljs-variable">.slave</span> sif);<br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] reg_a;<br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]  reg_b;<br>  <span class="hljs-keyword">reg</span>     reg_c;<br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] reg_d;<br> <br>  <span class="hljs-keyword">reg</span>    dly;<br>  <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] addr_dly;<br> <br> <br>  <span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">posedge</span> sif<span class="hljs-variable">.clk</span>) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span> (! sif<span class="hljs-variable">.rstn</span>) <span class="hljs-keyword">begin</span><br>      addr_dly &lt;= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      addr_dly &lt;= sif<span class="hljs-variable">.addr</span>;<br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">end</span><br> <br>  <span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">posedge</span> sif<span class="hljs-variable">.clk</span>) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span> (! sif<span class="hljs-variable">.rstn</span>) <span class="hljs-keyword">begin</span><br>        reg_a &lt;= <span class="hljs-number">0</span>;<br>      reg_b &lt;= <span class="hljs-number">0</span>;<br>      reg_c &lt;= <span class="hljs-number">0</span>;<br>      reg_d &lt;= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      <span class="hljs-keyword">case</span> (addr_dly)<br>        <span class="hljs-number">0</span> : reg_a &lt;= sif<span class="hljs-variable">.data</span>;<br>        <span class="hljs-number">1</span> : reg_b &lt;= sif<span class="hljs-variable">.data</span>;<br>        <span class="hljs-number">2</span> : reg_c &lt;= sif<span class="hljs-variable">.data</span>;<br>        <span class="hljs-number">3</span> : reg_d &lt;= sif<span class="hljs-variable">.data</span>;<br>      <span class="hljs-keyword">endcase</span><br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">end</span><br> <br>  <span class="hljs-keyword">assign</span> sif<span class="hljs-variable">.sready</span> = ~(sif<span class="hljs-variable">.addr</span>[<span class="hljs-number">1</span>] &amp; sif<span class="hljs-variable">.addr</span>[<span class="hljs-number">0</span>]) | ~dly;<br> <br>  <span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">posedge</span> sif<span class="hljs-variable">.clk</span>) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span> (! sif<span class="hljs-variable">.rstn</span>) <br>      dly &lt;= <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <br>      dly &lt;= sif<span class="hljs-variable">.sready</span>;<br>  <span class="hljs-keyword">end</span><br> <br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><p>The two design modules are tied together at a top level.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> d_top (ms_if tif);<br>  <span class="hljs-comment">// Pass the &quot;master&quot; modport to master</span><br>    master   m0 (tif<span class="hljs-variable">.master</span>);<br> <br>    <span class="hljs-comment">// Pass the &quot;slave&quot; modport to slave</span><br>    slave   s0 (tif<span class="hljs-variable">.slave</span>);<br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><h3 id="Testbench"><a href="#Testbench" class="headerlink" title="Testbench"></a>Testbench</h3><p>The testbench will pass the interface handle to the design, which will then assign master and slave modports to its sub-modules.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb;<br>  <span class="hljs-keyword">reg</span> clk;<br>  <span class="hljs-keyword">always</span> #<span class="hljs-number">10</span> clk = ~clk;<br> <br>  ms_if   if0 (clk);<br>  d_top   d0  (if0);  <br> <br>  <span class="hljs-comment">// Let the stimulus run for 20 clocks and stop</span><br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    clk &lt;= <span class="hljs-number">0</span>;<br>    if0<span class="hljs-variable">.rstn</span> &lt;= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">repeat</span> (<span class="hljs-number">5</span>) @ (<span class="hljs-keyword">posedge</span> clk);<br>    if0<span class="hljs-variable">.rstn</span> &lt;= <span class="hljs-number">1</span>;<br> <br>    <span class="hljs-keyword">repeat</span> (<span class="hljs-number">20</span>) @ (<span class="hljs-keyword">posedge</span> clk);<br>    <span class="hljs-built_in">$finish</span>;<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><p><strong>Simulation Output</strong></p><p>Remember that the master initiates bus transactions and the slave captures data and stores it in its internal registers reg_* for the corresponding address.</p><p><img src="https://www.chipverify.com/images/sv/modport-design-example-wave.PNG" alt="modport-design-example-wave"><a href="https://www.edaplayground.com/x/32EV">Click to try this example in a simulator!  <img src="https://www.chipverify.com/images/site/eda-playground-logo.png" alt="img"></a></p>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SV</tag>
      
      <tag>ChipVerif_Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch6-Clocking block</title>
    <link href="/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch06_Interface/ch06_Clocking%20Block/"/>
    <url>/2019/07/15/Verification/SystemVerilog/ChipVerif_web_SV/ch06_Interface/ch06_Clocking%20Block/</url>
    
    <content type="html"><![CDATA[<p>2019-11-02</p><h1 id="SystemVerilog-Clocking-Blocks"><a href="#SystemVerilog-Clocking-Blocks" class="headerlink" title="SystemVerilog Clocking Blocks"></a>SystemVerilog Clocking Blocks</h1><p>​    Module ports and interfaces by default do not specify any timing requirements or synchronization schemes between signals. A <em>clocking block</em> defined between <code>clocking</code> and <code>endcocking</code> does exactly that. <strong>It is a collection of signals synchronous with a particular clock and helps to specify the timing requirements between the clock and the signals.</strong></p><p>This would allow test writers to focus more on transactions rather than worry about when a signal will interact with respect to a clock. <strong>A testbench can have many clocking blocks, but only one block per clock.</strong></p><h2 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h2><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog">[<span class="hljs-keyword">default</span>] <span class="hljs-keyword">clocking</span> [identifier_name] @ [event_or_identifier]<br>  <span class="hljs-keyword">default</span> <span class="hljs-keyword">input</span> #[delay_or_edge] <span class="hljs-keyword">output</span> #[delay_or_edge]<br>  [list of signals]<br><span class="hljs-keyword">endclocking</span><br> <br></code></pre></td></tr></table></figure><p>The <em>delay_value</em> represents a skew of how many time units away from the clock event a signal is to be sampled or driven. <strong>If a <code>default</code> skew is not specified, then all input signals will be sampled <code>#1step</code> and output signlas driven <code>0ns</code> after the specified event.</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">clocking</span> ckb @ (<span class="hljs-keyword">posedge</span> clk);<br>  <span class="hljs-keyword">default</span> <span class="hljs-keyword">input</span> #<span class="hljs-number">1</span>step <span class="hljs-keyword">output</span> <span class="hljs-keyword">negedge</span>;<br>  <span class="hljs-keyword">input</span> ...;<br>  <span class="hljs-keyword">output</span> ...;<br><span class="hljs-keyword">endclocking</span><br> <br><span class="hljs-keyword">clocking</span> ck1 @ (<span class="hljs-keyword">posedge</span> clk);<br>  <span class="hljs-keyword">default</span> <span class="hljs-keyword">input</span> #<span class="hljs-number">5</span>ns <span class="hljs-keyword">output</span> #<span class="hljs-number">2</span>ns;<br>  <span class="hljs-keyword">input</span> data, valid, ready = top<span class="hljs-variable">.ele</span><span class="hljs-variable">.ready</span>;<br>  <span class="hljs-keyword">output</span> <span class="hljs-keyword">negedge</span> grant;<br>  <span class="hljs-keyword">input</span> #<span class="hljs-number">1</span>step addr;<br><span class="hljs-keyword">endclocking</span><br> <br></code></pre></td></tr></table></figure><p>Note the following:</p><ul><li>A clocking block called <strong>ck1</strong> is created which will be active on the positive edge of <strong>clk</strong></li><li>By default, all input signals within the clocking block will be sampled 5ns before and all output signals within the clocking block will be driven 2ns after the positive edge of the clock <strong>clk</strong></li><li><strong>data</strong>, <strong>valid</strong> and <strong>ready</strong> are declared as inputs to the block and hence will be sampled 5ns before the posedge of <strong>clk</strong></li><li><strong>grant</strong> is an output signal to the block with its own time requirement. Here <strong>grant</strong> will be driven at the negedge of <strong>clk</strong> instead of the default <strong>posedge</strong>.</li></ul><h2 id="Use-within-an-interface"><a href="#Use-within-an-interface" class="headerlink" title="Use within an interface"></a>Use within an interface</h2><p>Simply put, a clocking block encapsulates a bunch of signals that share a common clock. Hence declaring a clocking block inside an interface can help save the amount of code required to connect to the testbench and may help save time during development.</p><h2 id="重要"><a href="#重要" class="headerlink" title="重要"></a>重要</h2><p><strong>重要：Signal directions inside a clocking block are with respect to the testbench and not the DUT.</strong></p><h1 id="SystemVerilog-Clocking-Blocks-Part-II"><a href="#SystemVerilog-Clocking-Blocks-Part-II" class="headerlink" title="SystemVerilog Clocking Blocks Part II"></a>SystemVerilog Clocking Blocks Part II</h1><p>Clocking blocks allow inputs to be sampled and outputs to be driven at a specified clock event. If an input <em>skew</em> is mentioned for a clocking block, then all input signals within that block will be sampled at <strong><em>skew</em> time</strong> units <em>before</em> the clock event. If an output <em>skew</em> is mentioned for a clocking block, then all output signals in that block will be driven <em>skew</em>time units after the corresponding clock event.</p><h2 id="What-are-input-and-output-skews"><a href="#What-are-input-and-output-skews" class="headerlink" title="What are input and output skews ?"></a>What are input and output skews ?</h2><p>​    A skew is specified as a constant expression or as a parameter. If only a number is used, then the skew is interpreted to follow the active timescale in the given scope.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">clocking</span> cb @(clk);<br>    <span class="hljs-keyword">input</span>  #<span class="hljs-number">1</span>ps req; <span class="hljs-comment">// sample 1ps before clock edge</span><br>    <span class="hljs-keyword">output</span> #<span class="hljs-number">2</span>   gnt; <span class="hljs-comment">// drive 2ns after clock edge</span><br>    <span class="hljs-keyword">input</span>  #<span class="hljs-number">1</span> <span class="hljs-keyword">output</span> #<span class="hljs-number">3</span> sig; <span class="hljs-comment">// input skew and output skew</span><br><span class="hljs-keyword">endclocking</span><br> <br></code></pre></td></tr></table></figure><p>​    In the example given above, we have declared a clocking block of the name cb to describe when signals belonging to this block has to be sampled. Signal req is specified to have a skew of 1ps and <strong>will be sampled 1 ps before the clock edge clk.</strong> The output signal gnt has an output skew of 2 time units and hence will follow the timescale followed in the current scope. If we have a timescale of 1ns&#x2F;1ps then #2 represents 2 ns and <strong>hence will be <em>driven</em> 2 ns after the clock edge</strong>. The last signal sig is of <code>inout</code> type and will be sampled 1 ns before the clock edge and driven 3 ns after the clock edge.</p><p>​    <strong>An input skew of <code>1step</code> indicates that the signal should be sampled at the end of the previous time step, or in other words, immediately before the positive clock edge.</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">clocking</span> cb @(<span class="hljs-keyword">posedge</span> clk);<br>  <span class="hljs-keyword">input</span> #<span class="hljs-number">1</span>step req;<br><span class="hljs-keyword">endclocking</span><br> <br></code></pre></td></tr></table></figure><p>​    Inputs with explicit #0 skew will be sampled at the same time as their corresponding clocking event, but in the <em>Observed</em> region to avoid race conditions. Similarly, outputs with no skew or explicit #0 will be driven at the same time as the clocking event, in the Re-NBA region.</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>​    Consider a simple design with inputs clk and req and drives an output signal gnt. To keep things simple, lets just provide grant as soon as a request is received.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> des (<span class="hljs-keyword">input</span> req, clk, <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> gnt);<br>  <span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">posedge</span> clk)<br>    <span class="hljs-keyword">if</span> (req)<br>      gnt &lt;= <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>      gnt &lt;= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><p>To deal with the design port signals, let’s create a simple interface called <em>_if</em>.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">interface</span> _if (<span class="hljs-keyword">input</span> <span class="hljs-keyword">bit</span> clk);<br>  <span class="hljs-keyword">logic</span> gnt;<br>  <span class="hljs-keyword">logic</span> req;<br> <br>  <span class="hljs-keyword">clocking</span> cb @(<span class="hljs-keyword">posedge</span> clk);<br>    <span class="hljs-keyword">input</span> #<span class="hljs-number">1</span>ns gnt;<br>    <span class="hljs-keyword">output</span> #<span class="hljs-number">5</span>  req;<br>  <span class="hljs-keyword">endclocking</span><br><span class="hljs-keyword">endinterface</span><br> <br></code></pre></td></tr></table></figure><p>The next step is to drive inputs to the design so that it gives back the grant signal.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb;  <br>  <span class="hljs-keyword">bit</span> clk;<br> <br>  <span class="hljs-comment">// Create a clock and initialize input signal</span><br>  <span class="hljs-keyword">always</span> #<span class="hljs-number">10</span> clk = ~clk;<br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    clk &lt;= <span class="hljs-number">0</span>;<br>    if0<span class="hljs-variable">.cb</span><span class="hljs-variable">.req</span> &lt;= <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">end</span><br> <br>  <span class="hljs-comment">// Instantiate the interface</span><br>  _if if0 (<span class="hljs-variable">.clk</span> (clk));<br> <br>  <span class="hljs-comment">// Instantiate the design</span><br>  des d0 ( <span class="hljs-variable">.clk</span> (clk),<br>           <span class="hljs-variable">.req</span> (if0<span class="hljs-variable">.req</span>),<br>           <span class="hljs-variable">.gnt</span> (if0<span class="hljs-variable">.gnt</span>));<br> <br>  <span class="hljs-comment">// Drive stimulus</span><br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) <span class="hljs-keyword">begin</span><br>      <span class="hljs-keyword">bit</span>[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] delay = <span class="hljs-built_in">$random</span>;<br>      <span class="hljs-keyword">repeat</span> (delay) @(<span class="hljs-keyword">posedge</span> if0<span class="hljs-variable">.clk</span>);<br>      if0<span class="hljs-variable">.cb</span><span class="hljs-variable">.req</span> &lt;= ~ if0<span class="hljs-variable">.cb</span><span class="hljs-variable">.req</span>;<br>    <span class="hljs-keyword">end</span><br>    #<span class="hljs-number">20</span> <span class="hljs-built_in">$finish</span>;<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><p>It can be seen from simulation output window that <em>req</em> is driven #5ns after the clock edge.</p><p><a href="https://www.chipverify.com/images/sv/clocking-block-output.PNG"><img src="https://www.chipverify.com/images/sv/clocking-block-output.PNG" alt="img"></a></p><h2 id="Output-skew"><a href="#Output-skew" class="headerlink" title="Output skew"></a>Output skew</h2><p>To get a clear picture of the output skew, lets tweak the interface to have three different clocking blocks each with a different output skew. Then let us drive req with each of the clocking blocks to see the difference.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">interface</span> _if (<span class="hljs-keyword">input</span> <span class="hljs-keyword">bit</span> clk);<br>  <span class="hljs-keyword">logic</span> gnt;<br>  <span class="hljs-keyword">logic</span> req;<br> <br>  <span class="hljs-keyword">clocking</span> cb_0 @(<span class="hljs-keyword">posedge</span> clk);<br>    <span class="hljs-keyword">output</span> #<span class="hljs-number">0</span>  req;<br>  <span class="hljs-keyword">endclocking</span><br> <br>  <span class="hljs-keyword">clocking</span> cb_1 @(<span class="hljs-keyword">posedge</span> clk);<br>    <span class="hljs-keyword">output</span> #<span class="hljs-number">2</span> req;<br>  <span class="hljs-keyword">endclocking</span><br> <br>  <span class="hljs-keyword">clocking</span> cb_2 @(<span class="hljs-keyword">posedge</span> clk);<br>    <span class="hljs-keyword">output</span> #<span class="hljs-number">5</span> req;<br>  <span class="hljs-keyword">endclocking</span><br><span class="hljs-keyword">endinterface</span>  <br> <br></code></pre></td></tr></table></figure><p>In our testbench, we’ll use a <code>for</code> loop to iterate through each stimulus and use a different clocking block for each iteration.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb;<br>  <span class="hljs-comment">// ... part of code same as before</span><br> <br>  <span class="hljs-comment">// Drive stimulus</span><br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) <span class="hljs-keyword">begin</span><br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">2</span>) @(if0<span class="hljs-variable">.cb_0</span>);      <br>      <span class="hljs-keyword">case</span> (i)<br>        <span class="hljs-number">0</span> : if0<span class="hljs-variable">.cb_0</span><span class="hljs-variable">.req</span> &lt;= <span class="hljs-number">1</span>;<br>        <span class="hljs-number">1</span> : if0<span class="hljs-variable">.cb_1</span><span class="hljs-variable">.req</span> &lt;= <span class="hljs-number">1</span>;<br>        <span class="hljs-number">2</span> : if0<span class="hljs-variable">.cb_2</span><span class="hljs-variable">.req</span> &lt;= <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">endcase</span><br>      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">2</span>) @ (if0<span class="hljs-variable">.cb_0</span>);<br>      if0<span class="hljs-variable">.req</span> &lt;= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">end</span><br>    #<span class="hljs-number">20</span> <span class="hljs-built_in">$finish</span>;<br>  <span class="hljs-keyword">end</span><br> <br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><p><a href="https://www.chipverify.com/images/sv/cb-output-skew.PNG"><img src="https://www.chipverify.com/images/sv/cb-output-skew.PNG" alt="img"></a></p><h2 id="Input-skew"><a href="#Input-skew" class="headerlink" title="Input skew"></a>Input skew</h2><p>To understand input skew, we’ll change the DUT to simply provide a random value every #1ns just for our purpose.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> des (<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] gnt);<br>  <span class="hljs-keyword">always</span> #<span class="hljs-number">1</span> gnt &lt;= <span class="hljs-built_in">$random</span>;<br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><p>The interface block will have different clocking block declarations like before each with a different input skew.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">interface</span> _if (<span class="hljs-keyword">input</span> <span class="hljs-keyword">bit</span> clk);<br>  <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] gnt;<br> <br>  <span class="hljs-keyword">clocking</span> cb_0 @(<span class="hljs-keyword">posedge</span> clk);<br>    <span class="hljs-keyword">input</span> #<span class="hljs-number">0</span>  gnt;<br>  <span class="hljs-keyword">endclocking</span><br> <br>  <span class="hljs-keyword">clocking</span> cb_1 @(<span class="hljs-keyword">posedge</span> clk);<br>    <span class="hljs-keyword">input</span> #<span class="hljs-number">1</span>step gnt;<br>  <span class="hljs-keyword">endclocking</span><br> <br>  <span class="hljs-keyword">clocking</span> cb_2 @(<span class="hljs-keyword">posedge</span> clk);<br>    <span class="hljs-keyword">input</span> #<span class="hljs-number">1</span> gnt;<br>  <span class="hljs-keyword">endclocking</span><br> <br>  <span class="hljs-keyword">clocking</span> cb_3 @(<span class="hljs-keyword">posedge</span> clk);<br>    <span class="hljs-keyword">input</span> #<span class="hljs-number">2</span> gnt;<br>  <span class="hljs-keyword">endclocking</span><br><span class="hljs-keyword">endinterface</span>  <br> <br></code></pre></td></tr></table></figure><p>In the testbench, we’ll fork 4 different threads at time 0ns where each thread waits for the positive edge of the clock and samples the output from DUT.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tb;<br>  <span class="hljs-keyword">bit</span> clk;<br> <br>  <span class="hljs-keyword">always</span> #<span class="hljs-number">5</span> clk = ~clk;<br>  <span class="hljs-keyword">initial</span>   clk &lt;= <span class="hljs-number">0</span>;<br> <br>  _if if0 (<span class="hljs-variable">.clk</span> (clk));<br>  des d0  (<span class="hljs-variable">.gnt</span> (if0<span class="hljs-variable">.gnt</span>));<br> <br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">fork</span><br>      <span class="hljs-keyword">begin</span><br>        @(if0<span class="hljs-variable">.cb_0</span>);<br>        <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;cb_0.gnt = 0x%0h&quot;</span>, if0<span class="hljs-variable">.cb_0</span><span class="hljs-variable">.gnt</span>);<br>      <span class="hljs-keyword">end</span><br>      <span class="hljs-keyword">begin</span><br>        @(if0<span class="hljs-variable">.cb_1</span>);<br>        <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;cb_1.gnt = 0x%0h&quot;</span>, if0<span class="hljs-variable">.cb_1</span><span class="hljs-variable">.gnt</span>);<br>      <span class="hljs-keyword">end</span><br>      <span class="hljs-keyword">begin</span><br>        @(if0<span class="hljs-variable">.cb_2</span>);<br>        <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;cb_2.gnt = 0x%0h&quot;</span>, if0<span class="hljs-variable">.cb_2</span><span class="hljs-variable">.gnt</span>);<br>      <span class="hljs-keyword">end</span><br>      <span class="hljs-keyword">begin</span><br>        @(if0<span class="hljs-variable">.cb_3</span>);<br>        <span class="hljs-built_in">$display</span> (<span class="hljs-string">&quot;cb_3.gnt = 0x%0h&quot;</span>, if0<span class="hljs-variable">.cb_3</span><span class="hljs-variable">.gnt</span>);<br>      <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">join</span><br>    #<span class="hljs-number">10</span> <span class="hljs-built_in">$finish</span>;<br>  <span class="hljs-keyword">end</span><br> <br><span class="hljs-keyword">endmodule</span><br> <br></code></pre></td></tr></table></figure><p>The output waveform is shown below and it can be seen that the design drives a random value every #1ns.</p><p><a href="https://www.chipverify.com/images/sv/cb-input-skew.PNG"><img src="https://www.chipverify.com/images/sv/cb-input-skew.PNG" alt="img"></a></p><p>It’s important to note that the testbench code which sampled through cb_1 clocking block managed to get the value 0x3 while cb_0 got 0xd. Note that these values may be different for other simulators since they can take a different randomization seed value.</p><p><strong>Simulation Log</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ncsim</span>&gt; run<br><span class="hljs-attribute">cb_3</span>.gnt = <span class="hljs-number">0</span>x9<br><span class="hljs-attribute">cb_2</span>.gnt = <span class="hljs-number">0</span>x3<br><span class="hljs-attribute">cb_1</span>.gnt = <span class="hljs-number">0</span>x3<br><span class="hljs-attribute">cb_0</span>.gnt = <span class="hljs-number">0</span>xd<br><span class="hljs-attribute">Simulation</span> complete via $finish(<span class="hljs-number">1</span>) at time <span class="hljs-number">15</span> NS + <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SV</tag>
      
      <tag>ChipVerif_Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVMPrimer中的DUT改写成Verilog</title>
    <link href="/2019/07/10/Verification/SystemVerilog/UVMPrimer%E4%B8%AD%E7%9A%84DUT%E6%94%B9%E5%86%99%E6%88%90Verilog/"/>
    <url>/2019/07/10/Verification/SystemVerilog/UVMPrimer%E4%B8%AD%E7%9A%84DUT%E6%94%B9%E5%86%99%E6%88%90Verilog/</url>
    
    <content type="html"><![CDATA[<h3 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h3><p>讲UVMPrimer书给的代码中的DUT改写成了Verilog形式，原来时VHDL形式，用VCS仿真的时候总是出错，花了大半天改写了。</p><h3 id="DUT介绍"><a href="#DUT介绍" class="headerlink" title="DUT介绍"></a>DUT介绍</h3><p>这本书中的DUT是个ALU，模块管脚如下图，</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/verification/primer/1.png"></p><p>A,B是两个八位的输入，start是启动信号，op是命令信号，包括加，乘，与等，result是计算结果，done是DUT的应答信号，当dut计算结束，done为1。ALU中的计算有单周期，也有多周期的乘法指令。</p><p><strong>op命令的编码如下：</strong></p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/verification/primer/2.png"></p><p><strong>ALU的时序图如下，这就是管脚的协议，设计工程师根据协议来design，验证师根据协议来验证设计是否满足协议。</strong></p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/verification/primer/3.png"></p><p>start有效时，ALU读取op,A,B信号，ALU计算中start一直是高，当ALU计算结束，ALU拉高done信号，此时start可以拉低了，done为高只持续一个周期。</p><h3 id="ALU代码："><a href="#ALU代码：" class="headerlink" title="ALU代码："></a>ALU代码：</h3><p>单周期的指令</p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> single_alu(<br>  <span class="hljs-keyword">input</span> clk,<br>  <span class="hljs-keyword">input</span> rst_n,<br>  <span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] A,<br>  <span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] B,<br>  <span class="hljs-keyword">input</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] op,<br>  <span class="hljs-keyword">input</span> start,<br>  <span class="hljs-keyword">output</span> done,<br>  <span class="hljs-keyword">output</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] result<br>);<br><br><span class="hljs-keyword">reg</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] result_r;<br><span class="hljs-keyword">reg</span> done_r;<br><br><span class="hljs-keyword">assign</span> result = result_r;<br><span class="hljs-keyword">assign</span> done = done_r;<br><br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk ) <span class="hljs-keyword">begin</span> <span class="hljs-comment">//synchronize</span><br>  <span class="hljs-keyword">if</span>(rst_n == <span class="hljs-number">1&#x27;b0</span>) <span class="hljs-keyword">begin</span><br>    result_r &lt;= <span class="hljs-number">&#x27;b0</span>; <br>  <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span>(start == <span class="hljs-number">1&#x27;b1</span>) <span class="hljs-keyword">begin</span><br>      <span class="hljs-keyword">case</span>(op)<br>        <span class="hljs-number">3&#x27;b001</span>:result_r &lt;= A+B;<br>        <span class="hljs-number">3&#x27;b010</span>:result_r &lt;= A&amp;B;<br>        <span class="hljs-number">3&#x27;b011</span>:result_r &lt;= A^B;<br>        <span class="hljs-keyword">default</span>: result_r &lt;= <span class="hljs-number">&#x27;b0</span>;<br>      <span class="hljs-keyword">endcase</span><br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">end</span><br>  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@ %0t : [single alu] result is %d !!!&quot;</span>,<span class="hljs-built_in">$time</span>,result_r);<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rst_n) <span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">if</span>(rst_n == <span class="hljs-number">1&#x27;b0</span>) done_r &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span>(start==<span class="hljs-number">1&#x27;b1</span> &amp;&amp; op != <span class="hljs-number">3&#x27;b000</span>) <span class="hljs-keyword">begin</span><br>      done_r &lt;= <span class="hljs-number">1&#x27;b1</span>;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span> done_r &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>多周期乘法指令</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> mul_alu(<br>  <span class="hljs-keyword">input</span> clk,<br>  <span class="hljs-keyword">input</span> rst_n,<br>  <span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] A,<br>  <span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] B,<br>  <span class="hljs-keyword">input</span> start,<br>  <span class="hljs-keyword">output</span> done,<br>  <span class="hljs-keyword">output</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] result<br>    <span class="hljs-comment">// 这里没有op信号</span><br>);<br><br><span class="hljs-keyword">reg</span> done_r,done1,done2,done3;<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] result_r,mul1,mul2;<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] a,b;<br><br><span class="hljs-keyword">assign</span> done = done_r;<br><span class="hljs-keyword">assign</span> result = result_r;<br><br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rst_n) <span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">if</span>(rst_n &lt;= <span class="hljs-number">1&#x27;b0</span>) <span class="hljs-keyword">begin</span><br>    done_r &lt;= <span class="hljs-number">&#x27;b0</span>;<br>    done1 &lt;= <span class="hljs-number">&#x27;b0</span> ; <br>    done2 &lt;= <span class="hljs-number">&#x27;b0</span> ;<br>    done3 &lt;= <span class="hljs-number">&#x27;b0</span> ;<br><br>    mul1 &lt;= <span class="hljs-number">&#x27;b0</span>;<br>    mul2 &lt;= <span class="hljs-number">&#x27;b0</span>;<br>    result_r &lt;= <span class="hljs-number">&#x27;b0</span>;<br>    a&lt;=<span class="hljs-number">0</span>;<br>    b&lt;=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>    a &lt;= A;<br>    b &lt;= B;<br>    mul1 &lt;= a*b;<br>    mul2 &lt;= mul1;<br>    result_r &lt;= mul2;<br>    done3 &lt;= start &amp;&amp; (~done_r);<br>    done2 &lt;= done3 &amp;&amp; (~done_r);<br>    done1 &lt;= done2 &amp;&amp; (~done_r);<br>    done_r &lt;= done1 &amp;&amp;(~done_r);<br>  <span class="hljs-keyword">end</span><br> <span class="hljs-comment">// $display(&quot;@ %0t : [mul alu] result is %d !!!&quot;,$time,result_r);</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>顶层模块</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> tinyalu(<br>  <span class="hljs-keyword">input</span> clk,<br>  <span class="hljs-keyword">input</span> reset_n,<br>  <span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] A,<br>  <span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] B,<br>  <span class="hljs-keyword">input</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] op,<br>  <span class="hljs-keyword">input</span> start,<br>  <span class="hljs-keyword">output</span> done,<br>  <span class="hljs-keyword">output</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] result<br>);<br><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] result_sgl,result_mul;<br><span class="hljs-keyword">reg</span> start_sgl,start_mul;<br><span class="hljs-keyword">wire</span> done_sgl,done_mul;<br><span class="hljs-keyword">reg</span> done_r;<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] result_r;<br><br><span class="hljs-keyword">assign</span> done = done_r;<br><span class="hljs-keyword">assign</span> result = result_r;<br><br>single_alu sgl_u(<span class="hljs-variable">.clk</span>(clk),<span class="hljs-variable">.rst_n</span>(reset_n),<span class="hljs-variable">.A</span>(A),<span class="hljs-variable">.B</span>(B),<span class="hljs-variable">.op</span>(op),<br><span class="hljs-variable">.start</span>(start_sgl),<span class="hljs-variable">.done</span>(done_sgl),<span class="hljs-variable">.result</span>(result_sgl));<br><br>mul_alu mul_u(<span class="hljs-variable">.clk</span>(clk),<span class="hljs-variable">.rst_n</span>(reset_n),<span class="hljs-variable">.A</span>(A),<span class="hljs-variable">.B</span>(B),<span class="hljs-variable">.start</span>(start_mul),<br><span class="hljs-variable">.done</span>(done_mul),<span class="hljs-variable">.result</span>(result_mul));<br><span class="hljs-comment">// 根据op的最高位决定是单周期指令还是多周期指令</span><br><span class="hljs-keyword">always</span>@(op[<span class="hljs-number">2</span>],start) <span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">case</span>(op[<span class="hljs-number">2</span>])<br>    <span class="hljs-number">1</span>: <span class="hljs-keyword">begin</span><br>      start_mul = start;<br>      start_sgl = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-number">0</span>: <span class="hljs-keyword">begin</span><br>      start_mul =<span class="hljs-number">0</span>;<br>      start_sgl = start;<br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">endcase</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">always</span>@(op[<span class="hljs-number">2</span>],result_mul,result_sgl) <span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">case</span>(op[<span class="hljs-number">2</span>])<br>    <span class="hljs-number">1</span>: <span class="hljs-keyword">begin</span><br>      result_r = result_mul;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-number">0</span>: <span class="hljs-keyword">begin</span><br>      result_r = result_sgl;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">default</span> result_r = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">endcase</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">always</span>@(op[<span class="hljs-number">2</span>],done_mul,done_sgl) <span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">case</span>(op[<span class="hljs-number">2</span>])<br>    <span class="hljs-number">1</span>: <span class="hljs-keyword">begin</span><br>      done_r = done_mul;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-number">0</span>: <span class="hljs-keyword">begin</span><br>      done_r = done_sgl;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">default</span> done_r = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">endcase</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h3 id="所有文件获取"><a href="#所有文件获取" class="headerlink" title="所有文件获取"></a>所有文件获取</h3><p>把DUT和验证环境放在了GitHub上，<a href="https://github.com/east1203/Verilog_module/tree/master/UVMPrimer%20DUT"><strong>地址</strong></a></p><p>原来</p><h3 id="错误："><a href="#错误：" class="headerlink" title="错误："></a>错误：</h3><p>编码时候出现了一些错误。</p><ol><li><p>定向思维错误。</p><p>在连续写多个always过程语句时候，把相似的敏感列表写成了一样的了。这种错误常常发生，就是脑子木了，惯性的敲代码，没过脑子。</p></li><li><p>给信号result增加寄存器形式result_r，result_r用在过程语句中。result_r的宽度跟result不一致，经常忘了定义宽度。</p></li><li><p>修改了信号，但是没有改全。</p></li><li><p>在tb上例化DUT时，连线信号变了，但是例化DUT部分没有改变这个信号。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>Others</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EasierUVM安装问题</title>
    <link href="/2019/07/01/tools/vcs/EasierUVM%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/"/>
    <url>/2019/07/01/tools/vcs/EasierUVM%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="perl包安装"><a href="#perl包安装" class="headerlink" title="perl包安装"></a>perl包安装</h3><p>EasierUVM需要安装File::Copy::Recursive,File::stat, and Time::Piece modules.这几个PERL 包，官方文档给的安装命令是</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">perl -MCPAN -e &#x27;install File::Copy::Recursive&#x27;<br>perl -MCPAN -e &#x27;install File::stat&#x27;<br>perl -MCPAN -e &#x27;install Time::Piece&#x27;<br></code></pre></td></tr></table></figure><p>如果没有CPAN工具，要先装CPAN。</p><p>很不幸，安装出错，说是YAML没有安装，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">Warning (usually harmless): &#x27;YAML&#x27; not installed, will not store persistent state<br>Running install for module &#x27;Module::Build&#x27;<br>&#x27;YAML&#x27; not installed, falling back to Data::Dumper and Storable to read prefs &#x27;/root/.cpan/prefs&#x27;<br>Running make for L/LE/LEONT/Module-Build-0.4229.tar.gz<br></code></pre></td></tr></table></figure><p>然后我再命令行中安装YMAL</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y *YAML*<br></code></pre></td></tr></table></figure><p>又说没法下载包</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">Error </span>Downloading Packages:<br>  libyaml<span class="hljs-string">-0</span>.1.3<span class="hljs-string">-4</span>.el6_6.x86_64: failure: libyaml<span class="hljs-string">-0</span>.1.3<span class="hljs-string">-4</span>.el6_6.x86_64.rpm from RPM_Packx64: [Errno 256] No more mirrors to try.<br>  perl-YAML-Syck<span class="hljs-string">-1</span>.07<span class="hljs-string">-4</span>.el6.x86_64: failure: perl-YAML-Syck<span class="hljs-string">-1</span>.07<span class="hljs-string">-4</span>.el6.x86_64.rpm from RPM_Packx64: [Errno 256] No more mirrors to try.<br>  perl-YAML-Tiny<span class="hljs-string">-1</span>.40<span class="hljs-string">-2</span>.el6.noarch: failure: perl-YAML-Tiny<span class="hljs-string">-1</span>.40<span class="hljs-string">-2</span>.el6.noarch.rpm from RPM_Packx64: [Errno 256] No more mirrors to try.<br></code></pre></td></tr></table></figure><p>我发现其实系统上装了一个YAML了，然后我把这个YAML卸载了，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum erase *YMAL*<br></code></pre></td></tr></table></figure><p>然后我打开CPAN，在命令行输入cpan，然后安装YMAL，成功了</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># cpan</span><br>cpan&gt; <span class="hljs-keyword">install</span> YMAL<br></code></pre></td></tr></table></figure><p>安装YMAL中间有好多warning，不管，一路确定，执行完没有错误，然后再执行EasierUVM给的安装perl包的命令，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">perl -MCPAN -e &#x27;install File::Copy::Recursive&#x27;<br>perl -MCPAN -e &#x27;install File::stat&#x27;<br></code></pre></td></tr></table></figure><p>这样perl包就安装成功了</p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
      <category>EDA</category>
      
      <category>vcs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>vcs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>仿真错误集合</title>
    <link href="/2019/06/29/Verification/simulation/%E4%BB%BF%E7%9C%9F%E9%94%99%E8%AF%AF%E9%9B%86%E5%90%88/"/>
    <url>/2019/06/29/Verification/simulation/%E4%BB%BF%E7%9C%9F%E9%94%99%E8%AF%AF%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="1-UVM仿真"><a href="#1-UVM仿真" class="headerlink" title="1 UVM仿真"></a>1 UVM仿真</h3><h4 id="1-1-imp声明时两个参数"><a href="#1-1-imp声明时两个参数" class="headerlink" title="1.1 imp声明时两个参数"></a>1.1 imp声明时两个参数</h4><p>Error-[MRRE] Member reference resolution error<br>&#x2F;home&#x2F;IC&#x2F;uvm&#x2F;uvm-1.1d&#x2F;src&#x2F;tlm1&#x2F;uvm_analysis_port.svh, 114<br>  Member operator “.” cannot be used on object of type int.<br>  Expression: m_imp<br>  Source info: m_imp.write</p><p>解决：在uvm_analysis_imp ,uvm_blocking_put_imp等IMP中，声明IMP时候有两个类型参数，</p><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">uvm_analysis_imp<span class="hljs-comment">#(trans,C) C_imp;</span><br><span class="hljs-regexp">//</span> trans是端口传输的transaction类型<br><span class="hljs-regexp">//</span> C是实现这个端口的component<br></code></pre></td></tr></table></figure><p>上面的错是因为少了第二个参数。</p><h4 id="1-2-main-phase下声明对象与super-main-phase顺序"><a href="#1-2-main-phase下声明对象与super-main-phase顺序" class="headerlink" title="1.2   main_phase下声明对象与super.main_phase顺序"></a>1.2   main_phase下声明对象与super.main_phase顺序</h4><p>Back to file ‘top_tb.sv’.</p><p>Error-[SE] Syntax error<br>  Following verilog source has syntax error :<br>  “top_tb.sv”, 102: token is ‘t’<br>    trans t;</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> main_phase(uvm_phase phase);<br>  trans tr;<br>  <span class="hljs-keyword">super</span><span class="hljs-variable">.main_phase</span>(phase);<br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>  `uvm_info(<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;B get a trans&quot;</span>,UVM_LOW);<br>  B_port<span class="hljs-variable">.get</span>(tr);<br>  tr<span class="hljs-variable">.print</span>();<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><p>出错原因是tr的定义写在了super.main_phase(phase)之后，上面代码是正确的写法。</p><p><strong>其他的phase类型，所以，没事不要写super.*_phase(phase)</strong></p><h4 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h4><p>Back to file ‘top_tb.sv’.</p><p>Error-[SE] Syntax error<br>  Following verilog source has syntax error :<br>  “top_tb.sv”, 38: token is ‘d’<br>      edata d&#x3D;new();</p><h3 id="2-语法错误"><a href="#2-语法错误" class="headerlink" title="2. 语法错误"></a>2. 语法错误</h3><h4 id="2-1-SV中task中的变量在其他语句之前定义"><a href="#2-1-SV中task中的变量在其他语句之前定义" class="headerlink" title="2.1 SV中task中的变量在其他语句之前定义"></a>2.1 SV中task中的变量在其他语句之前定义</h4><p>SsystemVerilog中，task function中可以定义变量，但这些变量需要在其他语句之前定义，包括$display语句。</p><h4 id="2-2-接口定义的时候加"><a href="#2-2-接口定义的时候加" class="headerlink" title="2.2 接口定义的时候加()"></a>2.2 接口定义的时候加()</h4><p>如果接口没有参数列表，那么在top中声明接口的时候也要加上括号()</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top;<br><span class="hljs-keyword">interface</span> <span class="hljs-keyword">if</span>;<br>,,,,<br><span class="hljs-keyword">endinterface</span><br><span class="hljs-keyword">if</span> if0();<br>    <span class="hljs-comment">//不能写成if if0; 会报错。</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h3 id="3-仿真脚本"><a href="#3-仿真脚本" class="headerlink" title="3. 仿真脚本"></a>3. 仿真脚本</h3><h4 id="3-1-类在package中include，"><a href="#3-1-类在package中include，" class="headerlink" title="3.1 类在package中include，"></a>3.1 类在package中include，</h4><p>类在package中用&#96;include进去，在vcs选项中的文件是top.sv模块，接口模块文件，package文件。</p><h4 id="3-2-用run文件和Makefile文件启动VCS的不同"><a href="#3-2-用run文件和Makefile文件启动VCS的不同" class="headerlink" title="3.2 用run文件和Makefile文件启动VCS的不同"></a>3.2 用run文件和Makefile文件启动VCS的不同</h4><p>用run文件启动，在run文件中引用变量可以直接写成    $UVM_HOME</p><p>但是在Makefile文件中，设置变量： cov_opt &#x3D; line+tgl+fsm+cond    。使用变量要加花括号{}：${cov_opt}</p>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>Simulation</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>sim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 函数指针</title>
    <link href="/2019/06/28/C++/%E5%87%BD%E6%95%B0/C++%20%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
    <url>/2019/06/28/C++/%E5%87%BD%E6%95%B0/C++%20%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>函数指针，指向函数的指针，而不是对象。函数的类型由它的返回值类型和形参共同决定，与函数名无关。</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 定义一个函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s1,<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s2)</span>;<br><span class="hljs-comment">// 函数指针</span><br><span class="hljs-type">void</span> (*fp)(<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s1,<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s2);<br></code></pre></td></tr></table></figure><p>函数指针的定义，只需用函数指针名替换函数名即可，<strong>注意一定要加括号，要不然就成了返回void*类型的函数了。</strong></p><h3 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2. 初始化"></a>2. 初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 定义一个函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s1,<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s2)</span>;<br><span class="hljs-comment">// 函数指针</span><br><span class="hljs-type">void</span> (*fp)(<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s1,<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s2);<br><span class="hljs-comment">//方法一</span><br>pf=display;<br><span class="hljs-comment">//方法二   取地址符号可选</span><br>pf=&amp;display;  <br></code></pre></td></tr></table></figure><h3 id="3-使用函数指针"><a href="#3-使用函数指针" class="headerlink" title="3. 使用函数指针"></a>3. 使用函数指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 定义一个函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s1,<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s2)</span>;<br><span class="hljs-comment">// 函数指针</span><br><span class="hljs-type">void</span> (*fp)(<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s1,<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s2);<br><span class="hljs-comment">// 初始化</span><br>pf=display;<br><span class="hljs-comment">// 调用函数指针</span><br>pf(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>);<br><span class="hljs-comment">// 或者</span><br>(*pf)(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>);<br><span class="hljs-comment">// 等价于</span><br>display(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="4-函数指针形参"><a href="#4-函数指针形参" class="headerlink" title="4. 函数指针形参"></a>4. 函数指针形参</h3><p>函数指针可以作为形参，传递给函数。函数指针作为应用程序的一个接口。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// test函数有一个函数指针形参</span><br><span class="hljs-comment">// 参数是函数类型，它会自动转换成函数指针</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">void</span> fp(<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s1,<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s2))</span>;<br><span class="hljs-comment">// 或者显式声明为函数指针</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">void</span> (*fp)(<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s1,<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s2))</span><br>&#123;<br>    fp(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-decltype-操作符"><a href="#5-decltype-操作符" class="headerlink" title="5. decltype 操作符"></a>5. decltype 操作符</h3><p>decltype返回函数类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span> <span class="hljs-title function_">Func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s1,<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s2)</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">decltype</span><span class="hljs-params">(display)</span> Func2;   <span class="hljs-comment">//与上方等价的定义，</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*PFunc)</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s1,<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s2)</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">decltype</span><span class="hljs-params">(display)</span> *PFunc2; <span class="hljs-comment">//与上方等价的定义。</span><br></code></pre></td></tr></table></figure><p>Func和Func2是函数类型，PFunc和PFunc2是函数指针类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Func2 fp)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(PFunc2 fp)</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV——系统函数</title>
    <link href="/2019/06/26/Verification/SystemVerilog/SV%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0/"/>
    <url>/2019/06/26/Verification/SystemVerilog/SV%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="1-随机化相关函数"><a href="#1-随机化相关函数" class="headerlink" title="1 随机化相关函数"></a>1 随机化相关函数</h3><h4 id="1-std-randomize-with"><a href="#1-std-randomize-with" class="headerlink" title="1)  std::randomize() with"></a>1)  std::randomize() with</h4><p>对于随机对象，可以采用object.randomize()的方式进行随机化，但有的时候可以通过更简单的方式，不必定义类和例化对象，甚至变量都不是随机类型，也可以对其进行随机化，这就是系统随机化 函数std::randomize。</p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span> <span class="hljs-comment">//SV</span><br><span class="hljs-keyword">int</span> value;<br>    std::randomize(value) <span class="hljs-keyword">with</span> &#123;value&gt;=<span class="hljs-number">0</span> &amp;&amp; value&lt;=<span class="hljs-number">10</span>;&#125;;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="2-srandom-设置随机钟子"><a href="#2-srandom-设置随机钟子" class="headerlink" title="2)  srandom() 设置随机钟子"></a>2)  srandom() 设置随机钟子</h4><p>手动设置随机种子，保证每次运行程序的时候随机化的结构一样，方便重现仿真情景。对象的钟子可以在对象上设置或者采用进程的钟子，而进程的种子必须在进程中设置。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">class</span> trans;<br><span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] a;<br><span class="hljs-keyword">endclass</span><br><span class="hljs-keyword">module</span> test;<br>trans tr;<br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    tr=<span class="hljs-keyword">new</span>();<br>    tr<span class="hljs-variable">.srandom</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 设置对象的随机种子</span><br>    <span class="hljs-keyword">repeat</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span><br>        tr<span class="hljs-variable">.randomize</span>();<br>        <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@ %0t tr : %0d&quot;</span>,<span class="hljs-built_in">$time</span>,tr<span class="hljs-variable">.a</span>);<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br>    <br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    process::self<span class="hljs-variable">.srandom</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 设置进程的随机钟子</span><br>    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@ %0t : %0d&quot;</span>,<span class="hljs-built_in">$time</span>,urandom_range(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>));<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h4 id="3）random-int-seed"><a href="#3）random-int-seed" class="headerlink" title="3）random(int seed)"></a>3）random(int seed)</h4><p>返回32bit有符号数，seed是可选的</p><h4 id="4-urandom-int-seed"><a href="#4-urandom-int-seed" class="headerlink" title="4)  urandom(int seed)"></a>4)  urandom(int seed)</h4><p>无符号</p><h4 id="5）urandom-range"><a href="#5）urandom-range" class="headerlink" title="5）urandom_range()"></a>5）urandom_range()</h4><p>unrandom_range(int unsigned MIN,int unsigned MAX)，指定范围内的无符号随机数，MIN可以省略，默认0.</p><h3 id="2-IO"><a href="#2-IO" class="headerlink" title="2.   IO"></a>2.   IO</h3><h4 id="1）sformatf格式化字符串"><a href="#1）sformatf格式化字符串" class="headerlink" title="1）sformatf格式化字符串"></a>1）sformatf格式化字符串</h4><p>返回一个格式化字符串，使用的格式九个display等输出函数一样，只是它不输出，而是返回字符串。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">string</span> msg;<br>smg=<span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;@%0t [%s] %s : %s&quot;</span>, <span class="hljs-built_in">$time</span>, r, src, i);<br></code></pre></td></tr></table></figure><h4 id="2）-sprint（）返回字符串"><a href="#2）-sprint（）返回字符串" class="headerlink" title="2） sprint（）返回字符串"></a>2） sprint（）返回字符串</h4><p>uvm_object默认的函数，print()是打印object的信息，而sprint()将要打印的信息返回成字符串。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">`uvm_info(<span class="hljs-string">&quot;drv&quot;</span>,sformatf(<span class="hljs-string">&quot;send a trans! \n %s&quot;</span>,tr<span class="hljs-variable">.sprint</span>()),UVM_LOW);<br></code></pre></td></tr></table></figure><h3 id="3-输出到文件"><a href="#3-输出到文件" class="headerlink" title="3. 输出到文件"></a>3. 输出到文件</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">integer</span> logf;<br>logf = <span class="hljs-built_in">$fopen</span>(logname, <span class="hljs-string">&quot;a+&quot;</span>);<br><span class="hljs-built_in">$fwrite</span>(logf, <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, msg));<br><span class="hljs-built_in">$fclose</span>(logf);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gvim中设置字体背景</title>
    <link href="/2019/06/18/linux/gvim%E8%AE%BE%E7%BD%AE%E5%AD%97%E4%BD%93%E8%83%8C%E6%99%AF/"/>
    <url>/2019/06/18/linux/gvim%E8%AE%BE%E7%BD%AE%E5%AD%97%E4%BD%93%E8%83%8C%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<p><strong>在&#x2F;etc&#x2F;vimrc文件中添加如下命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">set gfn=Sans\ 12<br>colorscheme desert<br>set nobackup<br></code></pre></td></tr></table></figure><p>第一行：设置字体类型和字体大小，注意vimrc不支持空格，所以<strong>空格都需要加上反斜杠转义</strong>，这点很重要，我就在这里出错，试了好多遍都不对，最后有一篇文章说需要用反斜杠才搞定。</p><p>第二行：设置背景</p><p>第三行：设置不进行自动备份，不知道什么意思，看别人这么设的，不设置也可以。</p><p>有哪些字体、背景色都可以在gvim的edit选项标签下找到。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中的拷贝、赋值与销毁</title>
    <link href="/2019/06/16/C++/%E7%B1%BB/C++%E4%B8%AD%E7%9A%84%E6%8B%B7%E8%B4%9D%E3%80%81%E8%B5%8B%E5%80%BC%E4%B8%8E%E9%94%80%E6%AF%81/"/>
    <url>/2019/06/16/C++/%E7%B1%BB/C++%E4%B8%AD%E7%9A%84%E6%8B%B7%E8%B4%9D%E3%80%81%E8%B5%8B%E5%80%BC%E4%B8%8E%E9%94%80%E6%AF%81/</url>
    
    <content type="html"><![CDATA[<h3 id="1-拷贝构造函数"><a href="#1-拷贝构造函数" class="headerlink" title="1. 拷贝构造函数"></a>1. 拷贝构造函数</h3><p>如果一个构造函数的第一个参数是该类类型的引用，且其他参数都有默认值，那么这是个拷贝构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>&#123;<br><span class="hljs-built_in">Foo</span>();<br><span class="hljs-built_in">Foo</span>(<span class="hljs-type">const</span> Foo&amp;);  <span class="hljs-comment">//拷贝构造函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="1-1-合成拷贝构造函数"><a href="#1-1-合成拷贝构造函数" class="headerlink" title="1.1 合成拷贝构造函数"></a>1.1 合成拷贝构造函数</h4><p>​        如果没有为类定义拷贝构造函数，那么编译器会自动定义一个合成拷贝构造函数。与合成默认构造函数不同（如果定义了其他构造函数，那么编译器就不会定义合成默认构造函数），即使定义了其他的构造函数，编译器还是会自动定义一个合成拷贝构造函数。</p><p>​        合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。编译器从给定对象中将每个非static成员拷贝到正在创建的对象中。</p><h4 id="1-2-拷贝初始化"><a href="#1-2-拷贝初始化" class="headerlink" title="1.2  拷贝初始化"></a>1.2  拷贝初始化</h4><p>​        用”&#x3D;“来初始化的就是拷贝初始化，它将等号右边的初始值复制给等号左边对象。不用等号的就是直接初始化。</p><p>​        如果使用直接初始化，编译器会根据普通函数匹配的原则来选择合适的构造函数来匹配（这里是说构造函数而不是拷贝构造函数，只要是与类名相同的函数都是构造函数）。如果是拷贝赋值，编译器需要将右侧对象拷贝到左侧对象，<strong>如果需要的话还要进行类型转换。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">dots</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;.&#x27;</span>)</span></span>;  <span class="hljs-comment">//直接初始化</span><br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(dots)</span></span>;               <span class="hljs-comment">//直接初始化</span><br>string s2=dots;  <span class="hljs-comment">//拷贝初始化</span><br>string nines=<span class="hljs-built_in">string</span>(<span class="hljs-number">100</span>,<span class="hljs-string">&#x27;9&#x27;</span>); <span class="hljs-comment">//拷贝初始化</span><br></code></pre></td></tr></table></figure><p><strong>拷贝构造函数的使用情况：</strong></p><ol><li>用等号定义变量的初始值的时候</li><li>将一个对象作为实参传给非引用类型的形参。（<strong>这也解释了为什么拷贝构造函数第一个参数是引用类型</strong>）</li><li>从一个返回类型为非引用类型的函数返回一个对象。</li><li>用花括号列表初始化数组中的元素或者聚合类中的成员。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Data</span>&#123;<br><span class="hljs-type">int</span> val;<br>string str;<br>&#125;;<br><span class="hljs-comment">//花括号初始化聚合类</span><br>Data d=&#123;<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;dong&#x27;</span>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-拷贝赋值运算符"><a href="#2-拷贝赋值运算符" class="headerlink" title="2. 拷贝赋值运算符"></a>2. 拷贝赋值运算符</h3><p>通过重载赋值运算符可以赋值的行为。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    Foo&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Foo&amp;);<br>&#125;;<br>Foo&amp; Foo::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Foo&amp; f)<br>&#123;<br>    <span class="hljs-keyword">this</span>.ele = f.ele;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>赋值运算符必须定义为成员函数</strong>。赋值运算符左侧的对象默认绑定到了this指针上，返回值一般是自身类型的引用。</p><h3 id="3-析构函数"><a href="#3-析构函数" class="headerlink" title="3. 析构函数"></a>3. 析构函数</h3><p>作用：释放对象所使用的资源，并销毁对象的非static数据成员。</p><p><strong>调用析构函数的情况：</strong></p><ol><li>变量离开其作用域</li><li>对象被销毁时，其成员被销毁。</li><li>容器被销毁时，其元素被销毁。</li><li>动态分配的对象，被delete的时候。</li><li>对于临时对象，当创建它的表达式结束时销毁。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">string str = <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-comment">// 等号右侧string(&quot;hello&quot;)创建了一个临时对象。</span><br></code></pre></td></tr></table></figure><p>当指向一个对象的指针或者引用离开其作用域时不会执行析构函数。</p><h4 id="4-析构与拷贝"><a href="#4-析构与拷贝" class="headerlink" title="4.  析构与拷贝"></a>4.  析构与拷贝</h4><p><strong>需要析构函数的时候一般也需要拷贝构造函数和赋值操作符，反之亦然。</strong></p><h4 id="5-default"><a href="#5-default" class="headerlink" title="5.  default"></a>5.  default</h4><p>可以将拷贝构造函数显示定义为default，让编译器自动生成合成的拷贝构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sales_data</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Sales_data</span>() = <span class="hljs-keyword">default</span>;<br><span class="hljs-built_in">Sales_data</span>(<span class="hljs-type">const</span> Sales_data&amp;) = <span class="hljs-keyword">default</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="6-补充"><a href="#6-补充" class="headerlink" title="6.  补充"></a>6.  补充</h4><p>关于拷贝构造函数，还可以通过将其设置成delete函数（删除函数），来阻止拷贝操作，或者定义成私有成员。</p><p>还有关于拷贝的内存管理的内容，拷贝与移动赋值的关系等等。</p><p>（以后有时间再补充)</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用VCS启动UVM仿真</title>
    <link href="/2019/06/13/tools/vcs/%E7%94%A8VCS%E5%90%AF%E5%8A%A8UVM%E4%BB%BF%E7%9C%9F/"/>
    <url>/2019/06/13/tools/vcs/%E7%94%A8VCS%E5%90%AF%E5%8A%A8UVM%E4%BB%BF%E7%9C%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h3><ol><li>下载好uvm的库，解压后的文件夹uvm-1.1d，<a href="https://www.accellera.org/downloads/standards/uvm">accellera官网下载UVM</a></li><li>将库保存在linux虚拟机自己的目录下</li></ol><h3 id="2-步骤"><a href="#2-步骤" class="headerlink" title="2. 步骤"></a>2. 步骤</h3><ol><li>在.bashrc文件中设置变量 $UVM_HOME，这个变量保存uvm-1.1d的目录，设置了这个变量后，在用到uvm库的路径的时候，就可以用$UVM_HOME.</li></ol><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs c">cd ~<br>gvim .bashrc<br><span class="hljs-comment">// 在.bashrc文件中添加uvm-1.1d这个文件夹的地址</span><br><span class="hljs-comment">//比如 </span><br>export UVM_HOME=~/uvm/uvm<span class="hljs-number">-1.1</span>d<br></code></pre></td></tr></table></figure><ol start="2"><li>设置VCS运行脚本</li></ol><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-comment"># filename :run</span><br>vcs +acc +vpi -sverilog <span class="hljs-variable">$UVM_HOME</span>/src/dpi/uvm_dpi.cc -CFLAGS -DVCS -timescale=<span class="hljs-number">1</span>ns/<span class="hljs-number">1</span>ps -f filelist.f <br>./simv +UVM_TESTNAME=$<span class="hljs-number">1</span><br><span class="hljs-comment"># +UVM_TESTNAME是要测试的case，使用的时候 ./run my_case0，这个$1就替换成了my_case0</span><br></code></pre></td></tr></table></figure><ol start="3"><li>filelist.f文件的内容</li></ol><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tcl">+incdir+<span class="hljs-variable">$UVM_HOME</span>/src<br><span class="hljs-variable">$UVM_HOME</span>/src/uvm_pkg.sv<br>/home/IC/Desktop/my_uvm/dut/dut.sv<br>top_tb.sv<br><span class="hljs-comment"># dut.sv是DUT</span><br><span class="hljs-comment"># top_tb.sv是测试平台最顶层</span><br></code></pre></td></tr></table></figure><ol start="4"><li>在top_tb.sv中&#96;include一些文件</li></ol><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-meta">`<span class="hljs-keyword">timescale</span> 1ns/1ps</span><br><span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;uvm_macros.svh&quot;</span><br><br><span class="hljs-keyword">import</span> uvm_pkg::*;<br><span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;my_if.sv&quot;</span><br><span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;my_transaction.sv&quot;</span><br><span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;my_sequencer.sv&quot;</span><br><span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;my_driver.sv&quot;</span><br><span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;my_monitor.sv&quot;</span><br><span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;my_agent.sv&quot;</span><br><span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;my_model.sv&quot;</span><br><span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;my_scoreboard.sv&quot;</span><br><span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;my_env.sv&quot;</span><br><span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;base_test.sv&quot;</span><br><span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;my_case0.sv&quot;</span><br></code></pre></td></tr></table></figure><ol start="5"><li>运行</li></ol><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl">./run my_case0<br></code></pre></td></tr></table></figure><h3 id="3-VCS仿真UVM脚本2"><a href="#3-VCS仿真UVM脚本2" class="headerlink" title="3. VCS仿真UVM脚本2"></a>3. VCS仿真UVM脚本2</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">vcs     +vpi +acc -sverilog +incdir+$&#123;UVM_HOME&#125;/src \<br>      $&#123;UVM_HOME&#125;/src/uvm_pkg.sv  \<br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;UVM_HOME&#125;/src/dpi/uvm_dpi.cc   \</span><br><span class="language-bash">      -CFLAGS -DVCS \</span><br><span class="language-bash">      -timescale=1ns/1ps \</span><br><span class="language-bash">      top_tb.sv</span> <br>./simv<br></code></pre></td></tr></table></figure><p><strong>上面脚本中，顺序不能错，一点都不能错。</strong></p><p>+acc：使能PLI<br>+vpi：开启VPI PLI</p><p>可以将top_tb.sv替换成filelist.f文件</p><p><strong>注意：在Makefile中，访问变量需要加{}中括号。</strong></p><h3 id="4-VCS仿真UVM脚本3"><a href="#4-VCS仿真UVM脚本3" class="headerlink" title="4. VCS仿真UVM脚本3"></a>4. VCS仿真UVM脚本3</h3><p>在.bashrc文件中设置变量  VCS_UVM_HOME ，设置成。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export VCS_UVM_HOME = $UVM_HOME/src<br></code></pre></td></tr></table></figure><p>运行VCS</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vcs -sverilog -ntb_opts uvm-1.1 test.sv<br></code></pre></td></tr></table></figure><p>如果用到uvm_pkg.sv，就可以按照上面那样直接运行了。其中uvm-1.1是编译选项，告诉vcs按照uvm1.1来进行编译仿真。</p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
      <category>EDA</category>
      
      <category>vcs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vim中systemverilog语法高亮</title>
    <link href="/2019/06/13/linux/vim%E4%B8%ADsystemverilog%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE/"/>
    <url>/2019/06/13/linux/vim%E4%B8%ADsystemverilog%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE/</url>
    
    <content type="html"><![CDATA[<h4 id="1-内容："><a href="#1-内容：" class="headerlink" title="1. 内容："></a>1. 内容：</h4><p>在vim、gvim中设计systemverilog语法高亮。</p><h4 id="2-步骤："><a href="#2-步骤：" class="headerlink" title="2. 步骤："></a>2. 步骤：</h4><ol><li>在自己主目录下创建.vim的隐藏文件夹。<code>cd ~</code></li><li>在.vim目录下创建两个文件夹，命名为syntax和ftdetect。</li><li>在ftdetect文件夹下创建文件sv.vim。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 在文件sv.vim中保存下面一行能容</span><br>au BufRead,BufNewFile *.sv set filetype=systemverilog<br></code></pre></td></tr></table></figure><ol start="4"><li>将systemverilog.vim文件拷贝到syntax目录下，这个文件可以从网上下载，也可以用这里的。</li><li>重新打开vim或者gvim就可以了。</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&quot;Author: Nachum Kanovsky<br>&quot;Email: nkanovsky yahoo com<br>&quot;Version: 1.7<br>if exists(&quot;b:current_syntax&quot;)<br>finish<br>endif<br><br>let b:current_syntax = &quot;systemverilog&quot;<br><br>syntax keyword svTodo TODO contained<br>syntax match svLineComment &quot;//.*&quot; contains=svTodo<br>syntax region svBlockComment start=&quot;/\*&quot; end=&quot;\*/&quot; contains=svTodo<br>syntax keyword svBoolean true false TRUE FALSE<br>syntax region svString start=+&quot;+ skip=+\\&quot;+ end=+&quot;+<br>syntax keyword svType <span class="hljs-type">real</span> realtime event reg wire <span class="hljs-type">integer</span> logic <span class="hljs-type">bit</span> <span class="hljs-type">time</span> byte chandle genvar signed unsigned shortint shortreal string <span class="hljs-type">void</span> <span class="hljs-type">int</span> specparam<br>syntax keyword svDirection <span class="hljs-keyword">input</span> output <span class="hljs-keyword">inout</span> <span class="hljs-keyword">ref</span><br>syntax keyword svStorageClass parameter localparam virtual var protected rand const static automatic extern forkjoin export <span class="hljs-keyword">import</span><br>syntax match svInvPre &quot;`\(\K\k*\)*\&gt;&quot;<br>syntax match svPreProc &quot;`\(__FILE__\|__LINE__\|begin_keywords\|celldefine\|default_nettype\|end_keywords\|endcelldefine\|include\|line\|nounconnected_drive\|pragma\|resetall\|timescale\|unconnected_drive\|undef\|undefineall\)\&gt;&quot;<br>syntax match svPreCondit &quot;`\(else\|elsif\|endif\|ifdef\|ifndef\)\&gt;&quot;<br>syntax match svInclude &quot;`include\&gt;&quot;<br>syntax match svDefine &quot;`define\&gt;&quot;<br>syntax keyword svConditional <span class="hljs-keyword">if</span> <span class="hljs-keyword">else</span> iff<br>syntax match svLabel &quot;^\W*[a-zA-Z_]\+[a-zA-Z_0-9,\[\]\t ]*:&quot;he=e<span class="hljs-number">-1</span> contained<br>syntax region svCase matchgroup=svConditional start=&quot;\&lt;case\|casex\|casez\&gt;&quot; end=&quot;\&lt;endcase\&gt;&quot; contains=<span class="hljs-keyword">ALL</span><br>syntax keyword svRepeat <span class="hljs-keyword">for</span> <span class="hljs-keyword">foreach</span> <span class="hljs-keyword">do</span> <span class="hljs-keyword">while</span> forever repeat<br>syntax keyword svKeyword fork <span class="hljs-keyword">join</span> join_any join_none <span class="hljs-keyword">begin</span> <span class="hljs-keyword">end</span> module endmodule <span class="hljs-keyword">function</span> endfunction task endtask <span class="hljs-keyword">always</span> always_ff always_latch always_comb initial this generate endgenerate config endconfig <span class="hljs-keyword">class</span> endclass clocking endclocking interface endinterface module endmodule package endpackage modport posedge negedge edge defparam assign deassign <span class="hljs-keyword">alias</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">disable</span> wait <span class="hljs-keyword">continue</span> <span class="hljs-keyword">and</span> buf bufif0 bufif1 nand nor <span class="hljs-keyword">not</span> <span class="hljs-keyword">or</span> xnor xor tri tri0 tri1 triand trior trireg pull0 pull1 pullup pulldown cmos <span class="hljs-keyword">default</span> endprimitive endspecify endtable force highz0 highz1 ifnone <span class="hljs-keyword">large</span> macromodule medium nmos notif0 notif1 pmos primitive rcmos <span class="hljs-keyword">release</span> rnmos rpmos rtran rtranif0 rtranif1 scalared small specify strong0 strong1 supply0 supply1 <span class="hljs-keyword">table</span> tran tranif0 tranif1 vectored wand weak0 weak1 wor cell design incdir liblist library noshowcancelled pulsestyle_ondetect pulsestyle_onevent showcancelled use instance uwire <span class="hljs-keyword">assert</span> assume <span class="hljs-keyword">before</span> bind bins binsof break <span class="hljs-keyword">constraint</span> context cover covergroup coverpoint <span class="hljs-keyword">cross</span> dist endgroup endprogram endproperty endsequence enum expect extends final first_match ignore_bins illegal_bins inside <span class="hljs-keyword">intersect</span> <span class="hljs-keyword">local</span> longint matches <span class="hljs-built_in">new</span> <span class="hljs-keyword">null</span> packed priority program property pure randc randcase randsequence <span class="hljs-keyword">sequence</span> solve struct super tagged throughout timeprecision timeunit <span class="hljs-keyword">type</span> typedef <span class="hljs-keyword">union</span> <span class="hljs-keyword">unique</span> wait_order wildcard <span class="hljs-keyword">with</span> <span class="hljs-keyword">within</span> accept_on checker endchecker eventually <span class="hljs-keyword">global</span> implies let nexttime reject_on <span class="hljs-keyword">restrict</span> s_always s_eventually s_nexttime s_until s_until_with strong sync_accept_on sync_reject_on unique0 <span class="hljs-keyword">until</span> until_with untyped weak implements interconnect nettype soft<br>syntax match svInteger &quot;\&lt;\(\.\)\@&lt;![0-9_]\+\(\s*[&#x27;.]\)\@!\&gt;&quot;<br>syntax match svInteger &quot;\(\&lt;[0-9_]\+\s*\)\?&#x27;\(s\|S\)\?\(d\|D\)\s*[0-9_ZzXx?]\+\&gt;&quot;<br>syntax match svInteger &quot;\(\&lt;[0-9_]\+\s*\)\?&#x27;\(s\|S\)\?\(h\|H\)\s*[0-9a-fA-F_ZzXx?]\+\&gt;&quot;<br>syntax match svInteger &quot;\(\&lt;[0-9_]\+\s*\)\?&#x27;\(s\|S\)\?\(o\|O\)\s*[0-7_ZzXx?]\+\&gt;&quot;<br>syntax match svInteger &quot;\(\&lt;[0-9_]\+\s*\)\?&#x27;\(s\|S\)\?\(b\|B\)\s*[01_ZzXx?]\+\&gt;&quot;<br>syntax match svInteger &quot;\&lt;&#x27;\(d\|D\|h\|H\|o\|O\|b\|B\)\&gt;&quot;<br>syntax match svInteger &quot;&#x27;[01xXzZ?]\&gt;&quot;<br>syntax match svReal &quot;\&lt;[0-9_]\+\.[0-9_]\+\(\(e\|E\)[+-]\?[0-9_]\+\)\?\&gt;&quot;<br>syntax match svReal &quot;\&lt;[0-9_]\+\(e\|E\)[+-]\?[0-9_]\+\&gt;&quot;<br>syntax keyword svStructure struct <span class="hljs-keyword">union</span> enum<br>syntax keyword svTypedef typedef<br>syntax match svInvSystemFunction &quot;\$\(\K\k*\)&quot;<br>syntax match svSystemFunction &quot;\$\(display\|finish\|stop\|exit\|realtime\|stime\|time\|printtimescale\|timeformat\|bitstoreal\|realtobits\|bitstoshortreal\|shortrealtobits\|itor\|rtoi\|signed\|unsigned\|cast\|bits\|isunbounded\|typename\|unpacked_dimensions\|dimensions\|left\|right\|low\|high\|increment\|size\|clog2\|asin\|ln\|acos\|log10\|atan\|exp\|atan2\|sqrt\|hypot\|pow\|sinh\|floor\|cosh\|ceil\|tanh\|sin\|asinh\|cos\|acosh\|tan\|atanh\|countbits\|countones\|onehot\|onehot0\|isunknown\|fatal\|error\|warning\|info\|fatal\|error\|warning\|info\|asserton\|assertoff\|assertkill\|assertcontrol\|assertpasson\|assertpassoff\|assertfailon\|assertfailoff\|assertnonvacuouson\|assertvacuousoff\|sampled\|rose\|fell\|stable\|changed\|past\|past_gclk\|rose_gclk\|fell_gclk\|stable_gclk\|changed_gclk\|future_gclk\|rising_gclk\|falling_gclk\|steady_gclk\|changing_gclk\|coverage_control\|coverage_get_max\|coverage_get\|coverage_merge\|coverage_save\|get_coverage\|set_coverage_db_name\|load_coverage_db\|random\|urandom\|urandom_range\|dist_chi_square\|dist_erlang\|dist_exponential\|dist_normal\|dist_poisson\|dist_t\|dist_uniform\|q_initialize\|q_add\|q_remove\|q_full\|q_exam\|asyncandarray\|asyncandplane\|asyncnandarray\|asyncnandplane\|asyncorarray\|asyncorplane\|asyncnorarray\|asyncnorplane\|syncandarray\|syncandplane\|syncnandarray\|syncnandplane\|syncorarray\|syncorplane\|syncnorarray\|syncnorplane\|system\|contained\|transparent\)\&gt;&quot;<br>syntax match svObjectFunctions &quot;\.\(num\|size\|delete\|exists\|first\|last\|next\|prev\|insert\|pop_front\|pop_back\|push_front\|push_back\|find\|find_index\|find_first\|find_first_index\|find_last\|find_last_index\|min\|max\|reverse\|sort\|rsort\|shuffle\|sum\|product\|and\|or\|xor\)\&gt;\(\s\|\n\)*(&quot;he=e<span class="hljs-number">-1</span><br>syntax match svOperator &quot;\(\~\|&amp;\||\|\^\|=\|!\|?\|:\|@\|&lt;\|&gt;\|%\|+\|-\|\*\|\/[\/\*]\@!\)&quot;<br>syntax match svDelimiter &quot;\(&#123;\|&#125;\|(\|)\)&quot;<br><br>highlight! <span class="hljs-keyword">default</span> link svTodo Todo<br>highlight! <span class="hljs-keyword">default</span> link svLineComment <span class="hljs-keyword">Comment</span><br>highlight! <span class="hljs-keyword">default</span> link svBlockComment <span class="hljs-keyword">Comment</span><br>highlight! <span class="hljs-keyword">default</span> link svBoolean <span class="hljs-type">Boolean</span><br>highlight! <span class="hljs-keyword">default</span> link svString String<br>highlight! <span class="hljs-keyword">default</span> link svType <span class="hljs-keyword">Type</span><br>highlight! <span class="hljs-keyword">default</span> link svDirection StorageClass<br>highlight! <span class="hljs-keyword">default</span> link svStorageClass StorageClass<br>highlight! <span class="hljs-keyword">default</span> link svPreProc PreProc<br>highlight! <span class="hljs-keyword">default</span> link svPreCondit PreCondit<br>highlight! <span class="hljs-keyword">default</span> link svInclude <span class="hljs-keyword">Include</span><br>highlight! <span class="hljs-keyword">default</span> link svDefine Define<br>highlight! <span class="hljs-keyword">default</span> link svConditional Conditional<br>highlight! <span class="hljs-keyword">default</span> link svLabel Label<br>highlight! <span class="hljs-keyword">default</span> link svRepeat Repeat<br>highlight! <span class="hljs-keyword">default</span> link svKeyword Keyword<br>highlight! <span class="hljs-keyword">default</span> link svInteger Number<br>highlight! <span class="hljs-keyword">default</span> link svReal Number<br>highlight! <span class="hljs-keyword">default</span> link svStructure Structure<br>highlight! <span class="hljs-keyword">default</span> link svTypedef Typedef<br>highlight! <span class="hljs-keyword">default</span> link svSystemFunction <span class="hljs-keyword">Function</span><br>highlight! <span class="hljs-keyword">default</span> link svOperator <span class="hljs-keyword">Operator</span><br>highlight! <span class="hljs-keyword">default</span> link svDelimiter <span class="hljs-keyword">Delimiter</span><br>highlight! <span class="hljs-keyword">default</span> link svObjectFunctions <span class="hljs-keyword">Function</span><br><br>highlight! <span class="hljs-keyword">default</span> link svCase <span class="hljs-keyword">none</span><br>highlight! <span class="hljs-keyword">default</span> link svInvPre <span class="hljs-keyword">none</span><br>highlight! <span class="hljs-keyword">default</span> link svInvSystemFunction <span class="hljs-keyword">none</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SV</tag>
      
      <tag>linux</tag>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SV——package</title>
    <link href="/2019/06/12/Verification/SystemVerilog/SV%E2%80%94%E2%80%94package/"/>
    <url>/2019/06/12/Verification/SystemVerilog/SV%E2%80%94%E2%80%94package/</url>
    
    <content type="html"><![CDATA[<h3 id="1-package"><a href="#1-package" class="headerlink" title="1. package"></a>1. package</h3><p>SystemVerilog中package是用来在多个modules、interfaces、programs和checkers之间共享parameter、net、variables、type、task、function、sequence、property和checker declaration这些东西。</p><p>package是最外层的<strong>命名空间</strong>，在package中可以定义parameter、net、variables、type、task、function、sequence、property和checker declaration这些东西。</p><h3 id="2-package-declarations"><a href="#2-package-declarations" class="headerlink" title="2. package declarations"></a>2. package declarations</h3><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">package</span> package_name;<br>    <span class="hljs-comment">// 这些里可以声明一些东西</span><br>    <span class="hljs-comment">// net_declaration</span><br>    <span class="hljs-comment">// data_declaration</span><br>    <span class="hljs-comment">// task_declaration</span><br>    <span class="hljs-comment">// function_declaration</span><br>    <span class="hljs-comment">// checker_declaration</span><br>    <span class="hljs-comment">// dpi_import_export</span><br>    <span class="hljs-comment">// extern_constraint_declaration</span><br>    <span class="hljs-comment">// class_declaration</span><br>    <span class="hljs-comment">// class_constructor_declaration</span><br>    <span class="hljs-comment">// local_parameter_declaration ;</span><br>    <span class="hljs-comment">// parameter_declaration ;</span><br>    <span class="hljs-comment">// covergroup_declaration</span><br>    <span class="hljs-comment">// assertion_item_declaration</span><br><span class="hljs-keyword">endpackage</span><br><br><span class="hljs-comment">// 一个package例子</span><br><span class="hljs-keyword">package</span> ComplexPkg;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-keyword">shortreal</span> i, r;<br>    &#125; Complex;<br>    <span class="hljs-keyword">function</span> Complex add(Complex a, b);<br>        add<span class="hljs-variable">.r</span> = a<span class="hljs-variable">.r</span> + b<span class="hljs-variable">.r</span>;<br>        add<span class="hljs-variable">.i</span> = a<span class="hljs-variable">.i</span> + b<span class="hljs-variable">.i</span>;<br>    <span class="hljs-keyword">endfunction</span><br>    <span class="hljs-keyword">function</span> Complex mul(Complex a, b);<br>        mul<span class="hljs-variable">.r</span> = (a<span class="hljs-variable">.r</span> * b<span class="hljs-variable">.r</span>) - (a<span class="hljs-variable">.i</span> * b<span class="hljs-variable">.i</span>);<br>        mul<span class="hljs-variable">.i</span> = (a<span class="hljs-variable">.r</span> * b<span class="hljs-variable">.i</span>) + (a<span class="hljs-variable">.i</span> * b<span class="hljs-variable">.r</span>);<br>    <span class="hljs-keyword">endfunction</span><br><span class="hljs-keyword">endpackage</span> : ComplexPkg<br></code></pre></td></tr></table></figure><h3 id="3-using-package"><a href="#3-using-package" class="headerlink" title="3. using package"></a>3. using package</h3><p>使用package中的定义，用作用域符号 ::</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// 使用上面定义的结构体Complex和函数mul</span><br>ComplexPkg::Complex cout = ComplexPkg::mul(a, b);<br></code></pre></td></tr></table></figure><p>还可以使用import关键字引入package中定义的对象，在使用这些对象的时候不用加包名和作用域符号了。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">import</span> package_name::package_item;<span class="hljs-comment">//引入包中定义的package_item对象</span><br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">import</span> package_name::*  <span class="hljs-comment">//引入包中定义的所有对象</span><br></code></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">package</span> p;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123; FALSE, TRUE &#125; bool_t;<br><span class="hljs-keyword">endpackage</span><br><span class="hljs-keyword">package</span> q;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123; ORIGINAL, FALSE &#125; teeth_t;<br><span class="hljs-keyword">endpackage</span><br><span class="hljs-keyword">module</span> top1 ;<br>    <span class="hljs-keyword">import</span> p::*;<br>    <span class="hljs-keyword">import</span> q::teeth_t;<br>    teeth_t myteeth;<br>    <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>        myteeth = q:: FALSE; <span class="hljs-comment">// OK:</span><br>        myteeth = FALSE; <span class="hljs-comment">// ERROR: Direct reference to FALSE refers to the</span><br>    <span class="hljs-keyword">end</span> <span class="hljs-comment">// FALSE enumeration literal imported from p</span><br><span class="hljs-keyword">endmodule</span><br><span class="hljs-keyword">module</span> top2 ;<br>    <span class="hljs-keyword">import</span> p::*;<br>    <span class="hljs-keyword">import</span> q::teeth_t, q::ORIGINAL, q::FALSE;<br>    teeth_t myteeth;<br>    <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>   myteeth = FALSE; <span class="hljs-comment">// OK: Direct reference to FALSE refers to the</span><br>    <span class="hljs-keyword">end</span> <span class="hljs-comment">// FALSE enumeration literal imported from q</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>package定义在文件中，需要先将文件名 &#96;include才可以import</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;pkg.sv&quot;</span><br><span class="hljs-keyword">import</span> package_name;<br></code></pre></td></tr></table></figure><h3 id="4-作用域冲突"><a href="#4-作用域冲突" class="headerlink" title="4. 作用域冲突"></a>4. 作用域冲突</h3><p>package还有一些作用域冲突的问题，比如package的作用域是在top层，如果import的package中定义的变量与原来top层的变量名字一样就会发生冲突，具体参见SV手册吧。</p><h3 id="5-package的编译顺序"><a href="#5-package的编译顺序" class="headerlink" title="5. package的编译顺序"></a>5. package的编译顺序</h3><p>如果有多个package之间相互import的情况，那么在VCS编译的时候，被引用的package要写在前面，比如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vcs ... -f filelist<br></code></pre></td></tr></table></figure><p>在filelist中，package文件的顺寻有要求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">filelist</span><br>./packages/pkg1.sv<br>./packages/pkg2.sv<br></code></pre></td></tr></table></figure><p>被引用的写在前面。</p><h3 id="6-使用中的gotcha（”陷阱“）"><a href="#6-使用中的gotcha（”陷阱“）" class="headerlink" title="6. 使用中的gotcha（”陷阱“）"></a>6. 使用中的gotcha（”陷阱“）</h3><ol><li><p><strong>通过import package得到的变量不能被hierarchy access，只能通过作用域符号访问。</strong></p><blockquote><p>  Hierarchical paths are used to access signals where they are declared.  </p></blockquote></li><li><p><strong>对枚举类型import，只是import枚举的名字，没有import枚举标签，不能直接使用枚举的标签。</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs VERILOG"><span class="hljs-keyword">package</span> chip_types;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> <span class="hljs-keyword">logic</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] &#123;RESET, HOLD, LOAD, READY&#125; states_t;<br><span class="hljs-keyword">endpackage</span><br><span class="hljs-keyword">module</span> chip (... );<br><span class="hljs-keyword">import</span> chip_types::states_t; II explicit <span class="hljs-keyword">import</span> of states t <span class="hljs-keyword">type</span><br>states_t state_e, nstate_e;<br><span class="hljs-keyword">always_ff</span> @(<span class="hljs-keyword">posedge</span> clock, <span class="hljs-keyword">negedge</span> reset_n)<br><span class="hljs-keyword">if</span> (!reset_n) state_e &lt;= RESET; II GOTCHA: RESET <span class="hljs-keyword">not</span> imported<br><span class="hljs-keyword">else</span> state_e &lt;= nstate_e;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>可以通过通配符import方式，这样会将枚举的名字和标签都引进来。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">import</span> chip_types::*;<br></code></pre></td></tr></table></figure><p>当然也可以通过分别将标签枚举进来。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">import</span> chip_types::states_t; II explicit <span class="hljs-keyword">import</span> of states t <span class="hljs-keyword">type</span><br><span class="hljs-keyword">import</span> chip_types::RESET; II <span class="hljs-keyword">and</span> its labels<br><span class="hljs-keyword">import</span> chip_types:: HOLD;<br><span class="hljs-keyword">import</span> chip_types::LOAD;<br><span class="hljs-keyword">import</span> chip_types:: READY ;<br></code></pre></td></tr></table></figure></li><li><p><strong>当多个package中的标识符冲突时，import通配符会编译出错。</strong></p><blockquote><p>The gotcha with wildcard package imports occurs when there are identifiers<br>common to more than one package, To avoid this gotcha, explicitly import any<br>duplicate identifiers from the desired package.  <strong>Wildcard imports of other packages will not import identifiers that have been explicitly declared or explicitly imported in the localscope</strong>  </p></blockquote><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">import</span> chip_types::*; II <span class="hljs-keyword">wildcard</span> <span class="hljs-keyword">import</span> of a <span class="hljs-keyword">package</span><br><span class="hljs-keyword">import</span> bus_types::*; II <span class="hljs-keyword">wildcard</span> <span class="hljs-keyword">import</span> of another <span class="hljs-keyword">package</span><br><span class="hljs-keyword">import</span> chip_types::HOLD; II explicit <span class="hljs-keyword">import</span> of HOLD<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Verification</category>
      
      <category>System Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>Verification</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>perl语言——目录操作</title>
    <link href="/2019/06/11/IC/script/perl/perl%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C/"/>
    <url>/2019/06/11/IC/script/perl/perl%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h4 id="1-移动当前目录-chdir"><a href="#1-移动当前目录-chdir" class="headerlink" title="1. 移动当前目录 chdir"></a>1. 移动当前目录 chdir</h4><p>程序会以自己的工作目录作为相对路径的起点，但可以用chdir<strong>操作符</strong>来改变当前目录</p><figure class="highlight perl"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">chdir</span> <span class="hljs-string">&#x27;\etc&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="2-文件名通配符-，glob"><a href="#2-文件名通配符-，glob" class="headerlink" title="2. 文件名通配符*，glob"></a>2. 文件名通配符*，glob</h4><p>类似于shell里的星号*，或者*.v等。在perl程序中可以用glob操作符，他的返回值是一个<strong>列表</strong>。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">@li = <span class="hljs-keyword">glob</span> <span class="hljs-string">&#x27;*&#x27;</span>; <span class="hljs-comment">#匹配到当前目录下的所有文件</span><br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;@li\n&quot;</span>; <span class="hljs-comment">#打印出当前目录下的所有文件</span><br></code></pre></td></tr></table></figure><h4 id="3-删除文件unlink"><a href="#3-删除文件unlink" class="headerlink" title="3. 删除文件unlink"></a>3. 删除文件unlink</h4><p>用unlink操作符可以删除文件，它的输入参数是文件名的<strong>列表</strong>。所以它可以和glob操作符连用</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">unlink</span> <span class="hljs-keyword">glob</span> <span class="hljs-string">&#x27;*.v&#x27;</span>;<span class="hljs-comment">#删除所有的以.v结尾的文件</span><br></code></pre></td></tr></table></figure><h4 id="4-重命名文件rename"><a href="#4-重命名文件rename" class="headerlink" title="4. 重命名文件rename"></a>4. 重命名文件rename</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">rename</span> <span class="hljs-string">&#x27;old&#x27;</span>,<span class="hljs-string">&#x27;new&#x27;</span>;<span class="hljs-comment">#有逗号</span><br></code></pre></td></tr></table></figure><p><strong>这个命令也可以移动文件。</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">rename</span> <span class="hljs-string">&#x27;test/test.txt&#x27;</span> =&gt; <span class="hljs-string">&#x27;mv_test.txt&#x27;</span>;<span class="hljs-comment"># 将文件test中的test.txt移动到当前目录，并改名未mv_test.txt</span><br></code></pre></td></tr></table></figure><h4 id="5-创建和删除目录-mkdir-rmdir"><a href="#5-创建和删除目录-mkdir-rmdir" class="headerlink" title="5. 创建和删除目录 mkdir rmdir"></a>5. 创建和删除目录 mkdir rmdir</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">mkdir</span> <span class="hljs-string">&#x27;fred&#x27;</span>,<span class="hljs-number">0755</span>;<span class="hljs-comment">#创建目录fred，它的权限是0755,也可以不加权限</span><br><span class="hljs-keyword">unlink</span> <span class="hljs-keyword">glob</span> <span class="hljs-string">&#x27;fred/*&#x27;</span>; <span class="hljs-comment">#先将目录中的所有文件移除</span><br><span class="hljs-keyword">rmdir</span> <span class="hljs-string">&#x27;fred&#x27;</span>; <span class="hljs-comment">#rmdir只能移除空目录，先调用unlink</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>script</category>
      
      <category>perl</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>perl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>perl语言——哈希</title>
    <link href="/2019/06/07/IC/script/perl/perl%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C/"/>
    <url>/2019/06/07/IC/script/perl/perl%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C/</url>
    
    <content type="html"><![CDATA[<h4 id="1-什么是哈希-hash"><a href="#1-什么是哈希-hash" class="headerlink" title="1. 什么是哈希 hash"></a>1. 什么是哈希 hash</h4><p>哈希是一种数据结构，可以存储任意长度的值并随意取用。</p><p>在数组中以数字为索引，但是哈希中以名字为索引，索引在哈希中称为<strong>键(key)<strong>，它是</strong>任意唯一的字符串</strong> ，即使是数字也会被转换成字符串。以<strong>键值对</strong>的形式存放数据。</p><p><strong>注意</strong>：</p><ol><li>哈希中的键都是唯一的。</li><li>值可以不是唯一的。</li><li>键以字符串形式保存。</li><li>以<strong>键值对</strong>的形式存放数据。</li><li>值可以是<strong>任何标量</strong>，比如数字，字符串，undef，及它们的组合。如果用数组给哈希中的索引赋值，那么赋的是数组最后一个的值。</li></ol><h4 id="2-哈希的应用"><a href="#2-哈希的应用" class="headerlink" title="2. 哈希的应用"></a>2. 哈希的应用</h4><p>主要应用场景：</p><ol><li>按名字查找信息</li><li>按主机名找IP</li><li>按IP找主机</li><li>统计单词出现次数</li><li>按用户名统计每个人使用的磁盘数量。</li><li>…………</li></ol><h4 id="3-创建哈希对象并使用"><a href="#3-创建哈希对象并使用" class="headerlink" title="3. 创建哈希对象并使用"></a>3. 创建哈希对象并使用</h4><p>整个哈希对象用**百分号%**做前缀。</p><p><strong>哈希元素通过赋值来产生。</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs PERL">$h&#123;<span class="hljs-string">&#x27;dong&#x27;</span>&#125;=<span class="hljs-number">999</span>; <span class="hljs-comment"># 赋值产生哈希键值对，如果第一次创建，那么创建哈希对象h</span><br><span class="hljs-keyword">print</span> $h&#123;<span class="hljs-string">&#x27;dong&#x27;</span>&#125;; <span class="hljs-comment"># 使用哈希对象</span><br><span class="hljs-keyword">print</span><span class="hljs-string">&quot;\n&quot;</span>;<br></code></pre></td></tr></table></figure><p>对哈希中键值对进行索引的时候用的是 **$<strong>前缀，并且是</strong>花括号{}**。</p><p><strong>哈希和列表可以相互转化，可以通过列表对哈希赋值。格式如下程序，其中列表元素个数必须为偶数</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs PERL">%h = (<span class="hljs-string">&#x27;dong&#x27;</span>,<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;wang&#x27;</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&#x27;liu&#x27;</span>,<span class="hljs-number">30</span>); 键 值一次排列<br><span class="hljs-keyword">print</span> $h&#123;<span class="hljs-string">&#x27;dong&#x27;</span>&#125;,<span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment"># 输出10</span><br><span class="hljs-keyword">print</span> $h&#123;<span class="hljs-string">&#x27;wang&#x27;</span>&#125;,<span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment"># 输出20</span><br>@arr = %h;<br><span class="hljs-keyword">foreach</span> (@arr) &#123;<br><span class="hljs-keyword">print</span> $_,<span class="hljs-string">&quot;\t&quot;</span>;  <span class="hljs-comment"># 输出 dong10liu30wang20</span><br>&#125;<span class="hljs-comment"># 这里打印的顺序的随机的，不知道为什么？</span><br></code></pre></td></tr></table></figure><p>两个哈希可以直接赋值。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs PERL"><span class="hljs-keyword">my</span> %H1 = %H2;<br></code></pre></td></tr></table></figure><p><strong>胖箭头创建哈希</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs PERL">%h = (<br>  <span class="hljs-string">&#x27;dong&#x27;</span>  =&gt;  <span class="hljs-number">10</span>,<br>  <span class="hljs-string">&#x27;wang&#x27;</span>  =&gt;  <span class="hljs-number">20</span>,<br>  <span class="hljs-string">&#x27;liu&#x27;</span>   =&gt;  <span class="hljs-number">30</span><br>);<br></code></pre></td></tr></table></figure><p>与之前的方法效果一样，主要是为了好看，并且可以省略<strong>键的引号</strong>。值的引号不能省略。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">%h = (<br>  <span class="hljs-string">dong  =&gt;</span>  <span class="hljs-string">&#x27;LIU&#x27;</span>,<br>  <span class="hljs-string">wang  =&gt;</span>  <span class="hljs-string">&#x27;HU&#x27;</span>,<br>  <span class="hljs-string">liu   =&gt;</span>  <span class="hljs-string">&#x27;SHAN&#x27;</span><br>);<br></code></pre></td></tr></table></figure><h4 id="4-哈希函数"><a href="#4-哈希函数" class="headerlink" title="4. 哈希函数"></a>4. 哈希函数</h4><ol><li><p><strong>reverse</strong></p><p>将哈希的键与值互换，要求哈希的值也是唯一的</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs PERL">%H1 = <span class="hljs-keyword">reverse</span> %H2;<br></code></pre></td></tr></table></figure></li><li><p><strong>keys和values函数</strong></p></li></ol><p> keys返回键列表，values返回值列表。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">%h = (<span class="hljs-string">&#x27;dong&#x27;</span>,<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;wang&#x27;</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&#x27;liu&#x27;</span>,<span class="hljs-number">30</span>); 键 值一次排列<br>@KEYS = <span class="hljs-keyword">keys</span> %h;<br>@VALUES = <span class="hljs-keyword">values</span> %h;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>each遍历哈希中的键值对</strong></li></ol><p> each每次返回一个键值对</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs PERL">%h = (<span class="hljs-string">&#x27;dong&#x27;</span>,<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;wang&#x27;</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&#x27;liu&#x27;</span>,<span class="hljs-number">30</span>); 键 值一次排列<br><span class="hljs-keyword">while</span>(($key,$value)=<span class="hljs-keyword">each</span> %h) &#123;<br>  <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;$key : $value\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>每次调用each，返回下一对键值对列表，如果全都执行到最后，那么返回空列表。在while的条件表达式中是标量环境，列表在标量环境中表示列表中元素个数，此时元素个数为0，那么不满足while循环条件，循环结束。</p><ol start="4"><li>exists查看是否有某个键</li></ol><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">%h = (<span class="hljs-string">&#x27;dong&#x27;</span>,<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;wang&#x27;</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&#x27;liu&#x27;</span>,<span class="hljs-number">30</span>); 键 值一次排列<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">exists</span> $h&#123;<span class="hljs-string">&#x27;dong&#x27;</span>&#125;) &#123;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;having dong \n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>delete删除指定的键及对应值。</li></ol>  <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs PERL">%h = (<span class="hljs-string">&#x27;dong&#x27;</span>,<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;wang&#x27;</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&#x27;liu&#x27;</span>,<span class="hljs-number">30</span>); 键 值一次排列<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">delete</span> $h&#123;<span class="hljs-string">&#x27;dong&#x27;</span>&#125;) &#123;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;delete dong \n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>script</category>
      
      <category>perl</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>perl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>perl语言——字符串</title>
    <link href="/2019/06/07/IC/script/perl/perl%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2019/06/07/IC/script/perl/perl%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h4 id="1-普通字符串操作"><a href="#1-普通字符串操作" class="headerlink" title="1. 普通字符串操作"></a>1. 普通字符串操作</h4><p>点号.连接两个字符串。</p><p>叉号x将字符串复制几次。</p><figure class="highlight perl"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs perl">$s1 = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>$s2 = <span class="hljs-string">&#x27; world&#x27;</span>;<br>$s3 = $s1.$s2;<br>$s4 = <span class="hljs-string">&#x27;a&#x27;</span>x3;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;$s3\n&quot;</span>; <span class="hljs-comment"># hello world</span><br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;$s4\n&quot;</span>; <span class="hljs-comment"># aaa</span><br></code></pre></td></tr></table></figure><h4 id="2-chomp操作符去掉字符串末尾的换行符"><a href="#2-chomp操作符去掉字符串末尾的换行符" class="headerlink" title="2. chomp操作符去掉字符串末尾的换行符"></a>2. chomp操作符去掉字符串末尾的换行符</h4><p>chomp只能对单个变量操作，基本只能对字符串操作，它的作用就是去掉字符串末尾的换行符。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs PERL">$s1 = <span class="hljs-string">&quot;hello\nhow are you\n&quot;</span>;<br>$s2 = <span class="hljs-string">&quot;I am fine\n&quot;</span>;<br><span class="hljs-keyword">print</span> $s1;<br><span class="hljs-keyword">print</span> $s2;<br><span class="hljs-keyword">chomp</span>($s1);<br><span class="hljs-keyword">chomp</span>($s2);<br><span class="hljs-keyword">print</span> $s1;<br><span class="hljs-keyword">print</span> $s2;<br><span class="hljs-comment"># 输出:</span><br>hello   <br>how are you<br>I am fine<br>hello <span class="hljs-comment"># 字符串内部hello后面的换行符不会被去掉</span><br>how are youI am fineliu <span class="hljs-comment"># $s1最后的换行符被去掉</span><br></code></pre></td></tr></table></figure><h4 id="3-split操作符"><a href="#3-split操作符" class="headerlink" title="3. split操作符"></a>3. split操作符</h4><p>split操作符，根据字符将字符串分成多组，返回一个数组保存结果</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">$str = <span class="hljs-string">&quot;hello world&quot;</span>;<br>@res = <span class="hljs-keyword">split</span> <span class="hljs-string">&quot; &quot;</span>,$str; <span class="hljs-comment"># 以空格为界切分$str,数组@res保存结果</span><br><span class="hljs-keyword">print</span> $res[<span class="hljs-number">0</span>],<span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment"># hello</span><br></code></pre></td></tr></table></figure><p> split默认以空白符切分变量$_</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">$_ = <span class="hljs-string">&quot;hello world&quot;</span>;<br>@res = <span class="hljs-keyword">split</span>; <span class="hljs-comment"># 以空格为界切分$_,数组@res保存结果</span><br><span class="hljs-keyword">print</span> $res[<span class="hljs-number">0</span>],<span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment"># hello</span><br></code></pre></td></tr></table></figure><h4 id="4-join函数"><a href="#4-join函数" class="headerlink" title="4. join函数"></a>4. join函数</h4><p> 与split相反的作用，将多个字符串连接起来</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"> $str = <span class="hljs-string">&quot;hello world&quot;</span>;<br>@res = <span class="hljs-keyword">split</span> <span class="hljs-string">&quot; &quot;</span>,$str;<br><span class="hljs-keyword">print</span> $res[<span class="hljs-number">0</span>],<span class="hljs-string">&quot;\n&quot;</span>;<br>$str =  <span class="hljs-keyword">join</span> <span class="hljs-string">&quot;+&quot;</span>,@res;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;$str\n&quot;</span>;  <span class="hljs-comment"># hello+world</span><br></code></pre></td></tr></table></figure><p><strong>join函数连接的列表至少要有两个元素</strong></p><h4 id="5-index——在字符串中查找子字符串"><a href="#5-index——在字符串中查找子字符串" class="headerlink" title="5. index——在字符串中查找子字符串"></a>5. index——在字符串中查找子字符串</h4><p>在字符串中查找子字符串，如果找到则返回子字符串第一次出现的索引位置，找不到返回-1.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs PERL">$str = <span class="hljs-string">&quot;hello hello hello&quot;</span>;<br>$substr = <span class="hljs-string">&#x27;hello&#x27;</span>;<br><span class="hljs-comment"># index(str,substr)</span><br>$ind1 = <span class="hljs-keyword">index</span>($str,$substr); <span class="hljs-comment">#也可以直接用&#x27;hello&#x27;</span><br><span class="hljs-keyword">print</span> $ind1; <span class="hljs-comment"># 输出0，不关心后面的hello</span><br><span class="hljs-comment"># index(str,substr,startindex) #从startindex索引处开始找substr</span><br>$ind2 = <span class="hljs-keyword">index</span>($str,$substr,$ind1+<span class="hljs-number">1</span>);<br><span class="hljs-keyword">print</span> $ind2; <span class="hljs-comment"># 输出6</span><br></code></pre></td></tr></table></figure><h4 id="6-substr-提取子字符串"><a href="#6-substr-提取子字符串" class="headerlink" title="6. substr 提取子字符串"></a>6. substr 提取子字符串</h4><p>返回字符串的一段子字符串。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># substr(str,initial_position,length)</span><br><span class="hljs-keyword">my</span> $substr = <span class="hljs-keyword">substr</span>(<span class="hljs-string">&#x27;this is good day&#x27;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>);<br><span class="hljs-keyword">print</span> $substr; <span class="hljs-comment"># output: this</span><br><span class="hljs-comment"># 如果要输出之后的所有，省略第三个参数即可</span><br><span class="hljs-keyword">my</span> $substr = <span class="hljs-keyword">substr</span>(<span class="hljs-string">&#x27;this is good day&#x27;</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">print</span> $substr; <span class="hljs-comment"># output：this is good day</span><br></code></pre></td></tr></table></figure><p>如果第二个参数initial_position是-1，表示从倒数第一个开始提取，</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $substr = <span class="hljs-keyword">substr</span>(<span class="hljs-string">&#x27;this is good day&#x27;</span>,-<span class="hljs-number">3</span>,<span class="hljs-number">3</span>);<br><span class="hljs-keyword">print</span> $substr; <span class="hljs-comment"># output : day</span><br></code></pre></td></tr></table></figure><h4 id="7-sprintf-格式化返回字符串"><a href="#7-sprintf-格式化返回字符串" class="headerlink" title="7. sprintf 格式化返回字符串"></a>7. sprintf 格式化返回字符串</h4><p>sprintf 格式化返回字符串，用法跟print一样，只是不会打印，而是将字符串返回，可以保存在变量中。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs PERL">$name = <span class="hljs-string">&#x27;dong&#x27;</span>;<br>$age = <span class="hljs-number">24</span>;<br>$info = <span class="hljs-keyword">sprintf</span>(<span class="hljs-string">&quot;name : %s ; age : %d\n&quot;</span>,$name,$age);<br><span class="hljs-keyword">print</span> $info; <span class="hljs-comment">#输出：   name : dong ; age : 24</span><br></code></pre></td></tr></table></figure><h4 id="8、大小写处理函数-lc-转为小写-uc-转为大写-。"><a href="#8、大小写处理函数-lc-转为小写-uc-转为大写-。" class="headerlink" title="8、大小写处理函数 lc(转为小写) uc(转为大写) 。"></a>8、大小写处理函数 lc(转为小写) uc(转为大写) 。</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs PERL">$text=<span class="hljs-string">&quot;zhengwen feng&quot;</span>;<br>$text2=<span class="hljs-keyword">lc</span> $text;<br>$text3=<span class="hljs-keyword">uc</span> $text;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;$text2\n&quot;</span>;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;$text3\n&quot;</span>;<br></code></pre></td></tr></table></figure><h4 id="9、将第一字母变为小写-lcfirst-，将第一个字母大写-ucfirst-。"><a href="#9、将第一字母变为小写-lcfirst-，将第一个字母大写-ucfirst-。" class="headerlink" title="9、将第一字母变为小写(lcfirst)，将第一个字母大写(ucfirst)。"></a>9、将第一字母变为小写(lcfirst)，将第一个字母大写(ucfirst)。</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs PERL">$string=<span class="hljs-string">&quot;zheng&quot;</span>;<br>$string2=<span class="hljs-keyword">lcfirst</span> $string;<br>$string3=<span class="hljs-keyword">ucfirst</span> $string;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;$string2\n&quot;</span>;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;$string3\n&quot;</span>;<br></code></pre></td></tr></table></figure><h4 id="10、字符串中取串长-字符数量-length"><a href="#10、字符串中取串长-字符数量-length" class="headerlink" title="10、字符串中取串长(字符数量)-length"></a>10、字符串中取串长(字符数量)-length</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs PERL">$str=<span class="hljs-string">&quot;abCD99e&quot;</span>;<br>$strlen=<span class="hljs-keyword">length</span>($str);<br></code></pre></td></tr></table></figure><h4 id="11、字符串比较函数-eq、ne、cmp、lt、gt、le、ge，"><a href="#11、字符串比较函数-eq、ne、cmp、lt、gt、le、ge，" class="headerlink" title="11、字符串比较函数 eq、ne、cmp、lt、gt、le、ge，"></a>11、字符串比较函数 eq、ne、cmp、lt、gt、le、ge，</h4><p>使用cmp就好。绝不能用’&#x3D;&#x3D;’,要用eq，正确的做法是：不论整形Perl字符串，都用eq。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs PERL"><span class="hljs-keyword">lt</span>           小于　<br><span class="hljs-keyword">gt</span>         大于　<br>eq         等于　<br>le          小于等于　<br>ge        大于等于　<br><span class="hljs-keyword">ne</span>        不等于　<br>cmp     比较, 返回<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-keyword">or</span>-<span class="hljs-number">1</span><br><br>$s1 = <span class="hljs-string">&#x27;dong&#x27;</span>;<br>$s2 = <span class="hljs-string">&#x27;wang&#x27;</span>;<br><span class="hljs-keyword">if</span>($s1 eq $s2) &#123;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;$s1 and $s2 is equal\n&quot;</span>;<br>&#125;<br><span class="hljs-comment"># 其他的函数用法类似，比较两个字符串</span><br></code></pre></td></tr></table></figure><h4 id="12、双引号字符串中的转义符"><a href="#12、双引号字符串中的转义符" class="headerlink" title="12、双引号字符串中的转义符"></a>12、双引号字符串中的转义符</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs PERL">符号    含义<br>\n    换行<br>\r    回车<br>\t    制表符<br>\f    formfeed<br>\b    退格<br>\a    响铃<br>\e    escape(ASCII中的escape字符)<br>\<span class="hljs-number">007</span>    任何八进制值(这里是，<span class="hljs-number">007</span>=bell(响铃))<br>\x7f    任何十进制值(这里是，<span class="hljs-number">007</span>=bell)<br>\cC    一个控制符(这里是，ctrl+c)<br>\\    反斜线<br>\<span class="hljs-string">&quot;    双引号</span><br><span class="hljs-string">\l    下个字符小写</span><br><span class="hljs-string">\L    接着的字符均为小写直到\E</span><br><span class="hljs-string">\u    下个字符大写</span><br><span class="hljs-string">\U    接着的字符均为大写直到\E   #可以直接将字符串转换成大写形式</span><br><span class="hljs-string">\Q    在non-word字符前加上\，直到\E</span><br><span class="hljs-string">\E    结束\L,\E和\Q</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>script</category>
      
      <category>perl</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>perl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EDA虚拟机使用错误解决</title>
    <link href="/2019/06/05/linux/EDA%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BD%BF%E7%94%A8%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/"/>
    <url>/2019/06/05/linux/EDA%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BD%BF%E7%94%A8%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<p>在Linux中运行yum命令时显示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs kotlin">There was a problem importing one of the Python modules<br><br>required to run yum. The error leading to <span class="hljs-keyword">this</span> problem was:<br>   /usr/lib64/libnssutil3.so: undefined symbol: PL_ClearArenaPool<br>Please install a <span class="hljs-keyword">package</span> which provides <span class="hljs-keyword">this</span> module, or<br>verify that the module <span class="hljs-keyword">is</span> installed correctly.<br>It<span class="hljs-string">&#x27;s possible that the above module doesn&#x27;</span>t match the<br>current version of Python, which <span class="hljs-keyword">is</span>:<br><span class="hljs-number">2.4</span><span class="hljs-number">.3</span> (#<span class="hljs-number">1</span>, Dec <span class="hljs-number">22</span> <span class="hljs-number">2011</span>, <span class="hljs-number">12</span>:<span class="hljs-number">12</span>:<span class="hljs-number">01</span>)<br>[GCC <span class="hljs-number">4.1</span><span class="hljs-number">.2</span> <span class="hljs-number">20080704</span> (Red Hat <span class="hljs-number">4.1</span><span class="hljs-number">.2</span>-<span class="hljs-number">50</span>)]<br>If you cannot solve <span class="hljs-keyword">this</span> problem yourself, please go to<br>the yum faq at:<br>  http:<span class="hljs-comment">//wiki.linux.duke.edu/YumFaq</span><br></code></pre></td></tr></table></figure><p>主要是这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">The</span> error leading to <span class="hljs-variable language_">this</span> problem <span class="hljs-attr">was</span>:<br>   <span class="hljs-regexp">/usr/</span>lib64/libnssutil3.<span class="hljs-property">so</span>: <span class="hljs-literal">undefined</span> <span class="hljs-attr">symbol</span>: PL_ClearArenaPool<br></code></pre></td></tr></table></figure><p>解决方法如下：<a href="https://communities.bmc.com/thread/71275?start=0&tstart=0"><strong>原文</strong></a></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">The problem is not python, it’s the LD_LIBRARY_PATH that does not <span class="hljs-keyword">include</span> <span class="hljs-regexp">/lib64 and /u</span>sr<span class="hljs-regexp">/lib64 setting in the /</span>etc<span class="hljs-regexp">/profiles.d/</span>blreports.sh <span class="hljs-keyword">file</span>.  we fixed <span class="hljs-keyword">this</span> by pre-pending <span class="hljs-regexp">/lib64:/u</span>sr/lib64 to the LD_LIBRARY_PATH<br></code></pre></td></tr></table></figure><p>也就是在LD_LIBRARY_PATH环境变量中加上两个路径&#x2F;lib64和&#x2F;usr&#x2F;lib64，</p><p>方法：</p><ol><li>进入root权限，su</li><li>打开当前用户下的.bashrc文件，gvim ~&#x2F;.bashrc</li><li>添加一行 export LD_LIBRARY_PATH&#x3D;&#x2F;lib64:&#x2F;usr&#x2F;lib64:$LD_LIBRARY_PATH</li><li>source一下文件.bashrc就可以了。</li></ol>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>others</tag>
      
      <tag>linux</tag>
      
      <tag>yum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SystemVerilog仿真</title>
    <link href="/2019/05/28/tools/vcs/SV%E4%BB%BF%E7%9C%9F/"/>
    <url>/2019/05/28/tools/vcs/SV%E4%BB%BF%E7%9C%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="modelSim仿真出错"><a href="#modelSim仿真出错" class="headerlink" title="modelSim仿真出错"></a>modelSim仿真出错</h3><h5 id="1-The-interface-port-‘infu’-must-be-passed-an-actual-interface"><a href="#1-The-interface-port-‘infu’-must-be-passed-an-actual-interface" class="headerlink" title="1. The interface port ‘infu’ must be passed an actual interface."></a>1. The interface port ‘infu’ must be passed an actual interface.</h5><p>在调用接口连接TEST和DUT的时候，compilation通过了，但是simulation的时候出错了，报上面这个错。</p><p>解决：将编译命令改成：</p><figure class="highlight coq"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs coq">vsim -voptargs=<span class="hljs-string">&quot;+acc&quot;</span> <span class="hljs-built_in">top</span> -<span class="hljs-built_in">do</span> <span class="hljs-string">&quot;run -all&quot;</span><br>#其中 <span class="hljs-built_in">top</span>是顶层模块，其中例化了TEST,DUT<br></code></pre></td></tr></table></figure><p><a href="https://verificationacademy.com/forums/systemverilog/sytem-verilog-port-actual-interface-error">参考</a></p><h3 id="SV仿真脚本"><a href="#SV仿真脚本" class="headerlink" title="SV仿真脚本"></a>SV仿真脚本</h3><p><strong>makefile中变量需要加上花括号{}。</strong></p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs TCL">cov_opt = line+tgl+fsm+cond<br><span class="hljs-comment"># vcs编译 urg生成覆盖率报告 dve观察覆盖率</span><br>run: vcs urg dve<br>vcs:<br>vcs -sverilog\<br>+v2k\<br> -f filelist\<br>+notimingcheck\<br>-debug_all\<br>-R \<br>-cm <span class="hljs-variable">$&#123;cov_opt&#125;</span><br><br>sim:<br>./simv -cm <span class="hljs-variable">$&#123;cov_opt&#125;</span><br><span class="hljs-comment"># simv_vdb文件夹下面包含覆盖率的内容，用urg命令将内容生成报告，便于查看。</span><br><span class="hljs-comment"># 报告有两种格式，网页和text，这里-report both是两种都生成。</span><br>urg:<br>urg -dir simv.vdb -report both<br>dve:<br>dve -covdir simv.vdb  //在VCS中观察仿真结果<br>.PHONY:clean<br>clean:<br>rm -rf csrc simv ucli.key simv.daidir<br>rm -rf simv.vdb vc_hdrs.h<br></code></pre></td></tr></table></figure><h3 id="覆盖率仿真"><a href="#覆盖率仿真" class="headerlink" title="覆盖率仿真"></a>覆盖率仿真</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">% </span><span class="language-bash">vcs -cm line+cond+fsm source.v</span><br><span class="hljs-meta prompt_">% </span><span class="language-bash">simv -cm line+cond+fsm</span><br><span class="hljs-meta prompt_">% </span><span class="language-bash">urg -<span class="hljs-built_in">dir</span> simv.vdb   // 生成覆盖率报告</span><br><span class="hljs-meta prompt_">% </span><span class="language-bash">dve -covdir simv.vdb  //在VCS中观察仿真结果</span><br></code></pre></td></tr></table></figure><h3 id="SV仿真脚本2"><a href="#SV仿真脚本2" class="headerlink" title="SV仿真脚本2"></a>SV仿真脚本2</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">############################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Verilog \ SystemVerilog simulation script <span class="hljs-comment">#</span></span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">2019-07-27<span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">############################################</span></span><br><br>files = filelist<br>comp_log = comp.log<br>sim_log = sim.log<br>defines = <br>cov_opt = line+tgl+fsm+cond<br><br>compile_options = -sverilog +v2k  -f filelist\<br>-debug_all\<br>+vcs+vcdpluson -timescale=&quot;1ns/1ps&quot; \<br>+define+$&#123;defines&#125;\<br>-l $&#123;comp_log&#125;<br>runtime_options = \<br>-cm $&#123;cov_opt&#125;\<br>-l $&#123;sim_log&#125;<br><br>compile_option=-sverilog -f filelist<br>run: vcs sim<br><br>vcs:<br>vcs $&#123;compile_options&#125;<br><br><br>sim:<br>./simv $&#123;runtime_options&#125;<br><br>urg:<br>urg -dir simv.vdb -report both<br><br>.PHONY:clean<br>clean:<br>rm -rf csrc simv ucli.key simv.daidir<br>rm -rf simv.vdb vc_hdrs.h<br>rm -rf *.log<br>rm -rf *.vpd<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
      <category>EDA</category>
      
      <category>vcs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>SV</tag>
      
      <tag>vcs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合逻辑和时序逻辑的综合</title>
    <link href="/2019/05/27/IC/Synthesis/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E5%92%8C%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%9A%84%E7%BB%BC%E5%90%88/"/>
    <url>/2019/05/27/IC/Synthesis/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E5%92%8C%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%9A%84%E7%BB%BC%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h3 id="综合工具工作的步骤："><a href="#综合工具工作的步骤：" class="headerlink" title="综合工具工作的步骤："></a>综合工具工作的步骤：</h3><ol><li>检测并消除冗余逻辑</li><li>查找组合反馈回路</li><li>利用无关紧要条件</li><li>检测出未使用的状态</li><li>查找并消除等价的状态；</li><li>进行状态分配；</li><li>在满足物理工艺的面积、速度限制的条件下，综合出最优的多级逻辑实现。既包括了最优化技术，又包括了工艺映射。</li></ol><h3 id="1-综合简介"><a href="#1-综合简介" class="headerlink" title="1. 综合简介"></a>1. 综合简介</h3><p>电路模型可以分成三个层次：**架构级(architectural level model)<strong>、</strong>逻辑级(logic level model)<strong>、</strong>物理级(physical level model)**。</p><p><strong>架构级</strong>：必须由电路执行的、将一组输入转换成输出的操作，不与时钟相关联。架构的内部组成可以由不同结构的、互连的、同步的功能单元来实现（我认为是功能单元或模块的互联）。这里的设计关键是从架构描述中提取出一个实现所需功能的算法。</p><p><strong>逻辑级</strong>：由电路实现的一组变量和一组布尔函数。它描述了寄存器资源和功能单元的架构、逻辑级的时序行为。这里的设计是将布尔逻辑转换成可满足功能的组合门电路和存储寄存器的最优化的网表。<strong>综合工具就是用来实现这一步的。综合工具先将Verilog代码翻译成布尔函数形式，然后进行优化、映射。</strong></p><p><strong>物理级</strong>：先不考虑。</p><p>从电路的高级别抽象模型到最终的物理实现。HDL可以对电路进行不同层次的描述来简化设计过程。</p><p>有三种描述层次：行为描述(behavioral)、结构描述(structral)、物理描述(physical)。</p><p>比如：一个架构模型的行为描述可以是定义一组数据变换的算法；同一个架构模型的结构描述是由实现这组算法的数据通路（寄存器、存储器、加法器等）和控制器组成（功能模块的组合）。一个逻辑级的行为描述包括状态转移图(STG)、算法状态机图(ASM)等；其结构描述是实现行为级所描述功能的门级网表。</p><p><strong>其实这里不是很明白。直接从书上摘下来的。</strong></p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/syn1.png"></p><h4 id="2-1-逻辑综合"><a href="#2-1-逻辑综合" class="headerlink" title="2.1  逻辑综合"></a>2.1  逻辑综合</h4><p>逻辑综合是将电路从逻辑级描述转换成结构描述，最终生成结构化的原语网表。</p><p>逻辑级描述是一组布尔方程。这些方程由连续赋值语句或等效的电平敏感的行为构成。</p><p>逻辑综合：</p><p>  给定的原语网表 &gt;&gt; 优化的Verilog原语网表 &gt;&gt; 由目标工艺资源(asic单元)组成的等效电路。</p><p>综合工具的组成结构如下图：</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/syn2.png"></p><p><strong>综合要保证综合前后电路的等效性以及生成电路的可测性。</strong></p><p><strong>逻辑综合是进行逻辑优化，之后要进行性能优化，寻找在物理工艺上最优性能的电路。（比如功耗、面试、时序等)</strong></p><h3 id="2-组合逻辑的综合"><a href="#2-组合逻辑的综合" class="headerlink" title="2 组合逻辑的综合"></a>2 组合逻辑的综合</h3><p>可综合的组合逻辑有：</p><ol><li>结构化的原语网表</li><li>一系列连续赋值语句</li></ol><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> y = a &amp; b;<br></code></pre></td></tr></table></figure><ol start="3"><li>电平敏感的周期性行为（<strong>无反馈、无锁存器</strong>）</li></ol><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span>@(a <span class="hljs-keyword">or</span> b ) <span class="hljs-keyword">begin</span>  <span class="hljs-comment">//对于每个输入值都有对应的输出、</span><br>.....     <span class="hljs-comment">//逻辑中没有反馈回路、不生成锁存器</span><br>     <span class="hljs-comment">// case \if语句要写全</span><br>    <span class="hljs-comment">// 不能有时间控制语句 @ # 等</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>能够去除电路中的冗余逻辑。</p><h4 id="2-1-优先级结构的综合"><a href="#2-1-优先级结构的综合" class="headerlink" title="2.1 优先级结构的综合"></a>2.1 优先级结构的综合</h4><p>对于case和if语句，综合工具可能综合出有优先级的电路，也可能是没有优先级的电路，这要看HDL如何写的。</p><p>如果case语句中的*<em>分支选项都是互斥</em>***的，那么综合出 的电路没有优先级，会是个多路选择器结构。如果不是互斥的，那么case语句通常是对于首先匹配到的选项有高 的优先级，当然一般用的时候都是互斥结构。</p><p>如果if语句中的*<em>分支选项是互斥</em>***的，那么也不会出现优先级结构，而是多路选择器</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">/*</span><br><span class="hljs-comment">以下是一个会综合出优先级顺序的块。</span><br><span class="hljs-comment">因为sel_a与sel_b之间没有关系，if的分支选项不是互斥的。</span><br><span class="hljs-comment">比如，如果是没有优先级，当sel_a ==1 ，则y=a。此时sel_b也可能为1，那么y=b。没有优先级的话，</span><br><span class="hljs-comment">就不知道到底是匹配了哪一条分支。</span><br><span class="hljs-comment">所以要综合出优先级结构，且第一个条件分支的优先级最高。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">always</span>@(sel_a <span class="hljs-keyword">or</span> sel_b) <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">if</span>(sel_a ==<span class="hljs-number">1</span> ) y = a;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sel_b == <span class="hljs-number">1</span>) y = b;<br><span class="hljs-keyword">else</span> y = c;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="2-2-ASIC资源共享"><a href="#2-2-ASIC资源共享" class="headerlink" title="2.2 ASIC资源共享"></a>2.2 ASIC资源共享</h4><p>这跟编码风格有关。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// 一种 ， 两个加法器</span><br><span class="hljs-keyword">assign</span> sum = sel ? (a+b) : (a+c);<br><span class="hljs-comment">// 另一中 ， 一个加法器</span><br><span class="hljs-keyword">assign</span> sum = a + (sel ? b : c) ;<br></code></pre></td></tr></table></figure><p><strong>用括号来控制操作符分组来降低电路尺寸</strong></p><p>比如下面的Verilog描述的加法器综合成ASIC库中的全加器，如下图中(a)所示，(b)图是为了提高速度而得到的另一种综合结果。(a)中的电路面积小于(b)。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> add_4(<span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] sum,<span class="hljs-keyword">output</span> C,<span class="hljs-keyword">input</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]a,b,c);<br><span class="hljs-keyword">assign</span> &#123;sum,C&#125;=a+b+c;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/syn3.png"></p><h3 id="3-带锁存器的时序逻辑综合"><a href="#3-带锁存器的时序逻辑综合" class="headerlink" title="3  带锁存器的时序逻辑综合"></a>3  带锁存器的时序逻辑综合</h3><p><strong>无反馈的原语网表、连续赋值综合出无锁存器的组合逻辑。</strong></p><p><strong>带反馈的条件操作符综合出锁存器</strong>，如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> Out = (cs==<span class="hljs-number">0</span>)?(we==<span class="hljs-number">0</span>)?:In:Out:<span class="hljs-number">1&#x27;bz</span>;<br><span class="hljs-comment">//如果cs==0，we==1，那么Out = Out，Out会被锁存。</span><br></code></pre></td></tr></table></figure><h4 id="3-1-无意综合出锁存器"><a href="#3-1-无意综合出锁存器" class="headerlink" title="3.1 无意综合出锁存器"></a>3.1 无意综合出锁存器</h4><p>综合出锁存器的情况：</p><ol><li>电平敏感的always的敏感列表不全；</li><li>if,case的分支条件不全；</li><li>带反馈的连续赋值语句。</li></ol><h3 id="4-三态总线接口的综合"><a href="#4-三态总线接口的综合" class="headerlink" title="4 三态总线接口的综合"></a>4 三态总线接口的综合</h3><p>三态输出端口</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/syn4.png"></p><p>双向总线端口</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/syn5.png"></p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/syn6.png"></p><h3 id="5-带有触发器的时序逻辑综合"><a href="#5-带有触发器的时序逻辑综合" class="headerlink" title="5  带有触发器的时序逻辑综合"></a>5  带有触发器的时序逻辑综合</h3><p>记着在阿里的实习面试的时候被问到，RTL中的reg变量都能综合处寄存器吗，在边沿触发的always中的reg变量都能被综合成寄存器吗？当时说reg只是Verilog语法，用来块语句中。至于沿触发的always中的reg变量可能会被综合工具优化掉。那个人说了句嗯，好像是表示同意。不过最后还是没有offer。</p><p><strong>这一节的内容就能很好回答面试官的问题了</strong></p><p><strong>触发器仅由边沿敏感的always块综合而成，但并不是在边沿敏感的行为中的寄存器变量都被综合成触发器。</strong></p><p>综合出触发器的情况——<strong>变量对存储有需求</strong>：</p><ol><li><strong>该寄存器变量在行为描述范围以外被使用 （后面有例子）</strong></li><li><strong>该寄存器变量在未被赋值以前就在行为描述中用到 （后面有例子）</strong></li><li><strong>寄存器变量仅在行为的某些分支（if分支等）上被赋值。 （后面的例子好像不大实用）</strong></li></ol><p>在边沿敏感的行为语句中，如果if语句分支不完全，会综合出一个控制时钟使能的信号。这样即使在时钟变化时，寄存器变量也不会改变，除非满足分支条件，也就是时钟使能了。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk)<br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">if</span>(enable) data_out &lt;= data_in;<br>    <span class="hljs-comment">// enable 信号控制时钟使能，enable有效，data_out改变，否则data_out被存储起来。</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><ul><li><strong>寄存器变量在边沿触发的行为块之外被使用，那么综合工具会综合出触发器。如果没被使用，那么综合工具会忽略，不会综合出触发器</strong></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> test(    <span class="hljs-keyword">input</span> clk,    <span class="hljs-keyword">input</span> a,    <span class="hljs-keyword">output</span> b    );<br>    <span class="hljs-keyword">reg</span> b_r;<br>    <span class="hljs-keyword">reg</span> e_r;<br>    <span class="hljs-keyword">assign</span> b = b_r;<br>    <span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>        b_r &lt;= a;<br>        e_r &lt;= a;  <br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>寄存器变量b_r在always块之外用到了，给到了输出端。e_r没有被用到，所以vivado综合忽略了e_r寄存器变量，只为b_r生成一个触发器。如下图：</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/syn9.png"></p><ul><li><p><strong>寄存器变量在未被赋值以前就在边沿触发的块中被用到，会生成触发器</strong></p><p><strong>b_r寄存器变量在快语句之外没有被使用</strong></p></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> test(    <span class="hljs-keyword">input</span> clk,    <span class="hljs-keyword">input</span> a,    <span class="hljs-keyword">output</span> b    );<br>    <span class="hljs-keyword">reg</span> b_r;<br>    <span class="hljs-keyword">reg</span> e_r;<br>    <span class="hljs-keyword">assign</span> b = b_r;<br>    <span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>        b_r &lt;= e_r;  <span class="hljs-comment">//e_r在被赋值以前在always块中被用到</span><br>        e_r &lt;= a;  <br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/syn10.png"></p><p>如果e_r先被赋值，然后被使用，也会综合出触发器。网表与上面一样。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> test(    <span class="hljs-keyword">input</span> clk,    <span class="hljs-keyword">input</span> a,    <span class="hljs-keyword">output</span> b    );<br>    <span class="hljs-keyword">reg</span> b_r;<br>    <span class="hljs-keyword">reg</span> e_r;<br>    <span class="hljs-keyword">assign</span> b = b_r;<br>    <span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>        e_r &lt;= a; <br>        b_r &lt;= e_r;  <span class="hljs-comment">//e_r先赋值再使用      </span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>但如果不给e_r赋值，则不会出现触发器</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> test(    <span class="hljs-keyword">input</span> clk,    <span class="hljs-keyword">input</span> a,    <span class="hljs-keyword">output</span> b    );<br>    <span class="hljs-keyword">reg</span> b_r;<br>    <span class="hljs-keyword">reg</span> e_r;<br>    <span class="hljs-keyword">assign</span> b = b_r;<br>    <span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>  <br>        b_r &lt;= e_r;  <span class="hljs-comment">//不给e_r赋值     </span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/syn12.png"></p><p><strong>所以应该改成寄存器变量被赋值，也被使用，那么就生成触发器，若只满足其一，不行。</strong></p><ul><li><strong>寄存器变量仅在行为描述的某些分支上出现，但在行为之外没有被使用，不能综合处触发器。</strong></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> test(    <span class="hljs-keyword">input</span> clk,    <span class="hljs-keyword">input</span> a,    <span class="hljs-keyword">input</span> sel,    <span class="hljs-keyword">output</span> b    );<br>    <span class="hljs-keyword">reg</span> b_r;<br>    <span class="hljs-keyword">reg</span> e_r;<br>    <span class="hljs-keyword">reg</span> f_r;<br>    <span class="hljs-keyword">assign</span> b = b_r;<br>    <span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>        b_r &lt;= a;<br>        <span class="hljs-keyword">if</span>(sel) <span class="hljs-keyword">begin</span> e_r &lt;= a;f_r &lt;= a;<span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span> f_r &lt;= ~a;   <span class="hljs-comment">//e_r只出现在if的一条分支上        </span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br><span class="hljs-comment">// 两个电路的综合结果一样</span><br><span class="hljs-keyword">module</span> test(    <span class="hljs-keyword">input</span> clk,    <span class="hljs-keyword">input</span> a,    <span class="hljs-keyword">input</span> sel,    <span class="hljs-keyword">output</span> b    );<br>    <span class="hljs-keyword">reg</span> b_r;<br>    <span class="hljs-keyword">reg</span> e_r;   <br>    <span class="hljs-keyword">assign</span> b = b_r;<br>    <span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>        b_r &lt;= a;<br>        <span class="hljs-keyword">if</span>(sel) <span class="hljs-keyword">begin</span> e_r &lt;= a;<span class="hljs-keyword">end</span><br>          <span class="hljs-comment">//e_r只出现在if的一条分支上       </span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>无论是e_r只出现在if的部分分支，还是f_r出现在if的所有分支，都不能综合出触发器。</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/syn11.png"></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>Synthesis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>Synthesis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>perl语言——列表、数组</title>
    <link href="/2019/05/25/IC/script/perl/perl%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E5%88%97%E8%A1%A8%E3%80%81%E6%95%B0%E7%BB%84/"/>
    <url>/2019/05/25/IC/script/perl/perl%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E5%88%97%E8%A1%A8%E3%80%81%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="1-数组-列表"><a href="#1-数组-列表" class="headerlink" title="1.数组\列表"></a>1.数组\列表</h2><p>如果perl语言中的标量是单数(singular)，那么复数(plural)用列表或数组表示。</p><h4 id="1-1-数组和列表"><a href="#1-1-数组和列表" class="headerlink" title="1.1 数组和列表"></a>1.1 数组和列表</h4><p>perl中，列表表示一组标量的有序集合。数组是用来保存列表的变量。但这两个术语常常混用。</p><h4 id="1-2-数组变量-array、数组索引-array-i"><a href="#1-2-数组变量-array、数组索引-array-i" class="headerlink" title="1.2 数组变量@array、数组索引$array[i]"></a>1.2 数组变量@array、数组索引$array[i]</h4><p>数组变量：用 <strong>@变量名</strong>来表示数组整体，比如 @array。</p><p>数组索引：用**$变量名[index]**来索引数组内元素，比如$array[0] &#x3D; 1;.</p><p><strong>注意这里用的是中括号【】</strong></p><p><strong>数组的命名空间和标量的命名空间完全分开</strong>，所以数组@array和变量$array的是不同对象，在程序中同时定义这两个对象是合理的。</p><figure class="highlight perl"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs perl">$array[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  <span class="hljs-comment">#数组@array</span><br>$array[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>$array = <span class="hljs-number">10</span>;    <span class="hljs-comment">#标量$array</span><br></code></pre></td></tr></table></figure><p><strong>数组的长度理论上来说无限的</strong>，比如 $array[10000] &#x3D; 0;这样数组array的长度就是10001个。</p><h4 id="1-3-特殊的数组索引值-数组名-负索引"><a href="#1-3-特殊的数组索引值-数组名-负索引" class="headerlink" title="1.3  特殊的数组索引值 $#数组名\负索引"></a>1.3  特殊的数组索引值 $#数组名\负索引</h4><p><strong>$#数组名</strong>   表示数组最后一个元素的索引，它比数组个数小1，因为索引从0开始。</p><p><strong>$#数组名+1</strong> 表示数组大小。</p><p>负索引：比如-1表示最后一个，-2倒数第二个…………</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">$rocks[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>$rocks[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>$rocks[<span class="hljs-number">100</span>] = <span class="hljs-number">100</span>;    <span class="hljs-comment"># 这样数组一共有了101元素，中间的 那些是undef元素</span><br><span class="hljs-keyword">print</span> $rock[$#rock];  <span class="hljs-comment"># 输出数组最后一个值</span><br><span class="hljs-keyword">print</span> $rock[-<span class="hljs-number">1</span>];       <span class="hljs-comment">#输出数组最后一个值</span><br></code></pre></td></tr></table></figure><h4 id="1-4-数组赋值qw-x2F-x2F-，列表直接量"><a href="#1-4-数组赋值qw-x2F-x2F-，列表直接量" class="headerlink" title="1.4 数组赋值qw&#x2F;&#x2F;，列表直接量"></a>1.4 数组赋值qw&#x2F;&#x2F;，列表直接量</h4><p>除了上面的对数组的单个元素赋值，还可以用以下的方法</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">@array1 = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&quot;string&quot;</span>);<br>@array2 = <span class="hljs-keyword">qw</span>/<span class="hljs-number">1</span> <span class="hljs-number">2</span> a b string/;<br></code></pre></td></tr></table></figure><p>用括号（）标出来、中间用都好隔开的叫列表直接量，里面数字、字符可以混合</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,)   <span class="hljs-comment">#与上一行相同，末尾的逗号被忽略</span><br>(<span class="hljs-number">1</span>..<span class="hljs-number">5</span>)    <span class="hljs-comment"># 表示(1,2,3,4,5)</span><br>(<span class="hljs-number">1.5</span>..<span class="hljs-number">5.5</span>) <span class="hljs-comment">#也表示(1,2,3,4,5)，其中小数部分被忽略</span><br>(<span class="hljs-number">0</span>..$#array) <span class="hljs-comment">#表示数组的所有索引值</span><br></code></pre></td></tr></table></figure><p><strong>qw&#x2F;&#x2F;<strong>是用来建立单词列表的。其中的斜杠是</strong>定界符</strong>，可以换成!!  ##  () {} [] 这些都可以</p><h4 id="1-5-列表给变量赋值"><a href="#1-5-列表给变量赋值" class="headerlink" title="1.5 列表给变量赋值"></a>1.5 列表给变量赋值</h4><p>列表给变量赋值的时候按照顺序对应。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">($var1,$var2,$var3) = (<span class="hljs-string">&quot;wang&quot;</span>,<span class="hljs-string">&quot;huang&quot;</span>,<span class="hljs-string">&quot;liu&quot;</span>);<br>($var1,$var2,$var3) = (<span class="hljs-string">&quot;wang&quot;</span>,<span class="hljs-string">&quot;huang&quot;</span>);  <span class="hljs-comment">#$var3 是undef</span><br>($var1,$var2) = (<span class="hljs-string">&quot;wang&quot;</span>,<span class="hljs-string">&quot;huang&quot;</span>,<span class="hljs-string">&quot;liu&quot;</span>); <span class="hljs-comment"># 忽略列表多余的元素”liu&quot;</span><br>($array[<span class="hljs-number">0</span>],$array[<span class="hljs-number">1</span>]) = ($array[<span class="hljs-number">1</span>],$array[<span class="hljs-number">0</span>]);<span class="hljs-comment">#交换列表元素</span><br></code></pre></td></tr></table></figure><h4 id="1-6-push-pop-在数组尾添加、删除元素"><a href="#1-6-push-pop-在数组尾添加、删除元素" class="headerlink" title="1.6 push\pop 在数组尾添加、删除元素"></a>1.6 push\pop 在数组尾添加、删除元素</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl">@arr = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>$fred1 = <span class="hljs-keyword">pop</span>(@arr); <span class="hljs-comment">#$fred1为3</span><br>$fred2 = <span class="hljs-keyword">pop</span> @arr;  <span class="hljs-comment">#$fred2为2</span><br>@array = ();<br><span class="hljs-keyword">push</span> (@array,<span class="hljs-number">1</span>);<span class="hljs-comment">#  @array为（1）</span><br><span class="hljs-keyword">push</span> @array,<span class="hljs-number">2</span>..<span class="hljs-number">5</span>;<span class="hljs-comment">#(1,2,3,4,5)</span><br>@others = <span class="hljs-number">6</span>..<span class="hljs-number">10</span>;<br><span class="hljs-keyword">push</span> @array,@other;<span class="hljs-comment">#(1,2,3...10)</span><br></code></pre></td></tr></table></figure><h4 id="1-6-shift-unshift-从开头移除、添加元素"><a href="#1-6-shift-unshift-从开头移除、添加元素" class="headerlink" title="1.6 shift\unshift 从开头移除、添加元素"></a>1.6 shift\unshift 从开头移除、添加元素</h4><p>语法与上面相同</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">@arr = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br><span class="hljs-keyword">shift</span> @arr;<br><span class="hljs-keyword">unshift</span> @arr,<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h4 id="1-7-splice-从数组中间移除某些元素"><a href="#1-7-splice-从数组中间移除某些元素" class="headerlink" title="1.7  splice 从数组中间移除某些元素"></a>1.7  splice 从数组中间移除某些元素</h4><p>前面的都是从开头或结尾操作，splice可以从中间操作数组。</p><p>splice最多有四个元素，至少有前两个</p><ol><li><p>数组对象</p><ol start="2"><li>开始的索引位置。如果只有这两个，那么splice将索引及其以后的元素移除，</li><li>长度，移除多少个元素 </li><li>替换的列表。移除了一些元素，可以再补上一些</li></ol></li></ol><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">@arr = <span class="hljs-number">1</span>..<span class="hljs-number">10</span>;<br><span class="hljs-keyword">splice</span> @arr,<span class="hljs-number">5</span>;  <span class="hljs-comment">#@arr为(1,2,3,4,5)</span><br><span class="hljs-keyword">splice</span> @arr,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>; <span class="hljs-comment"># @arr为(1,2)</span><br>@other = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">splice</span> @arr,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,@other; <span class="hljs-comment"># @arr为(1,1,1),不上@other的元素</span><br></code></pre></td></tr></table></figure><h4 id="1-8-reverse-sort"><a href="#1-8-reverse-sort" class="headerlink" title="1.8  reverse\sort"></a>1.8  reverse\sort</h4><p>reverse以反序返回数组</p><p>sort 返回以字符编码顺序排序的结果，不会改变数组。</p><h4 id="1-9-foreach-、默认-变量"><a href="#1-9-foreach-、默认-变量" class="headerlink" title="1.9 foreach 、默认$_变量"></a>1.9 foreach 、默认$_变量</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl">@arr = (<span class="hljs-number">1</span>..<span class="hljs-number">10</span>);<br><span class="hljs-keyword">foreach</span> $ele (@arr) &#123;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;$ele\n&quot;</span>;<br>&#125;<br><span class="hljs-keyword">foreach</span> (@arr) &#123;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;$_\n&quot;</span>;  <span class="hljs-comment">#默认存到$_中</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-10-标量上下文和列表上下文"><a href="#1-10-标量上下文和列表上下文" class="headerlink" title="1.10 标量上下文和列表上下文"></a>1.10 标量上下文和列表上下文</h4><p><strong>同一个表达式出现再不同上下文中意义不同，比如数组@array，有时表示数组所存的列表，有时表示数组中元素个数。</strong></p><p><strong>一个表达式、变量或数组到底表示什么意思，其决定性因素的是操作符。</strong>，比如：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-number">42</span> + something <span class="hljs-comment"># 这里的something必须是标量</span><br><span class="hljs-keyword">sort</span> somethings <span class="hljs-comment">#something必须是列表</span><br>@people = <span class="hljs-keyword">qw</span>/dong wang sun/;<br>$nu = @people; <span class="hljs-comment">#@people返回3，元素个数</span><br>@arr = @people; <span class="hljs-comment"># @people表示列表</span><br><br>$fred = something; <span class="hljs-comment">#标量上下文</span><br>($var,$var) = something; <span class="hljs-comment">#列表上下文</span><br>($var) = something; <span class="hljs-comment">#列表上下文</span><br></code></pre></td></tr></table></figure><p><strong>强制指定标量上下文，用scalar伪函数</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">@arr = <span class="hljs-keyword">qw</span>/<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>/;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&#x27;@arr&#x27;</span>,<span class="hljs-string">&quot;have &quot;</span>,<span class="hljs-keyword">scalar</span> @arr,<span class="hljs-string">&quot; elements\n&quot;</span>;<br><span class="hljs-comment"># 输出 @arr have 3 elements</span><br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>script</category>
      
      <category>perl</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>perl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>子程序sub</title>
    <link href="/2019/05/25/IC/script/perl/perl%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E5%AD%90%E7%A8%8B%E5%BA%8F/"/>
    <url>/2019/05/25/IC/script/perl/perl%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E5%AD%90%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h4 id="1-定义子程序"><a href="#1-定义子程序" class="headerlink" title="1. 定义子程序"></a>1. 定义子程序</h4><p>子程序由<strong>sub</strong>关键字定义<strong>花括号</strong>表示函数体范围。</p><p><strong>子程序不需要事先声明。</strong></p><p><strong>如果定义了两个相同名字的子程序，后面的会覆盖前面的。</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">marine</span> </span>&#123;  <span class="hljs-comment"># marine是子程序名</span><br>  <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;this is a test\n&quot;</span>;<br>&#125;<br>&amp;marine；<span class="hljs-comment">#子程调用，&amp;marine写在程序定义之前也可以运行。</span><br><span class="hljs-comment"># 也可以直接用marine调用，这样必须写在程序定义之后</span><br></code></pre></td></tr></table></figure><h4 id="2-子程序调用-amp"><a href="#2-子程序调用-amp" class="headerlink" title="2. 子程序调用 &amp;"></a>2. 子程序调用 &amp;</h4><p>用<strong>”&amp;函数名（参数列表）；“</strong>来调用子程序，如果不需要传入参数，就不加，<strong>”&amp;函数名；“</strong></p><p>&amp;符号可以省略：</p><ol><li>子程序在使用之前定义好了</li><li>调用子程序时，参数列表放在括号里。</li></ol><p>&amp;不可省略：<strong>子程序名字和perl默认函数名字相同时绝对不可以省略</strong></p><h4 id="3-返回值"><a href="#3-返回值" class="headerlink" title="3. 返回值"></a>3. 返回值</h4><p>perl中所有的子程序都有返回值，所以perl默认以最后一次运算的结果作为返回值。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">sum_of_fred_barney</span> </span>&#123;  <span class="hljs-comment">#函数求变量$fred,$barney的和</span><br>  <span class="hljs-keyword">print</span> (<span class="hljs-string">&quot;sum is &quot;</span>,($fred+$barney),<span class="hljs-string">&quot;\n&quot;</span>);<span class="hljs-comment"># 这里的$fred,$barney是全局变量</span><br>  $fred+$barney;  <span class="hljs-comment"># 最后一个表达式的结果作为返回值</span><br>&#125;<br>$fred = <span class="hljs-number">1</span>;<br>$barney = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">print</span> &amp;sum_of_fred_barney,<span class="hljs-string">&quot;\n&quot;</span>;<br>输出：<br>sum is <span class="hljs-number">2</span><br><span class="hljs-number">2</span><br><span class="hljs-comment">### 另一种情况</span><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">sum_of_fred_barney</span> </span>&#123;  <span class="hljs-comment">#函数求变量$fred,$barney的和</span><br>  <span class="hljs-keyword">print</span> (<span class="hljs-string">&quot;sum is &quot;</span>,($fred+$barney),<span class="hljs-string">&quot;\n&quot;</span>);<span class="hljs-comment"># 这里的$fred,$barney是全局变量</span><br>  <span class="hljs-comment">#$fred+$barney;  # 将这一行注释掉</span><br>&#125;<br>$fred = <span class="hljs-number">1</span>;<br>$barney = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">print</span> &amp;sum_of_fred_barney,<span class="hljs-string">&quot;\n&quot;</span>;<br>输出：<br>sum is <span class="hljs-number">2</span><br><span class="hljs-number">1</span>   <span class="hljs-comment"># 最后一条语句是print函数，这里函数返回1，表示成功执行函数</span><br></code></pre></td></tr></table></figure><p><strong>最后一次运算结果，而不是最后一行表达式</strong>，如下面这个例子</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs perl">$fred = <span class="hljs-number">2</span>;<br>$barney = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">sel</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> ($fred &gt; $barney) &#123;<br>    $val = <span class="hljs-number">1</span>;  <span class="hljs-comment"># 这条语句是最后执行的。</span><br>  &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>    $val = <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br>&amp;sel;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&#x27;$val&#x27;</span>,<span class="hljs-string">&quot; is $val\n&quot;</span>;<br></code></pre></td></tr></table></figure><h5 id="return返回"><a href="#return返回" class="headerlink" title="return返回"></a>return返回</h5><p>如果子程序执行到一半需要返回，用return；</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">find4</span></span>&#123; <span class="hljs-comment">#从列表中找到大于4的第一个值，找到后立马返回这个值，找不到返回-1</span><br> <span class="hljs-keyword">foreach</span>(@_) &#123;<br>  <span class="hljs-keyword">if</span> ($_ &gt; <span class="hljs-number">4</span>) &#123;<span class="hljs-keyword">return</span> $_;&#125;<br> &#125;<br> -<span class="hljs-number">1</span>;<br>&#125;<br>@f4 = <span class="hljs-keyword">qw</span>/<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span>/;<br><span class="hljs-keyword">print</span> &amp;find4(@f4);<br></code></pre></td></tr></table></figure><h4 id="4-参数"><a href="#4-参数" class="headerlink" title="4. 参数"></a>4. 参数</h4><p>perl自动将参数化列表保存在数组**@_**中，在子程序定义的时候不需要写参数表。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">max</span> </span>&#123; <span class="hljs-comment"># 返回两个数的最大值</span><br> <span class="hljs-keyword">if</span>($_[<span class="hljs-number">0</span>] &gt; $_[<span class="hljs-number">1</span>]) &#123; $_[<span class="hljs-number">0</span>] ;&#125; <span class="hljs-comment">#$_[0]是子程序调用时第一个参数，$_[1]是第二个参数。</span><br> <span class="hljs-keyword">else</span> &#123; $_[<span class="hljs-number">1</span>] ;&#125;<br>&#125;<br>$fred = <span class="hljs-number">2</span>;<br>$barney = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;the max of &quot;</span>,<span class="hljs-string">&#x27;$fred&#x27;</span>,<span class="hljs-string">&quot; and &quot;</span>,<span class="hljs-string">&#x27;$barney&#x27;</span>,<span class="hljs-string">&quot; is &quot;</span>,&amp;max($fred,$barney),<span class="hljs-string">&quot;\n&quot;</span>; <br></code></pre></td></tr></table></figure><p>子程序调用的时候有多余的参数，会被忽略，反正程序中也用不到。</p><p>也可以根据 <strong>标量上下文中的列表</strong>这个概念来判断传入的参数个数对不对，如果多了就输出一段警告。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">max</span> </span>&#123;<br><span class="hljs-keyword">if</span>(@_ != <span class="hljs-number">2</span>)<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;WARNING!\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>也可以传入任意长度的参数，只要是功能需要</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">max</span></span>&#123;  <span class="hljs-comment"># 求一个列表中的最大值</span><br> $max_of_list = <span class="hljs-keyword">shift</span> @_;<br> <span class="hljs-keyword">foreach</span> (@_) &#123;<br>  <span class="hljs-keyword">if</span>($max_of_list &lt; $_) &#123;<br>  $max_of_list = $_;<br>  &#125;<br> &#125;<br> $max_of_list;<br>&#125;<br>@list = <span class="hljs-keyword">qw</span>/<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>/; <br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;the max of &quot;</span>,<span class="hljs-string">&#x27;$fred&#x27;</span>,<span class="hljs-string">&quot; and &quot;</span>,<span class="hljs-string">&#x27;$barney&#x27;</span>,<span class="hljs-string">&quot; is &quot;</span>,&amp;max(@list),<span class="hljs-string">&quot;\n&quot;</span>; <br></code></pre></td></tr></table></figure><h4 id="5-子程序中的私有变量-my"><a href="#5-子程序中的私有变量-my" class="headerlink" title="5. 子程序中的私有变量 my"></a>5. 子程序中的私有变量 my</h4><p>用<strong>my</strong>操作符来定义子程序中的私有变量，作用域只是该子程序。</p><p>可以用来对子程序参数重命名，也就是将参数保存在这些私有变量里，因为默认的@_数组保存变量不好识别，变量多了不知道各个变量是什么意思。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">max</span> </span>&#123;<br> <span class="hljs-keyword">my</span>($l,$r) = @_;<br> <span class="hljs-keyword">if</span>($l &gt; $r) &#123; $l; &#125;<br> <span class="hljs-keyword">else</span> &#123; $r; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>my操作符不加（）的时候只能声明单个变量。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $fred,$barney; <span class="hljs-comment"># 只声明了$fred；</span><br></code></pre></td></tr></table></figure><h4 id="6-子程序持久性私有变量-state"><a href="#6-子程序持久性私有变量-state" class="headerlink" title="6. 子程序持久性私有变量 state"></a>6. 子程序持久性私有变量 state</h4><p>用state声明，子程序在多次调用的时候保留该变量的值，类似于C++中的static变量。</p><h4 id="7-自定义-排序规则子程序-sort-definition-subroutine"><a href="#7-自定义-排序规则子程序-sort-definition-subroutine" class="headerlink" title="7. 自定义 排序规则子程序(sort-definition subroutine)"></a>7. 自定义 排序规则子程序(sort-definition subroutine)</h4><p>通过自己定义规则子程序对元素进行排序。可以是正序、反序、或者按照键值对哈希排序等。</p><p>比如：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">sort_any</span> </span>&#123;<br><span class="hljs-keyword">if</span>($a&gt;$b) &#123;<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;  <span class="hljs-comment"># 大的在前，降序</span><br><span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于上面程序中的变量$a,$b是perl为我们定义好的，不需要自己定义，它们是来自排序列表中的两个元素。</p><p>子程序会返回一个数字，用来描述两个元素的比较结果。如果返回-1，表示$a应该在$b之前，返回1，$a应该在$b之后，返回0表示无所谓谁先谁后。上面程序中$a&gt;$b时返回-1，表示将大的$a排在前面，也就是降序排列。</p><p><strong>使用自定义排序规则</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs PERL"><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">sort_any</span> </span>&#123;<br><span class="hljs-keyword">if</span>($a&gt;$b) &#123;<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;  <span class="hljs-comment"># 大的在前，降序</span><br><span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; &#125;<br>&#125;<br>@arr = <span class="hljs-keyword">qw</span>/<span class="hljs-number">10</span> <span class="hljs-number">2</span> <span class="hljs-number">20</span> <span class="hljs-number">40</span>/;<br>@arr_sort = <span class="hljs-keyword">sort</span> sort_any @arr;  <span class="hljs-comment">## 调用自定义排序函数</span><br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;@arr_sort\n&quot;</span>; <span class="hljs-comment"># output : 40 20 10 2</span><br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;@arr\n&quot;</span>;  <span class="hljs-comment"># output : 10 2 20 40 不会改变原来列表</span><br></code></pre></td></tr></table></figure><p>另外，可以用飞船操作符&lt;&#x3D;&gt;，<strong>无分号结尾</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">sort_any</span> </span>&#123; $a &lt;=&gt; $b &#125; <span class="hljs-comment">#表示升序排列</span><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">sort_any</span> </span>&#123; $b &lt;=&gt; $a &#125; <span class="hljs-comment">#表示降序排列</span><br></code></pre></td></tr></table></figure><p><strong>按照哈希值排序</strong></p><p>其实是按照值对键进行排序，比如按照分数对人名进行排序。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs PERL">%h = (<span class="hljs-string">&#x27;dong&#x27;</span>,<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;wang&#x27;</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&#x27;liu&#x27;</span>,<span class="hljs-number">30</span>);<br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">sort_hash</span> </span>&#123;<br>$h&#123;$b&#125;&lt;=&gt;$h&#123;$a&#125; <span class="hljs-comment">#降序,根据值进行排序</span><br>&#125;<br>@l = <span class="hljs-keyword">sort</span> sort_hash <span class="hljs-keyword">keys</span> %h; <span class="hljs-comment"># 对键进行排序</span><br><span class="hljs-keyword">foreach</span> (@l) &#123;<span class="hljs-keyword">print</span> $_;<span class="hljs-keyword">print</span> <span class="hljs-string">&quot;\t&quot;</span>;&#125;<br><span class="hljs-comment"># output : liu wang dong</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>script</category>
      
      <category>perl</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>perl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跨时钟域设计</title>
    <link href="/2019/05/23/IC/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2019/05/23/IC/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="1-同步、异步定义"><a href="#1-同步、异步定义" class="headerlink" title="1. 同步、异步定义"></a>1. 同步、异步定义</h2><p><strong>对于工具来说，只要给出了时钟之间的关系，工具就认为是同步时钟，tool就可以对这两个时钟分析时序关系。</strong></p><p><strong>同步时钟：能够明确定义以下属性的时钟:</strong></p><ol><li>时钟周期或者频率</li><li>时钟占空比 duty time</li><li>每个时钟信号第一个上升沿的时间（相位）</li><li>时钟的输入latency——从PLL到模块的时钟输入端口的delay</li></ol><p><strong>异步时钟：</strong>没法明确定义上面这些属性的时钟。</p><p>比如clk0的周期、占空比、相位、latency都明确定义了，clk1只定义了时钟频率，那么就可以将这两个时钟看成异步时钟。</p><h2 id="2-亚稳态-metastable"><a href="#2-亚稳态-metastable" class="headerlink" title="2. 亚稳态 metastable"></a>2. 亚稳态 metastable</h2><p>亚稳态这东西各种数字书、时序书、文章等都会提到，都有专门的论文将这个metastable，比如Criticality-dependency-aware timing characterization and analysis。</p><h4 id="建立保持时间"><a href="#建立保持时间" class="headerlink" title="建立保持时间"></a>建立保持时间</h4><p><strong>建立时间：</strong>数据在时钟有效沿之前需要保持稳定的时间。</p><p><strong>保持时间</strong>：数据在时钟有效沿之后需要保持稳定的时间。</p><p><strong>建立时间和保持时间产生的由来是：边沿触发的触发器由锁存器组成的，锁存器是两个与非门或者或非门反馈形成的，反馈回路上有延迟，这样就导致触发器需要建立时间和保持时间，保证触发器建立稳定的反馈，否则就是不稳定，也就是亚稳态喽。</strong></p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/sr.png"></p><p>比如下面这张图：</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/meta1.png"></p><p>​    上方(a)图：横轴Tcp-d是时钟有效之前data需要稳定的时间，在上图中也就是从data input到达D开始至clock edge到达CP的时间；纵轴Tcp-q寄存器传播延迟——clock edge(CP)到data output(Q)时间。可见随着Tcp-d增大，Tcp-q区域稳定值，当此时的Tcp-q恶化10%时对应的Tcp-d就是Tsetup时间。如果Tcp-d继续减小，寄存器延迟迅速增长。</p><p>​         灰影区域<strong>metastable region</strong>亚稳态区域。但是就算是setup slack 小于建立时间，处在亚稳态区域，芯片也不一定失败，因为设计中的路径可能时序裕量较大。但是工艺厂商不保证器件时序正确。保持时间类似，如下图：</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/meta2.png"></p><h4 id="亚稳态的两个问题"><a href="#亚稳态的两个问题" class="headerlink" title="亚稳态的两个问题"></a>亚稳态的两个问题</h4><p>当建立、保持时间不满足时寄存器处于亚稳态，这回带来两个问题：</p><ol><li><strong>实际电路中大大延迟了Tck-q的时间，这个Tck-q的值不在工艺库里，需要问foundry到底是多少</strong></li><li><strong>最终Q端的值不确定，可能是0也可能是1.</strong></li></ol><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/meta3.png"></p><h2 id="3-跨时钟域处理的目标"><a href="#3-跨时钟域处理的目标" class="headerlink" title="3.  跨时钟域处理的目标"></a>3.  跨时钟域处理的目标</h2><p>为了保证跨时钟域数据（事件）的完整性或正确性：</p><ol><li>数据（事件）的值不能错</li><li>数据（事件）的顺序不能错</li><li>数据（事件）的个数不能错</li></ol><p>通过这三点来检验跨时钟域数据传输的正确性。</p><h2 id="3-single-bit跨时钟域"><a href="#3-single-bit跨时钟域" class="headerlink" title="3. single bit跨时钟域"></a>3. single bit跨时钟域</h2><h4 id="两级同步跨时钟信号（打两拍）"><a href="#两级同步跨时钟信号（打两拍）" class="headerlink" title="两级同步跨时钟信号（打两拍）"></a>两级同步跨时钟信号（打两拍）</h4><p>通常的跨时钟域传递数据会产生亚稳态，采样的异步时钟不知道被采样的data是否已经稳定，或者被采样的data不一定满足采样时钟的建立、保持时间。</p><p><strong>一般会采用如下图的打两拍——用两个寄存器将数据稳定一下；并且设置两个用来同步的触发器间Q到D的max delay(set_maximal_delay)。</strong>下面会分析为什么要这样。</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/sb1.png"></p><p>上图中，clk0,clk1是异步时钟，clk0控制绿色的寄存器，clk1控制两个蓝色的寄存器，我们称两个蓝色的寄存器位同步寄存器。第一个同步寄存器很可能是亚稳态采样，第二个寄存器基本不会亚稳态。</p><p>对于第一个同步的寄存器而言是跨时钟域采样，很可能亚稳态，这样第一个寄存器的Tck-q就会很长（这要问foundry，库中器件最大的Tck-q到底是多少，而不是根据库中的信息），比如1ns。</p><p><strong>如果同步时钟clk1不是很大</strong>，比如不到100Mhz，那么周期T是10Ns，那么对于第二个寄存器来说有足够的setup  \hold time来保证不是亚稳态采样。</p><p><strong>当然如果clk1频率很高的话</strong>，由于第一个寄存器亚稳态采样，Tck-q很大，实际中第一个寄存器Q端的输出会向后延迟，使第二个寄存器的setup time不满足。如下图中</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/sb2.png"></p><p>上图中由于clk1采样d_async时不满足建立时间，使得第一个同步寄存器亚稳态，其输出端d_async0经过很长时间才稳定，也就是Tck-q时间大大增长，这使得第二个同步寄存器在采样d_async0的时候也发生建立时间不满足，也使得输出端d_async1亚稳态，这样就错了。</p><p>这就需要设置第一个同步寄存器Q端到第二个同步寄存器D端的最大延迟(max delay)，使这段路径满足建立保持时间约束(T &gt; Tck-q + Tq-d + Tsu)。如下图所示：</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/sb3.png"></p><h4 id="跨时钟域可能延迟一个周期"><a href="#跨时钟域可能延迟一个周期" class="headerlink" title="跨时钟域可能延迟一个周期"></a>跨时钟域可能延迟一个周期</h4><p>在跨时钟域传输中可能会延迟一个周期，如下图所示</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/sb4.png"></p><p>如上图中case0中d_sync0第一个周期采样到了高电平，而case1中d_sync0第一个周期没采样到高电平，其信号延迟了一个周期，这种延迟一个周期是不确定的，但知识一个周期，不会是两个.</p><h4 id="错误的single-bit采样电路"><a href="#错误的single-bit采样电路" class="headerlink" title="错误的single bit采样电路"></a>错误的single bit采样电路</h4><p><strong>第一种</strong></p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/sb5.png"></p><p>上图中组合逻辑电路可能竞争冒险，使同步的寄存器采样到错误的数据</p><p><strong>第二种</strong></p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/sb6.png"></p><p>第一级同步寄存器是会产生亚稳态，那么它的Tck-q就会很大，比如1ns吧，但工具不知道，以为它是正常的满足setup 、hold 的，所以根据库中的Tck-q，比如0.2ns，这样实际中的Tck-q多了0.8ns，所以实际中的d_sync0信号会比工具认为的推迟0.8ns，如第二个d_asyn0信号，这样就有可能使第二级同步寄存器不满足setup time，产生亚稳态。这其实就是上面讨论的。</p><p>解决方法就是对Q到D之间的路径加一个MAX DELAY约束，考虑到Tck-q增大的情况。</p><h2 id="4-multi-bit跨时钟域"><a href="#4-multi-bit跨时钟域" class="headerlink" title="4. multi bit跨时钟域"></a>4. multi bit跨时钟域</h2><p>对于多位数据跨时钟域传递，如下图：</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/mb1.png"></p><p>这样不对，第一级的几个同步寄存器亚稳态时可能会产生四个输出（两位数据，四种情况），产生的数据不是传输的0或者3，这不行</p><h4 id="采用握手信号"><a href="#采用握手信号" class="headerlink" title="采用握手信号"></a>采用握手信号</h4><p>下图是基于握手信号的多位同步。传递一个数据需要握手4次，传递效率低，但对时钟频率没有特别的要求。</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/mb2.png"></p><h4 id="对数据使能信号进行寄存，控制数据采样"><a href="#对数据使能信号进行寄存，控制数据采样" class="headerlink" title="对数据使能信号进行寄存，控制数据采样"></a>对数据使能信号进行寄存，控制数据采样</h4><p>下图中，vld控制data信号，当vld有效的时候clk0对data采样。</p><p>在异步时钟域中，通过同步寄存器对vld进行寄存，然后用异或门产生一个cap信号，用来控制时钟clk1对data数据采样。</p><p><strong>注意：这里没有对data信号寄存，而是对vld信号寄存的</strong></p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/mb3.png"></p><p>这种方法效率高一些。但要保证vld的脉冲宽度足够宽，至少是clk1的两三倍。</p><h2 id="5-异步fifo"><a href="#5-异步fifo" class="headerlink" title="5. 异步fifo"></a>5. 异步fifo</h2><p>当然异步FIFO时最有效的，异步fifo设计见另一篇文章</p><p><a href="%5Bhttps://east1203.github.io/2019/04/13/IC/19_04/%E5%90%8C%E6%AD%A5FIFO/%5D(https://east1203.github.io/2019/04/13/IC/19_04/%E5%90%8C%E6%AD%A5FIFO/">同步FIFO</a></p><p><a href="%5Bhttps://east1203.github.io/2019/04/13/IC/19_04/%E5%BC%82%E6%AD%A5fifo/%5D(https://east1203.github.io/2019/04/13/IC/19_04/%E5%BC%82%E6%AD%A5fifo/">异步FIFO</a>s</p><p>当然异步fifo有好多时序上的问题，一般不要自己搞：</p><ol><li>使用synopsys DesignWare（DW)中的async_fifo IP</li><li>使用公司里经过TP验证的fifo，当然这要注意一下异步fifo实现的频率，可能100MHZ下可以用1GHZ或者500MHZ下就不行了</li><li>在FPGA中就用ISE&#x2F;VIVADO中自带的IP。</li></ol><h2 id="6-后仿中的时序约束"><a href="#6-后仿中的时序约束" class="headerlink" title="6.  后仿中的时序约束"></a>6.  后仿中的时序约束</h2><p>1 . 后仿的时候要设置不让工具检查跨时钟域的setup、hold time，因为肯定会产生亚稳态。</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/async1.png"></p><p>2 . 上面也提到的设置Q到D的最大延迟</p><h2 id="7-在Verilog高级数字设计第五章还有一块介绍异步传输的，"><a href="#7-在Verilog高级数字设计第五章还有一块介绍异步传输的，" class="headerlink" title="7.  在Verilog高级数字设计第五章还有一块介绍异步传输的，"></a>7.  在Verilog高级数字设计第五章还有一块介绍异步传输的，</h2><p>分成两种情况：异步数据脉冲宽度和同步时钟长短</p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>Asynchronous</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>Asynchronous</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中的异常</title>
    <link href="/2019/05/19/C++/C++%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8/"/>
    <url>/2019/05/19/C++/C++%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<p>关于异常这里先只放一张关于异常<strong>栈展开</strong>，也就是关于异常的抛出和捕获的配对</p><p>再try块中抛出（throw）异常（exception），在函数的调用链上逐级向上寻找匹配的catch块，如果找到了匹配的catch就执行异常处理的代码，如果没有找到推出当前的程序块或者函数（一些相关的局部对象就会被释放掉），然后继续向上找。如果最终找不到，会执行一个terminate程序，终止程序的执行。</p><p>异常捕获的搜索如下图：</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/excep.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过RISC存储程序机理解数据通路控制器设计</title>
    <link href="/2019/05/16/IC/CPU/%E9%80%9A%E8%BF%87RISC%E5%AD%98%E5%82%A8%E7%A8%8B%E5%BA%8F%E6%9C%BA%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1/"/>
    <url>/2019/05/16/IC/CPU/%E9%80%9A%E8%BF%87RISC%E5%AD%98%E5%82%A8%E7%A8%8B%E5%BA%8F%E6%9C%BA%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="RISC存储程序机"><a href="#RISC存储程序机" class="headerlink" title="RISC存储程序机"></a>RISC存储程序机</h3><p>RISC存储程序机SPM，该电路的程序和数据存储在存储器中。该电路有三个部分控制器、处理器（数据通路）和存储器。通过流水线设计（用寄存器打断）实现同时的指令获取、译码和执行。</p><p><strong>结构框图如下：</strong></p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/risc7.png"></p><h4 id="1-处理器"><a href="#1-处理器" class="headerlink" title="1.处理器"></a>1.处理器</h4><p>处理器部分包括寄存器（包括四个通用寄存器，Program Counter,Instruction Register、地址寄存器add_R等）、ALU、复用器、数据通路等。</p><p>上图中标出了数据流动的路线，寄存器赋值、复用器选择受到外部控制信号作用。</p><h4 id="2-ALU"><a href="#2-ALU" class="headerlink" title="2.ALU"></a>2.ALU</h4><p>ALU中的运算指令：</p><p>ADD 求和,</p><p>SUB 减法,</p><p>AND 按位与,</p><p>NOT取反</p><h4 id="3-控制器"><a href="#3-控制器" class="headerlink" title="3.控制器"></a>3.控制器</h4><p>上图(figure 7-10)中左边是controller，RISC机的所有操作都受控制器控制，控制器根据当前的指令将各个控制信号给到处理器和memory。</p><p>控制器的设计依赖于ALU的性能、数据通路资源和可用时钟方案。</p><table><thead><tr><th>控制信号</th><th>操作</th></tr></thead><tbody><tr><td>Load_Add_flag</td><td>加载地址寄存器</td></tr><tr><td>Load_PC</td><td>将Bus_2上的内容写到PC</td></tr><tr><td>Load_IR</td><td>加载指令寄存器IR</td></tr><tr><td>Inc_PC</td><td>PC加一</td></tr><tr><td>Sel_Bus_1_Mux</td><td>选择Mux_1的驱动源</td></tr><tr><td>Sel_Bus_2_Mux</td><td>选择Mux_2的驱动源</td></tr><tr><td>Load_R0</td><td>加载R0</td></tr><tr><td>Load_R1</td><td>加载R1</td></tr><tr><td>Load_R2</td><td>加载R2</td></tr><tr><td>Load_R3</td><td>加载R3</td></tr><tr><td>Load_Reg_Y</td><td>将Bus_2的内容写到Reg_Y</td></tr><tr><td>Load_Reg_Z</td><td>将ALU的输出写入Reg_X</td></tr><tr><td>Write</td><td>将Bus_1的内容写入memory</td></tr></tbody></table><h4 id="4-指令集"><a href="#4-指令集" class="headerlink" title="4.指令集"></a>4.指令集</h4><p>RISC机根据存储器中的指令序列进行操作，那么就必须预先定义好指令集内容。本次中的指令有一个字节的也有两个字节的，如下图所示</p><p><strong>对于单字节指令</strong>，前四位是指令的操作吗，后四位是源寄存器地址和目的寄存器地址。</p><p><strong>对于双字节指令</strong>，前四位是指令的操作码，后四位是源寄存器地址或目的寄存器地址，由指令类型决定；第二个字节给了操作数在存储器中的地址。</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/risc8.png"></p><p><strong>所有指令如下：</strong></p><ol><li><p><strong>单字节指令</strong></p><p>NOP：不执行任何操作，寄存器保持原值，源目的地址无效</p><p>ADD：源和目的寄存器中的内容相加，将结果保存到目的寄存器</p><p>SUB：源和目的寄存器中的内容相减，将结果保存到目的寄存器</p><p>AND：源和目的寄存器中的内容按位与，将结果保存到目的寄存器</p><p>NOT：源寄存器内容取反，保存到目的寄存器</p></li><li><p><strong>双字节指令</strong></p><p>RD：从第二个字节（地址）指定的存储单元位置取出数据存到目的寄存器，忽略源寄存器</p><p>WR：将源寄存器的数据取出存到第二个自己指定的存储单元位置，忽略目的寄存器</p><p>BR：从第二个字节指定的存储单元的内容存入PC，实现分支跳转，忽略源和目的寄存器</p><p>BRZ：当零标志位有效的时候，从第二个字节指定的存储单元的内容存入PC，实现分支跳转，忽略源和目的寄存器</p></li></ol><p><strong>下面给出每条指令的编码：</strong></p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/risc11.png"></p><h4 id="5-控制器设计"><a href="#5-控制器设计" class="headerlink" title="5.控制器设计"></a>5.控制器设计</h4><p><strong>根据指令定义状态机的状态，根据译码结果实现状态的跳转。</strong></p><p>该RISC机指令的执行分成三个阶段，取指、译码和执行。<strong>取指阶段</strong>分成两个周期，第一个周期加载地址寄存器Add_R，第二个周期从存储器中将指定地址处的内容取出给到指令寄存器IR。<strong>译码阶段</strong>一个周期完成。<strong>执行阶段</strong>根据不同指令类型分为0、1、2个周期，其中NOT指令可在译码周期内完成，单字节指令如ADD在一个周期内完成计算并将结果写入目的寄存器，其中<strong>源寄存器在译码阶段加载</strong>。双字节指令，如RD，需要两个周期，第一个周期将指令的第二个字节载入地址寄存器，另一个周期从指定的存储器单元位置读取数据写到目的寄存器。</p><p>根据上面分析，可以分成如下11个状态，需要两个周期的阶段有两个状态。</p><h5 id="各个状态"><a href="#各个状态" class="headerlink" title="各个状态"></a>各个状态</h5><table><thead><tr><th>各状态名</th><th>描述</th></tr></thead><tbody><tr><td>S_idle</td><td>复位后进入该状态，不执行任何操作</td></tr><tr><td>S_fet1</td><td>将PC值加载到地址寄存器Add_R，（复位操作会将PC值初始化位其实地址），复位无效后的第一个有效时钟进入该状态；NOP指令译码结束也进入该状态</td></tr><tr><td>S_fet2</td><td>将地址寄存器指定地址中的内容载入到指令寄存器，并将PC值加一</td></tr><tr><td>S_dec</td><td>对IR的内容译码，产生一些数据通路和寄存器的控制信号，控制状态的跳转。如果是双字节指令，需要加载地址寄存器</td></tr><tr><td>S_ex</td><td>单字节指令执行ALU操作，设置零标志位，将结果存入目的寄存器</td></tr><tr><td>S_rd1</td><td>将RD指令第二个字节从memory中加载到地址寄存器，PC+1</td></tr><tr><td>S_rd2</td><td>将S_rd1状态指定的存储器位置取出数据存入目的寄存器</td></tr><tr><td>S_wr1</td><td>将WR指令第二个字节从memory中加载到地址寄存器，PC+1</td></tr><tr><td>S_wr2</td><td>将源寄存器的内容村早S_wr1状态指定的存储器单元位置</td></tr><tr><td>S_br1</td><td>将BR指令第二个字节从memory中加载到地址寄存器，PC+1</td></tr><tr><td>S_br2</td><td>将S_br1指定的存储器单元地址存到PC</td></tr><tr><td>S_halt</td><td>发生指令异常，进入默认状态</td></tr></tbody></table><h5 id="下面几幅图给出根据译码结果执行不同指令的ASM图"><a href="#下面几幅图给出根据译码结果执行不同指令的ASM图" class="headerlink" title="下面几幅图给出根据译码结果执行不同指令的ASM图"></a><strong>下面几幅图给出根据译码结果执行不同指令的ASM图</strong></h5><p>一下几张图要参考代码来看，<a href="https://github.com/east1203/Verilog_module/tree/master/risc%E5%AD%98%E5%82%A8%E7%A8%8B%E5%BA%8F%E6%9C%BA%20SPM/%E4%B9%A6%E4%B8%AD%E9%99%84%E5%B8%A6%E7%9A%84%E4%BB%A3%E7%A0%81">书中附带的代码</a></p><h6 id="单字节指令的ALU运算"><a href="#单字节指令的ALU运算" class="headerlink" title="单字节指令的ALU运算"></a>单字节指令的ALU运算</h6><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/risc12.png"></p><h6 id="RD指令"><a href="#RD指令" class="headerlink" title="RD指令"></a>RD指令</h6><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/risc13.png"></p><h6 id="WR指令"><a href="#WR指令" class="headerlink" title="WR指令"></a>WR指令</h6><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/risc14.png"></p><h6 id="NOT指令"><a href="#NOT指令" class="headerlink" title="NOT指令"></a>NOT指令</h6><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/risc15.png"></p><h6 id="BZ-BRZ指令"><a href="#BZ-BRZ指令" class="headerlink" title="BZ  BRZ指令"></a>BZ  BRZ指令</h6><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/risc16.png"></p><h4 id="6-处理器"><a href="#6-处理器" class="headerlink" title="6.处理器"></a>6.处理器</h4><p>根据下面这张图中处理器里面的模块例化出来，端口连接好就行，具体见代码</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/05/risc7.png"></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>CPU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>RISC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>perl语言——输入与输出</title>
    <link href="/2019/05/16/IC/script/perl/perl%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"/>
    <url>/2019/05/16/IC/script/perl/perl%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h4 id="1-读取标准输入-lt-STDIN-gt"><a href="#1-读取标准输入-lt-STDIN-gt" class="headerlink" title="1. 读取标准输入  &lt; STDIN&gt;"></a>1. 读取标准输入  &lt; STDIN&gt;</h4><figure class="highlight perl"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># 从控制台读取信息，并打印出来：</span><br>$line = &lt;STDIN&gt;;<br><span class="hljs-keyword">print</span> $line;<br><span class="hljs-comment"># 不停打印</span><br><span class="hljs-keyword">while</span>(&lt;STDIN&gt;) &#123;<br>    <span class="hljs-keyword">print</span> $_; <span class="hljs-comment"># 默认将标准输入的内容保存在$_变量中</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-钻石操作符输入-lt-gt"><a href="#2-钻石操作符输入-lt-gt" class="headerlink" title="2. 钻石操作符输入 &lt;&gt;"></a>2. 钻石操作符输入 &lt;&gt;</h4><p>通过钻石操作符&lt;&gt;来读取文件的内容，使用时将要打开的文件名作为参数写在命令行中，如下</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">perl pro.pl filename<br></code></pre></td></tr></table></figure><p>&lt;&gt;会读取文件中的内容，如果写了多个文件名，那么逐个打开文件。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># 文件内容 command.log</span><br>first line<br>second line<br>third line<br><span class="hljs-comment"># perl 程序 pro.pl</span><br><span class="hljs-keyword">while</span>($line=&lt;&gt;) &#123;<br><span class="hljs-keyword">print</span> $line;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;ok\n&quot;</span>;<br>&#125;<br><span class="hljs-comment"># 在命令行中键入 perl pro.pl command.log</span><br><span class="hljs-comment"># 输出</span><br>first line  <span class="hljs-comment">## 可以看到&lt;&gt;操作符逐行读取文件的内容保存在$line变量中</span><br>ok<br>second line<br>ok<br>third line<br>ok<br><span class="hljs-comment">#####################</span><br><span class="hljs-keyword">while</span>(&lt;&gt;) &#123;<br><span class="hljs-keyword">print</span> $_;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;ok\n&quot;</span>;<br>&#125;<br><span class="hljs-comment">## 输出一样，&lt;&gt;默认存在$_中</span><br></code></pre></td></tr></table></figure><h4 id="3-调用参数-——-ARGV数组"><a href="#3-调用参数-——-ARGV数组" class="headerlink" title="3. 调用参数 ——@ARGV数组"></a>3. 调用参数 ——@ARGV数组</h4><p>上面将的钻石操作符，其实不是直接来检查命令行的参数。<strong>命令行的参数先传给一个列表@ARGV</strong>，@ARGV中保存命令行中的参数成员</p><p>所以上面的程序也可以写成</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl">@ARGV = <span class="hljs-string">&#x27;command.log&#x27;</span>;<br><span class="hljs-keyword">while</span>($line=&lt;&gt;) &#123;<br><span class="hljs-keyword">print</span> $line;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;ok\n&quot;</span>;<br>&#125;<br><span class="hljs-comment">## 如果要打开多个文件</span><br>@ARGV = <span class="hljs-keyword">qw</span>/file1 file2 file3/; <span class="hljs-comment">## qw// 返回列表</span><br></code></pre></td></tr></table></figure><p><strong>我们可以从命令行中向文件里传递参数，比如文件名，或者其他影响程序运行的参数。命令行中的参数保存在数组@ARGV中。</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">[command_line]$ pro.pl var1 var2 <span class="hljs-comment">#从命令行向文件pro.pl传入了两个参数var1,var2</span><br><span class="hljs-comment">## 在文件pro.pl中使用传入的参数</span><br>$VAR1 = $ARGV[<span class="hljs-number">0</span>];<br>$VAR2 = $ARGV[<span class="hljs-number">1</span>];<span class="hljs-comment">#把参数从数组@ARGV中提取出来</span><br></code></pre></td></tr></table></figure><h4 id="4-输出到标准输出"><a href="#4-输出到标准输出" class="headerlink" title="4. 输出到标准输出"></a>4. 输出到标准输出</h4><p>标准输出就是&lt; STDOUT&gt;，默认print会输出到这，&lt; STDOUT&gt;默认对应的是控制台</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;this is a test\n&quot;</span>;<br><span class="hljs-comment"># 也可以输出多个</span><br><span class="hljs-keyword">print</span> $val1,$val2,<span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-comment">## 对于列表输出</span><br>@list = <span class="hljs-keyword">qw</span>/this is a test/;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;@list\n&quot;</span>;<br><span class="hljs-keyword">print</span> @list,<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-comment">## 输出</span><br>this is a test <span class="hljs-comment">## 结果不言而喻，第二种输出都堆到一起了</span><br>thisisatest<br></code></pre></td></tr></table></figure><p>如果手动指定输出到命令行。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">print</span> &lt;STDOUT&gt;,”hello<span class="hljs-string">&quot;; // 这里的逗号是必须有的。</span><br><span class="hljs-string">print STDOUT &quot;</span>hello\n<span class="hljs-string">&quot;; // 这么写不需要逗号。</span><br></code></pre></td></tr></table></figure><p><strong>下面输出到文件的时候，不能写逗号，要用空格。</strong></p><h4 id="5-格式化输出printf"><a href="#5-格式化输出printf" class="headerlink" title="5. 格式化输出printf"></a>5. 格式化输出printf</h4><p>这种类似于C中的， ** printf “格式字符串”，数据列表**</p><p>由%s,%d,%f等，还有%g自动选择整数浮点数还是指数形式</p><p><strong>print没有这个功能。</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">printf</span> <span class="hljs-string">&quot;%s %s\n&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>;<br><span class="hljs-keyword">printf</span> <span class="hljs-string">&quot;%4.2f\n&quot;</span>,<span class="hljs-number">12.222</span>;<br>hello world<br><span class="hljs-number">12.22</span><br><span class="hljs-comment">## 也可以将格式字符串写成变量</span><br>$format = <span class="hljs-string">&quot;%s %s\n&quot;</span>;<br><span class="hljs-keyword">printf</span> $format,<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>;<br><br></code></pre></td></tr></table></figure><p><strong>在打印的时候动态生成格式字符串</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl">@list = <span class="hljs-keyword">qw</span>/apple banana pear/;<br>$format = <span class="hljs-string">&quot;list have &quot;</span>.(<span class="hljs-string">&quot;%6s &quot;</span> <span class="hljs-keyword">x</span> @list);<br><span class="hljs-keyword">printf</span> $format,@list;<br><span class="hljs-comment"># 输出</span><br>list have  apple banana   pear<br>.点号将字符串连接起来，<span class="hljs-keyword">x</span>字符是将字符串复制多少份 ，@List用在这个标量环境中返回元素个数<br></code></pre></td></tr></table></figure><h4 id="6-输入输出流定向-lt-和-gt"><a href="#6-输入输出流定向-lt-和-gt" class="headerlink" title="6. 输入输出流定向 &lt; 和 &gt;"></a>6. 输入输出流定向 &lt; 和 &gt;</h4><p>原来的标准输入&lt; STDIN&gt;是从控制台读入，&lt; STDOUT&gt;输出到控制台，但是可以通过标识符“&lt;”和”&gt;”来重新定义</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs perl"> <span class="hljs-comment"># command.log 文件内容</span><br> first line<br> second line<br> third line<br> <span class="hljs-comment"># pro.pl</span><br> <span class="hljs-keyword">while</span>($line = &lt;STDIN&gt;) &#123;<br> <span class="hljs-keyword">print</span> $line;<br> &#125;<br> <span class="hljs-comment"># 命令行键入</span><br> perl pro.pl &lt; command.log <span class="hljs-comment"># &lt;STDIN&gt;是从command.log文件中读入</span><br> <span class="hljs-comment"># output</span><br> first line<br> second line<br>third line<br> <span class="hljs-comment"># 同理 &gt; 是将&lt;STDOUT&gt;指向某个文件，而不是控制台</span><br></code></pre></td></tr></table></figure><h4 id="7-文件句柄-open-close"><a href="#7-文件句柄-open-close" class="headerlink" title="7. 文件句柄 open close"></a>7. 文件句柄 open close</h4><p><strong>文件句柄是裸字，没有$这个美元符号</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">open</span> FILE1,<span class="hljs-string">&#x27;file&#x27;</span>;<br><span class="hljs-keyword">open</span> FILE2,<span class="hljs-string">&#x27;&gt; file1&#x27;</span>;<br><span class="hljs-keyword">open</span> FILE3,<span class="hljs-string">&#x27;&lt; file2&#x27;</span>;<br><span class="hljs-keyword">open</span> FILE4,<span class="hljs-string">&#x27;&gt;&gt; file3&#x27;</span>; <span class="hljs-comment"># 以追加输入的方式打开文件</span><br><span class="hljs-keyword">close</span> FILE1;<br></code></pre></td></tr></table></figure><h4 id="8-使用文件句柄对文件输入输出"><a href="#8-使用文件句柄对文件输入输出" class="headerlink" title="8. 使用文件句柄对文件输入输出"></a>8. 使用文件句柄对文件输入输出</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># command.log 文件内容：</span><br>first line<br>second line<br>third line<br><span class="hljs-comment"># pro1.pl perl程序文件内容：</span><br><span class="hljs-keyword">open</span> CMD,<span class="hljs-string">&quot;&lt; command.log&quot;</span>;<br>$line = &lt;CMD&gt;; <span class="hljs-comment"># &lt;CMD&gt;只能读取一行</span><br><span class="hljs-keyword">print</span> $line;<br><span class="hljs-keyword">close</span> CMD;<br><span class="hljs-comment"># output：</span><br>first line <span class="hljs-comment"># 只输出一行，</span><br><span class="hljs-comment">######################</span><br><span class="hljs-comment">#如果想要读取多行，如下写</span><br><span class="hljs-comment"># pro2.pl perl程序文件内容：</span><br><span class="hljs-keyword">open</span> CMD,<span class="hljs-string">&quot;&lt; command.log&quot;</span>;<br>$line = <span class="hljs-keyword">join</span> <span class="hljs-string">&quot;&quot;</span>,&lt;CMD&gt;; <span class="hljs-comment"># 将所有的行连接成一个大的字符串</span><br><span class="hljs-keyword">print</span> $line;<br><span class="hljs-keyword">close</span> CMD;<br><span class="hljs-comment">#output:</span><br>first line<br>second line<br>third line<br><span class="hljs-comment">######################</span><br><span class="hljs-comment"># pro3.pl 也可以这么写，while循环输出所有行</span><br><span class="hljs-keyword">open</span> CMD,<span class="hljs-string">&quot;&lt; command.log&quot;</span>;<br><span class="hljs-keyword">while</span>($line=&lt;CMD&gt;) &#123;<br><span class="hljs-keyword">print</span> $line;<br>&#125;<br><span class="hljs-keyword">close</span> CMD;<br></code></pre></td></tr></table></figure><h4 id="9-改变默认文件的输出句柄-select"><a href="#9-改变默认文件的输出句柄-select" class="headerlink" title="9. 改变默认文件的输出句柄 select"></a>9. 改变默认文件的输出句柄 select</h4><p>比如 print 默认输出到&lt; STDOUT&gt;，到控制台</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">open</span> fp,<span class="hljs-string">&#x27;&gt; a.log&#x27;</span>;<br><span class="hljs-keyword">select</span> fp;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;TO FILE!!&quot;</span>;<br><span class="hljs-comment">## 输出到了文件a.log中</span><br><span class="hljs-keyword">select</span> STDOUT;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;TO STDOUT!!\n&quot;</span>;<br><span class="hljs-comment"># 输出到控制台</span><br></code></pre></td></tr></table></figure><h4 id="10-直接输出到文件句柄中"><a href="#10-直接输出到文件句柄中" class="headerlink" title="10. 直接输出到文件句柄中"></a>10. 直接输出到文件句柄中</h4><p>直接将字符串输出到文件句柄</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs PERL"><span class="hljs-keyword">open</span> fp,<span class="hljs-string">&#x27;&gt; a.log&#x27;</span>;<br><span class="hljs-keyword">print</span> fp <span class="hljs-string">&quot;TO FILE!!\n&quot;</span>; <span class="hljs-comment"># 注意格式,fp之后是空格</span><br><span class="hljs-comment">## 输出到了文件a.log中</span><br></code></pre></td></tr></table></figure><p><strong>这里文件句柄没有&lt;&gt;这个符号，有的话出错。</strong></p><h4 id="11-将文件句柄保存在变量中"><a href="#11-将文件句柄保存在变量中" class="headerlink" title="11. 将文件句柄保存在变量中"></a>11. 将文件句柄保存在变量中</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> $val_fh;<br><span class="hljs-keyword">open</span> $val_fh <span class="hljs-string">&#x27;&lt;&#x27;</span>,<span class="hljs-string">&#x27;file1&#x27;</span>;<br><span class="hljs-comment"># 或者写成一句</span><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">my</span> $val_fh <span class="hljs-string">&#x27;&lt;&#x27;</span>,<span class="hljs-string">&#x27;file1&#x27;</span>;<br><span class="hljs-keyword">print</span> &lt;$val_fh&gt;; <span class="hljs-comment">#使用</span><br></code></pre></td></tr></table></figure><h4 id="12-有问题的文件句柄"><a href="#12-有问题的文件句柄" class="headerlink" title="12. 有问题的文件句柄"></a>12. 有问题的文件句柄</h4><p>​    perl程序是不能打开文件的，需要操作系统代劳，如果操作系统权限不足，那么文件就打开失败。如果试图从有问题的文件句柄中读数据，会直接读到文件结尾；如果写，数据被丢弃。</p><p>​    在编译的时候加-w或-warning选项会报出警告，但也可以在程序中规避这种错。open函数执行完会返回一个值，<strong>如果打开成功返回真，打开失败返回假。</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">if</span>(! <span class="hljs-keyword">open</span> fp,<span class="hljs-string">&#x27;&gt; a.log&#x27;</span>) &#123; <span class="hljs-comment"># open返回假则执行if函数</span><br><span class="hljs-comment">## 操作失败</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="13-die处理致命错误"><a href="#13-die处理致命错误" class="headerlink" title="13. die处理致命错误"></a>13. die处理致命错误</h4><p>die可以使程序在发生异常或致命错误（比如除以零，子程序未定义，不合法的正则表达式等）的时候停止程序执行，并输出警告信息。</p><p>die函数执行时，会将程序员指定的信息输出到标准错误输出流中，并立即终止当前perl程序的执行，<strong>是终止整个perl文件程序，而不是单独的某个子程序。</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">if</span>(! <span class="hljs-keyword">open</span> fp,<span class="hljs-string">&#x27;&gt; a.log&#x27;</span>) &#123; <span class="hljs-comment"># open返回假则执行if函数</span><br><span class="hljs-keyword">die</span> <span class="hljs-string">&quot;cannot open file $!&quot;</span>;<br>&#125;<br><span class="hljs-comment"># 变量$!中包含系统错误的解释性信息，便于差错</span><br></code></pre></td></tr></table></figure><p>如果在die后字符串中加了 \n ，则不会打印行号和文件名等信息。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">if</span>(@ARGV&lt;<span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">die</span> <span class="hljs-string">&quot;not enough arguments\n&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="14-自动检测致命错误"><a href="#14-自动检测致命错误" class="headerlink" title="14. 自动检测致命错误"></a>14. 自动检测致命错误</h4><p>在perl5.10中使用   use autodie; 会自动在open函数失败的时候返回错误信息。</p><h4 id="15-读取文件中的某些行保存在新文件中"><a href="#15-读取文件中的某些行保存在新文件中" class="headerlink" title="15. 读取文件中的某些行保存在新文件中"></a>15. 读取文件中的某些行保存在新文件中</h4><p>从info.log文件中读取有”sequence”单词的行，将这些行保存在新的文件info.out文件中。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">open</span> f<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;&lt; info.log&#x27;</span>;<br><span class="hljs-keyword">open</span> f1,<span class="hljs-string">&#x27;&gt; info.out&#x27;</span>; <br><span class="hljs-keyword">print</span> f1 <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">#用’&gt;&#x27;方式打开info.out文件，写入空将文件info.out清空</span><br><span class="hljs-keyword">close</span> f1;<br><span class="hljs-keyword">open</span> f1,<span class="hljs-string">&#x27;&gt;&gt; info.out&#x27;</span>; <span class="hljs-comment">#以递增的方式打开info.out</span><br><br><span class="hljs-keyword">while</span>($line=&lt;f<span class="hljs-number">0</span>&gt;) &#123;<br> <span class="hljs-comment"># 从行首\A匹配到行尾\Z，\Z表示行尾，在它之后也可以有换行符。</span><br> <span class="hljs-comment"># 将匹配到的值保存在列表中</span><br>  <span class="hljs-keyword">push</span> @l,($line =~ <span class="hljs-regexp">m/(?&lt;var&gt;\A.+sequence.+\Z\n)/</span>); <br>  <span class="hljs-keyword">print</span> f1 $l[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">pop</span> @l;<br>&#125;<br><span class="hljs-keyword">close</span> f<span class="hljs-number">0</span>;<br><span class="hljs-keyword">close</span> f1;<br><br><span class="hljs-comment"># 也可以这样写</span><br><span class="hljs-comment"># $line =~ m/(?&lt;var&gt;\A.+sequence.+\Z\n)/; </span><br><span class="hljs-comment"># push @l,$1;</span><br><span class="hljs-comment"># print f1 $l[0];</span><br><span class="hljs-comment"># pop @l;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>script</category>
      
      <category>perl</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>perl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>perl语言——正则表达式</title>
    <link href="/2019/05/15/IC/script/perl/perl%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2019/05/15/IC/script/perl/perl%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h4 id="一、正则表达式"><a href="#一、正则表达式" class="headerlink" title="一、正则表达式"></a>一、正则表达式</h4><p>在perl里面正则表达式(regular expression)又叫模式(pattern)，用来匹配或者不匹配某个字符串的特征模板</p><h4 id="二、几个正则中常用的符号"><a href="#二、几个正则中常用的符号" class="headerlink" title="二、几个正则中常用的符号"></a>二、几个正则中常用的符号</h4><p>在介绍正则表达式的内容之前，先介绍几个符号。</p><ol><li><strong>元字符 . \ ()</strong></li></ol><p> perl里面的某些字符具有特殊含义，叫做元字符。比如：</p><ol><li><p>点号. : 表示任意一个字符，不包括换行符</p></li><li><p>反斜杠 \ : 表示字符本身，忽略它的特殊含义。比如.就表示点号本身，而不是任意一个字符。</p></li><li><p>圆括号 () : 将模式分成一个个捕获组。</p></li><li><p><strong>量词 + * ?</strong></p></li><li><p>“+” ：表示匹配前面的条目一次或一次以上。</p><figure class="highlight vim"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">abc</span>+  : 匹配字符<span class="hljs-keyword">c</span>一次或者一次以上，可以匹配<span class="hljs-keyword">abc</span>,abcc,abccc<br><span class="hljs-keyword">ab</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]+ :匹配任意<span class="hljs-number">0</span>到<span class="hljs-number">9</span>的数字一次或一次以上，如 abc0 ,abc11,,<br><span class="hljs-keyword">ab</span>(<span class="hljs-keyword">cd</span>)+  : 匹配组(<span class="hljs-keyword">cd</span>)一次或一次以上，如abcd,abcdcd,abcdcdcd，，<br></code></pre></td></tr></table></figure></li><li><p>“*” : 表示匹配前面条目0次或任意次</p></li><li><p>“?” ： 表示匹配前面条目0次或1次</p></li><li><p><strong>模式分组 ()</strong></p></li></ol><p> 将模式分成多个捕获组，比如 “ ([a-z]+)([0-9]+.abc)  “,将模式单独分出两个组。</p><p> 在《perl语言入门》书中还讲到，可以利用刚刚从圆括号中匹配到的字符再次匹配。比如<br> <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs perl">$_ = <span class="hljs-string">&quot;abba&quot;</span>  <span class="hljs-comment">## 正则表达式默认对变量 $_ 进行匹配</span><br><span class="hljs-keyword">if</span>( <span class="hljs-regexp">m/(.)\1/</span> ) &#123; <span class="hljs-comment">#  m// 是模式的界定符，下面讲</span><br>      <span class="hljs-comment"># 这里会匹配 bb，\1 的意思是再次匹配第一个捕获组的内容，匹配了两次b</span><br>  <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;ok\n&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">## 如果存在多个圆括号，如何区分哪个括号是第几组？依次计算左括号的序号就可以</span><br>$_ = <span class="hljs-string">&quot;yabba dabba doo&quot;</span><br><span class="hljs-keyword">if</span> (<span class="hljs-regexp">m/y((.)(.)\3\2) d\1/</span>)&#123;  <span class="hljs-comment"># yabba dabba</span><br>  <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;ok\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br> 也可以将\1 \2写成 \g{1}   \g{2}，含义一样，又不容易误解<br>4. **则一匹配 | **</p><p> 要么匹配左边要么匹配右边<br>5. **字符集 [] **<br>存在[]中的一个字符<br> <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-attr">[a-z]</span>  : 任意<span class="hljs-selector-tag">a</span>到<span class="hljs-selector-tag">z</span>的一个字符<br><span class="hljs-selector-attr">[a-z0-9]</span> ,<span class="hljs-selector-attr">[a-zA-Z]</span>,都可以<br></code></pre></td></tr></table></figure><br> <strong>字符集简写</strong></p><ol><li>\d : 表示一个数字</li><li>\s : 表示一个空格</li><li><strong>脱字符 ^</strong><br> 脱字符用在字符集符号[]中，表示不包含这些内容。<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-attr">[^a-z]</span> :不包含<span class="hljs-selector-tag">a</span>到<span class="hljs-selector-tag">z</span><br><span class="hljs-selector-attr">[^\d]</span> : 不包含数字 ， 等价于 <span class="hljs-selector-attr">[\D]</span><br><span class="hljs-selector-attr">[^\s]</span> : 不包含空格    等价于<span class="hljs-selector-attr">[\S]</span><br><span class="hljs-selector-attr">[\d\D]</span> : 匹配任意字符，包括换行符<br><span class="hljs-selector-attr">[^\d\D]</span> : 不匹配任何字符<br></code></pre></td></tr></table></figure></li></ol><h4 id="三、用正则表达式进行匹配"><a href="#三、用正则表达式进行匹配" class="headerlink" title="三、用正则表达式进行匹配"></a>三、用正则表达式进行匹配</h4><h5 id="1-模式定界符-m-x2F-x2F"><a href="#1-模式定界符-m-x2F-x2F" class="headerlink" title="1. 模式定界符 m&#x2F;&#x2F;"></a><strong>1. 模式定界符 m&#x2F;&#x2F;</strong></h5><p> 前面程序中经常出现 <code>m / 模式 /</code>，其中&#x2F;&#x2F; 就是模式的定界符，斜杠可以用其他符号，比如<em>，#等 m## ,m</em>*</p><h5 id="2-模式匹配修饰符"><a href="#2-模式匹配修饰符" class="headerlink" title="2. 模式匹配修饰符"></a><strong>2. 模式匹配修饰符</strong></h5><p>  模式匹配修饰符(modifier)又叫标志（flag)，用在模式定界符后面，用来改变默认的匹配行为的。</p><ol><li>&#x2F;i ：大小写无关的匹配，这里的&#x2F;i，&#x2F;是m&#x2F;&#x2F;中的&#x2F;，如果是m##，那么就是#i  <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">$_ = <span class="hljs-string">&quot;ABC&quot;</span>;<br><span class="hljs-regexp">m/abc/i</span> ; <span class="hljs-comment"># 也能匹配成功</span><br></code></pre></td></tr></table></figure></li><li>&#x2F;s : 匹配任意字符</li></ol><p>   原来点号. 不能匹配换行符，现在也可以了<br>  3. &#x2F;x ：可以随便加入空白符</p><p>  为了便于阅读，可以在模式中随便加空白符。但是这样的原先模式中存在的空白符就没用了，得换成\s形式<br>  4. 还可以选择字符的解释方式 &#x2F;a &#x2F;u &#x2F;l</p><p>   但我不是很明白什么意思</p><p>  <strong>这几种模式修饰符可以同时使用</strong></p><h5 id="3-锚位"><a href="#3-锚位" class="headerlink" title="3. 锚位"></a><strong>3. 锚位</strong></h5><ol><li>开头结尾定位^ $ \A \Z</li></ol><p> <strong>perl5中</strong></p><p> \A匹配字符串的绝对开头，这个字符串中间可能有换行符。\z（小写）匹配字符串的绝对末尾，\Z（大写）也是匹配字符串绝对末尾，但是可以允许后面有换行符。</p><p> ^也是匹配字符串的开头，$匹配字符串的末尾。后面会讲可以用$和&#x2F;m对多行内容进行匹配，这时^匹配一行开头，$匹配一行结尾。</p><ol start="2"><li>单词定位 \b \b <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">$_ = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-regexp">m/ \babc\b /x</span>;  <span class="hljs-comment"># 匹配单词abc,</span><br>m/ \bab\b /<span class="hljs-keyword">x</span>;  <span class="hljs-comment"># 匹配失败，没有ab的单词，只有abc</span><br></code></pre></td></tr></table></figure></li></ol><h5 id="4-匹配成功会返回1"><a href="#4-匹配成功会返回1" class="headerlink" title="4. 匹配成功会返回1"></a><strong>4. 匹配成功会返回1</strong></h5><p>可以作为if语句的判断条件，比如下一小节中的例子。</p><h5 id="5-绑定操作符-x3D"><a href="#5-绑定操作符-x3D" class="headerlink" title="5.  绑定操作符 &#x3D;~"></a><strong>5.  绑定操作符 &#x3D;~</strong></h5><p> 前面的模式匹配都是自动匹配到默认变量$_上，现在可以指定要匹配的变量。<br> <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">$str = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-keyword">if</span>($str =~ <span class="hljs-regexp">m/ \babc\b /x</span>) <span class="hljs-comment"># 匹配$str变量中的abc</span><br>&#123;<span class="hljs-keyword">print</span> <span class="hljs-string">&quot;ok\n&quot;</span>;&#125;<br></code></pre></td></tr></table></figure></p><h5 id="6-模式中内插"><a href="#6-模式中内插" class="headerlink" title="6. 模式中内插"></a><strong>6. 模式中内插</strong></h5><p> 可以将模式内容先 保存在某个变量里，然后用在模式定界符内<br> <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl">$str = <span class="hljs-string">&quot;abc&quot;</span>;<br>$pattern = <span class="hljs-string">&quot;\babc\b&quot;</span>;<br><span class="hljs-keyword">if</span>($str =~ <span class="hljs-regexp">m/$pattern/x</span>)<br>&#123;<br>  <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;ok\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h5 id="7-捕获变量"><a href="#7-捕获变量" class="headerlink" title="7. 捕获变量"></a><strong>7. 捕获变量</strong></h5><p> 捕获变量是用来保存捕获组中捕获到的内容。</p><ol><li>默认的捕获变量</li></ol><p> 默认的捕获变量是$1,$2,这些，用来保存捕获组1，捕获组2，，中的内容，捕获组是第几个组是看左括号是第几个。<br> <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl">$str = <span class="hljs-string">&quot;hello world&quot;</span>;<br><span class="hljs-keyword">if</span>($str =~ <span class="hljs-regexp">m/ (\bhello\b)\s(\bworld\b) /x</span>)&#123;<br>  <span class="hljs-keyword">print</span> $1,<span class="hljs-string">&quot; &quot;</span>,$2;<br>  <span class="hljs-comment"># 第一个捕获组得到的内容存在$1,第二个存在$2，</span><br>  <span class="hljs-comment"># 打印输出 hello world</span><br>&#125;<br></code></pre></td></tr></table></figure></p><ol start="2"><li>捕获变量的生存期</li></ol><p> 这些捕获变量能够保存到下次捕获成功，也就是说如果匹配失败，不会改变上次匹配成功捕获的内容。<br> 3. 不捕获模式</p><p> 如果不想捕获某个捕获组中的内容，<strong>在这个组的左括号后加?:</strong><br> <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl">$str = <span class="hljs-string">&quot;hello world&quot;</span>;<br><span class="hljs-keyword">if</span>($str =~ <span class="hljs-regexp">m/ (?:\bhello\b)\s(\bworld\b) /x</span>)&#123;<br>  <span class="hljs-keyword">print</span> $1,<span class="hljs-string">&quot; &quot;</span>,$2;<br>  <span class="hljs-comment"># 第一个捕获组不捕获,第二个捕获到world存在变量$1，</span><br>  <span class="hljs-comment"># 打印输出 “world ”</span><br>  <span class="hljs-comment"># 变量$2没有内容</span><br>&#125;<br></code></pre></td></tr></table></figure><br> 4. 自己指定(命名)捕获变量  %+</p><p> perl5.10中增加了对捕获内容直接命名的方法，将捕获的内容存在一个哈希表中 %+,<strong>表中的键是认为设定的捕获变量，键对应的值是变量内容</strong>。</p><p> 比如这样一个捕获组——(?<LABEL>PATTERN) ，其中LABEL是定义的变量名，PATTERN是捕获组内容<br>  <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl">$str = <span class="hljs-string">&quot;hello world&quot;</span>;<br><span class="hljs-keyword">if</span>($str =~ <span class="hljs-regexp">m/ (?&lt;var1&gt;\bhello\b)\s(?&lt;var2&gt;\bworld\b) /x</span>)&#123;<br>  <span class="hljs-keyword">print</span> $+<span class="hljs-string">&#123;var1&#125;</span>,<span class="hljs-string">&quot; &quot;</span>,$+<span class="hljs-string">&#123;var2&#125;</span>;<br>  <span class="hljs-comment"># 第一个捕获组捕获hello保存在$var1,第二个捕获到world存在变量$var2，</span><br>  <span class="hljs-comment"># 打印输出 “hello world”</span><br>&#125;<br></code></pre></td></tr></table></figure></p><h5 id="8-通用量词"><a href="#8-通用量词" class="headerlink" title="8. 通用量词"></a><strong>8. 通用量词</strong></h5> <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">模式 m/a&#123;<span class="hljs-number">5</span>,<span class="hljs-number">10</span>&#125;/ 匹配<span class="hljs-number">5</span>到<span class="hljs-number">10</span>次字符a。<br></code></pre></td></tr></table></figure><h5 id="9-保存匹配的结果"><a href="#9-保存匹配的结果" class="headerlink" title="9. 保存匹配的结果"></a>9. 保存匹配的结果</h5><p>​    在对文件中的行循环匹配的时候，有的时候能匹配到，有的时候匹配不到，如果匹配到就会更新捕获变量，$1,$2或者自己定义的哈希对（<strong>这些变量都是只读的</strong>）。但如果没匹配到，那么这些变量不会改变，但我们不知道他到底有没有匹配到，可能匹配到了，但他的值跟上一次匹配的一样，那么这些变量还是没变，那怎么办呢？</p><p>​    所以在每次匹配的时候将匹配到的值保存出来，下一次匹配之前再清空他。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl">$str = <span class="hljs-string">&quot;hello world&quot;</span>；<br><span class="hljs-keyword">push</span> @res,($str =~ <span class="hljs-regexp">m/(hello)/</span>);<br><span class="hljs-keyword">print</span> $res[<span class="hljs-number">0</span>],<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-keyword">pop</span> @res;<br><span class="hljs-comment">###也可以</span><br>$str =~ <span class="hljs-regexp">m/(hello)/</span>;<br>$res[<span class="hljs-number">0</span>] = $1;<br><span class="hljs-keyword">print</span> $res[<span class="hljs-number">0</span>],<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-keyword">pop</span> @res;<br></code></pre></td></tr></table></figure><h4 id="四、正则表达式处理文本"><a href="#四、正则表达式处理文本" class="headerlink" title="四、正则表达式处理文本"></a>四、正则表达式处理文本</h4><h5 id="1-用-s-x2F-x2F-x2F-进行替换"><a href="#1-用-s-x2F-x2F-x2F-进行替换" class="headerlink" title="1. 用 s&#x2F;&#x2F;&#x2F; 进行替换"></a><strong>1. 用 s&#x2F;&#x2F;&#x2F; 进行替换</strong></h5><p><strong>查找并替换</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">$str = <span class="hljs-string">&quot;bob is a boy\n&quot;</span>;<br>$str =~ <span class="hljs-regexp">s/bob/john/</span>; <span class="hljs-comment"># 匹配到bob，并用john替换</span><br><span class="hljs-keyword">print</span> $str; <span class="hljs-comment"># john is a boy</span><br></code></pre></td></tr></table></figure><p><strong>&#x2F;g进行全局替换，全部都替换</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">$str = <span class="hljs-string">&quot;bob is a boy,bob is a student\n&quot;</span>;<br>$str =~ <span class="hljs-regexp">s/bob/john/</span>;<br><span class="hljs-keyword">print</span> $str; <span class="hljs-comment"># john is a boy,bob is a student 只替换了一个john</span><br></code></pre></td></tr></table></figure><p>而</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">$str = <span class="hljs-string">&quot;bob is a boy,bob is a student\n&quot;</span>;<br>$str =~ <span class="hljs-regexp">s/bob/john/g</span>;<br><span class="hljs-keyword">print</span> $str; <span class="hljs-comment"># john is a boy,john is a student 两个都替换</span><br></code></pre></td></tr></table></figure><p>** 也可以 s###,等其他的定界符**</p><p><strong>大小写转换</strong><br>\U全部大写 \L全部小写</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">$str = <span class="hljs-string">&quot;bob is a boy,bob is a student\n&quot;</span>;<br> $str =~ <span class="hljs-regexp">s/(bob)/\U$1/g</span>; <span class="hljs-comment"># 原子匹配到的结果还是默认存在$1,$2中</span><br> <span class="hljs-keyword">print</span> $str; <span class="hljs-comment"># BOB is a boy,BOB is a student 大写</span><br></code></pre></td></tr></table></figure><h5 id="2-split操作符"><a href="#2-split操作符" class="headerlink" title="2. split操作符"></a><strong>2. split操作符</strong></h5><p>split操作符，根据字符将字符串分成多组，返回一个数组保存结果</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">$str = <span class="hljs-string">&quot;hello world&quot;</span>;<br>@res = <span class="hljs-keyword">split</span> <span class="hljs-string">&quot; &quot;</span>,$str; <span class="hljs-comment"># 以空格为界切分$str,数组@res保存结果</span><br><span class="hljs-keyword">print</span> $res[<span class="hljs-number">0</span>],<span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment"># hello</span><br></code></pre></td></tr></table></figure><p> split默认以空白符切分变量$_<br> <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">$_str_ = <span class="hljs-string">&quot;hello world&quot;</span>;<br>@res = <span class="hljs-keyword">split</span>; <span class="hljs-comment"># 以空格为界切分$_,数组@res保存结果</span><br><span class="hljs-keyword">print</span> $res[<span class="hljs-number">0</span>],<span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment"># hello</span><br></code></pre></td></tr></table></figure></p><h5 id="3-join函数"><a href="#3-join函数" class="headerlink" title="3. join函数"></a><strong>3. join函数</strong></h5><p> 与split相反的作用，将多个字符串连接起来<br>  <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"> $str = <span class="hljs-string">&quot;hello world&quot;</span>;<br>@res = <span class="hljs-keyword">split</span> <span class="hljs-string">&quot; &quot;</span>,$str;<br><span class="hljs-keyword">print</span> $res[<span class="hljs-number">0</span>],<span class="hljs-string">&quot;\n&quot;</span>;<br>$str =  <span class="hljs-keyword">join</span> <span class="hljs-string">&quot;+&quot;</span>,@res;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;$str\n&quot;</span>;  <span class="hljs-comment"># hello+world</span><br></code></pre></td></tr></table></figure><br>** join函数连接的列表至少要有两个元素**</p><h5 id="4-列表上下文中的m-x2F-x2F"><a href="#4-列表上下文中的m-x2F-x2F" class="headerlink" title="4. 列表上下文中的m&#x2F;&#x2F;"></a><strong>4. 列表上下文中的m&#x2F;&#x2F;</strong></h5><p> 如果m&#x2F;&#x2F;使用的上下文是列表环境，那么m&#x2F;&#x2F;将匹配到的所有内容返回成列表<br> <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"> $str = <span class="hljs-string">&quot;A good day&quot;</span>;<br><span class="hljs-keyword">my</span> ($first,$second,$third) = $str =~ <span class="hljs-regexp">m/ (\S+)\s(\S+)\s(\S+) /x</span>;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;$first+$second+$third\n&quot;</span>;<br><span class="hljs-comment">## 输出 A+good+day</span><br><span class="hljs-comment">## 将各个捕获组的内容保存到列表中的变量里</span><br></code></pre></td></tr></table></figure></p><h5 id="5-跨行的模式匹配-x2F-m"><a href="#5-跨行的模式匹配-x2F-m" class="headerlink" title="**5. 跨行的模式匹配 &#x2F;m **"></a>**5. 跨行的模式匹配 &#x2F;m **</h5><p>假如有一个文件program.log内容如下.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">first line<br>second line<br>third line<br></code></pre></td></tr></table></figure><p>读取文件内容并修改：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">open</span> CMD,<span class="hljs-string">&quot;&lt; command.log&quot;</span>;<br>$line = <span class="hljs-keyword">join</span> <span class="hljs-string">&quot;&quot;</span>,&lt;CMD&gt;; <span class="hljs-comment"># 将文件的所有内容读取到一个变量里</span><br><span class="hljs-comment">#$line = &lt;CMD&gt;; # 这样写只能读取第一行内容</span><br>$line =~ <span class="hljs-regexp">s/^/command.log: /gm</span>; <span class="hljs-comment">#每一行加上文件名</span><br><span class="hljs-keyword">print</span> $line; <span class="hljs-comment"># 输出修改后的内容</span><br><span class="hljs-keyword">close</span> CMD;<br><span class="hljs-keyword">open</span> CMD,<span class="hljs-string">&quot;&gt; com.log&quot;</span>;<br><span class="hljs-keyword">print</span> CMD $line; <span class="hljs-comment"># 将修改后的内容保存到另一个文件中</span><br>  <span class="hljs-comment">## print后的文件标识符和$line之间没有逗号</span><br><span class="hljs-keyword">close</span> $CMD;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">command</span>.<span class="hljs-built_in">log</span>: <span class="hljs-keyword">first</span> <span class="hljs-built_in">line</span><br><span class="hljs-keyword">command</span>.<span class="hljs-built_in">log</span>: second <span class="hljs-built_in">line</span><br><span class="hljs-keyword">command</span>.<span class="hljs-built_in">log</span>: third <span class="hljs-built_in">line</span><br></code></pre></td></tr></table></figure><p>com.log文件的内容：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">command</span>.<span class="hljs-built_in">log</span>: <span class="hljs-keyword">first</span> <span class="hljs-built_in">line</span><br><span class="hljs-keyword">command</span>.<span class="hljs-built_in">log</span>: second <span class="hljs-built_in">line</span><br><span class="hljs-keyword">command</span>.<span class="hljs-built_in">log</span>: third <span class="hljs-built_in">line</span><br></code></pre></td></tr></table></figure><p>如果不加\m，那么com.log中的内容为：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">command.<span class="hljs-built_in">log</span>: <span class="hljs-keyword">first</span> <span class="hljs-built_in">line</span> <br><span class="hljs-keyword">second</span> <span class="hljs-built_in">line</span><br><span class="hljs-keyword">third</span> <span class="hljs-built_in">line</span><br></code></pre></td></tr></table></figure><h5 id="6-一次更新多个文件-I变量"><a href="#6-一次更新多个文件-I变量" class="headerlink" title="6. 一次更新多个文件  $^I变量**"></a>6. 一次更新多个文件  $^I变量**</h5><p>对于一个文件command.log内容如下：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">author:</span> li<br><span class="hljs-symbol">date:</span> <span class="hljs-number">123</span><br><span class="hljs-symbol">phone:</span> <span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><p>我们想将author改成dong yk，日期设为当前日期，去掉phone那行。</p><p>脚本如下：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs perl">$time = <span class="hljs-keyword">localtime</span>; <span class="hljs-comment">#perl自己的函数，返回当前时间</span><br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;$time\n&quot;</span>;<br>$^I = <span class="hljs-string">&quot;.dat&quot;</span>;<br><span class="hljs-keyword">while</span>(&lt;&gt;) <span class="hljs-comment"># 主程序一次读取、更行及输出一行</span><br>&#123;<br>  <span class="hljs-regexp">s/^author:.*/author: dong yk/</span>; <span class="hljs-comment"># 替换</span><br>  s/^date:.*<span class="hljs-regexp">/date: $time/</span>;<br>  <span class="hljs-regexp">s/^phone:.*\n//</span>; <span class="hljs-comment"># 删除，包括换行符</span><br>  <span class="hljs-keyword">print</span>; <span class="hljs-comment"># 钻石操作符把默认输出设定为打开的文件，print将输出内容写进文件</span><br>&#125;<br></code></pre></td></tr></table></figure><p>钻石操作符&lt;&gt;会读取命令行参数指定的文件的内容。**$^I变量和&lt;&gt;同时使用，**在&lt;&gt;打开文件的时候会将原来文件复制一份，这个文件以$^I变量内容为后缀。</p><p><strong>必须要设置$^I变量，要不然print输出到控制台，因为&lt;&gt;读取的内容默认存在$_中，print默认输出$_的值</strong></p><h5 id="7-从命令行直接编辑"><a href="#7-从命令行直接编辑" class="headerlink" title="7. 从命令行直接编辑"></a><strong>7. 从命令行直接编辑</strong></h5><p>假如有一个文件program.log内容如下.</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">first</span> <span class="hljs-built_in">line</span><br><span class="hljs-keyword">second</span> <span class="hljs-built_in">line</span><br><span class="hljs-keyword">third</span> <span class="hljs-built_in">line</span><br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">perl -<span class="hljs-selector-tag">p</span> -<span class="hljs-selector-tag">i</span><span class="hljs-selector-class">.bak</span> -w -e <span class="hljs-string">&#x27;s/line/LINE/&#x27;</span> command.log<br></code></pre></td></tr></table></figure><p>program.log文件内容变成：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">first</span> LINE<br><span class="hljs-keyword">second</span> LINE<br><span class="hljs-keyword">third</span> LINE<br></code></pre></td></tr></table></figure><p>-p : 让perl生成一段小程序</p><p>-i ：功能类似$^I变量，以自定义的后缀保存源文件，这里的是.bak后缀</p><p>-w：开启警告</p><p>-e ：告诉perl后面跟着可执行程序</p>]]></content>
    
    
    <categories>
      
      <category>script</category>
      
      <category>perl</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>perl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Anaconda使用</title>
    <link href="/2019/05/14/others/Anaconda%E4%BD%BF%E7%94%A8/"/>
    <url>/2019/05/14/others/Anaconda%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="DOS环境启动anaconda运行python程序"><a href="#DOS环境启动anaconda运行python程序" class="headerlink" title="DOS环境启动anaconda运行python程序"></a>DOS环境启动anaconda运行python程序</h4><p>Anaconda环境下有好多python的包，也可以自己手动安装<code>conda install package_name</code>。很方便。</p><ol><li>先下载安装好Anaconda</li><li>在系统path环境下添加Anaconda文件夹下Scripts文件路径</li><li>在window系统的DOS环境下，键入activate就能启动anaconda</li><li>通过Anaconda安装软件，<code>conda install python</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>others</category>
      
    </categories>
    
    
    <tags>
      
      <tag>others</tag>
      
      <tag>AI</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git命令行中键入python卡住</title>
    <link href="/2019/05/14/tools/git/git%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E9%94%AE%E5%85%A5python%E5%8D%A1%E4%BD%8F/"/>
    <url>/2019/05/14/tools/git/git%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E9%94%AE%E5%85%A5python%E5%8D%A1%E4%BD%8F/</url>
    
    <content type="html"><![CDATA[<p>打开git bash，键入python，命令行冻结，没有任何提示信息。</p><p>解决：**给Python命令添加别名 winpy python.exe</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> ~<br>vim <span class="hljs-string">.bashrc</span><br></code></pre></td></tr></table></figure><p>在.bashrc中加一行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">alias</span> python=<span class="hljs-string">&#x27;winpy python.exe&#x27;</span>   <span class="hljs-comment">#等号两边没有空格</span><br></code></pre></td></tr></table></figure><p><strong>如果不用上面的方法，直接输入 python -i 也可以</strong></p><p>退出python：</p><p><strong>quit()</strong>  或者  <strong>exit()</strong></p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中的virtual概念</title>
    <link href="/2019/05/01/C++/C++%E4%B8%AD%E7%9A%84virtual%E6%A6%82%E5%BF%B5/"/>
    <url>/2019/05/01/C++/C++%E4%B8%AD%E7%9A%84virtual%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>此虚非彼虚</strong></p></blockquote><h5 id="0-目录"><a href="#0-目录" class="headerlink" title="0. 目录"></a>0. 目录</h5><ol><li>虚函数</li><li>纯虚函数和抽象基类</li><li>虚析构函数</li><li>虚函数和类作用域</li></ol><h5 id="1-虚函数"><a href="#1-虚函数" class="headerlink" title="1. 虚函数"></a>1. 虚函数</h5><p>在类的继承中引入虚函数(virtual function)的概念。如果基类中定义了虚成员函数，在派生类中可以为该函数定义派生类自己的版本。</p><p><strong>注意：</strong></p><ol><li>基类中的虚成员函数声明时加virtual关键字，但是如果虚函数在类外定义则<strong>不能加virtual关键字</strong>。</li><li>派生类中对应的函数可以不加virtual关键字，但派生类中的函数也是虚函数，即使没有virtual关键字，它的虚属性从基类中继承过来了。</li><li>要求派生类中定义的函数与基类中对应的<strong>函数的类型相同</strong>——返回类型、函数名、参数等。<strong>有个例外如果基类中函数返回值类型是基类，那么允许派生类中对应的函数的返回值类型是派生类类型。</strong></li><li>如果函数类型不一致，不能看成是派生类对基类函数的改写(override)，而是看成重载，那么派生类中的函数会覆盖基类中的函数。</li><li><strong>override：</strong>在<strong>派生类中显示定义</strong>，这个函数是改写基类中的函数.override写在参数列表或者const关键字之后。</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">child:<span class="hljs-symbol">public</span></span> <span class="hljs-symbol">parent</span>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">void</span> func1() <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span>; <span class="hljs-comment">//可以不加virtual关键字</span><br>    <span class="hljs-built_in">void</span> func2() <span class="hljs-keyword">override</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="6"><li><strong>final：</strong>该关键字用在<strong>基类成员函数上</strong>，显式声明这个函数不能在派生类中改写。<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">child:<span class="hljs-symbol">public</span></span> <span class="hljs-symbol">parent</span>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">void</span> func1() <span class="hljs-keyword">const</span> <span class="hljs-keyword">final</span>;<br>    <span class="hljs-built_in">void</span> func2() <span class="hljs-keyword">final</span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><p><strong>成员函数如果没有定义成虚函数，那么函数解析发生在编译阶段；而虚函数的解析发生在运行时，也就是</strong>动态绑定<strong>，也叫</strong>运行时绑定<strong>。</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">T1</span> &#123;<br><span class="hljs-keyword">public</span>:<br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span>()</span> &#123; cout &lt;&lt; <span class="hljs-string">&quot;this is T1 &quot;</span> &lt;&lt; endl; &#125; <span class="hljs-comment">//基类中要被继承的成员函数没有定义成virtual类型</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title">T2</span> :<span class="hljs-title">public</span> <span class="hljs-title">T1</span> &#123; <span class="hljs-comment">//T1继承T2</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span>()</span> &#123; cout &lt;&lt; <span class="hljs-string">&quot;this is T2&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showT1</span>(<span class="hljs-params">T1&amp; t</span>)</span> &#123; <span class="hljs-comment">//参数是基类对象的引用，可以接受派生类对象</span><br>t.show();  <span class="hljs-comment">//因为show()函数不是虚函数，所以在编译时将类T1的show()函数绑定给对象t1。</span><br>&#125;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> argc,<span class="hljs-built_in">char</span>** argv</span>)</span><br>&#123;<br>T1 t1;<br>T2 t2;<br>showT1(t1);<br>showT1(t2);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> T1<br><span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> T1<br></code></pre></td></tr></table></figure><p>从上面输出可以看出两个showT1()函数调用的都是基类对象的show()函数，这是因为基类中的show()函数不是虚函数，则在函数showT1()中的show()函数在编译阶段进行解析，解析成基类对象t的show()函数。</p><p><strong>当虚函数通过引用或者指针调用时，编译器产生的代码到运行时才能确定调用那个版本的函数</strong></p><p>将基类中的show()函数定义成虚函数，加上<strong>virtual</strong>关键字</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">T1</span> &#123;<br><span class="hljs-keyword">public</span>:<br> <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span>()</span> &#123; cout &lt;&lt; <span class="hljs-string">&quot;this is T1 &quot;</span> &lt;&lt; endl; &#125; <span class="hljs-comment">//基类中要被继承的成员函数定义成virtual类型</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title">T2</span> :<span class="hljs-title">public</span> <span class="hljs-title">T1</span> &#123; <span class="hljs-comment">//T1继承T2</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span>()</span> &#123; cout &lt;&lt; <span class="hljs-string">&quot;this is T2&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showT1</span>(<span class="hljs-params">T1&amp; t</span>)</span> &#123; <span class="hljs-comment">//参数是基类对象的引用，可以接受派生类对象</span><br>t.show();  <span class="hljs-comment">//因为show()函数是虚函数，所以在运行阶段才能确定show()函数的版本——根据对象t的类型</span><br>&#125;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> argc,<span class="hljs-built_in">char</span>** argv</span>)</span><br>&#123;<br>T1 t1;<br>T2 t2;<br>showT1(t1);<br>showT1(t2);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> T1<br><span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> T2<br></code></pre></td></tr></table></figure><p><strong>可以将共有派生类对象绑定到基类对象的引用或者指针上</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">T1</span> &#123;<br><span class="hljs-keyword">public</span>:<br> <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span>()</span> &#123; cout &lt;&lt; <span class="hljs-string">&quot;this is T1 &quot;</span> &lt;&lt; endl; &#125; <span class="hljs-comment">//基类中要被继承的成员函数定义成virtual类型</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title">T2</span> :<span class="hljs-title">public</span> <span class="hljs-title">T1</span> &#123; <span class="hljs-comment">//T1继承T2</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span>()</span> &#123; cout &lt;&lt; <span class="hljs-string">&quot;this is T2&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showT1</span>(<span class="hljs-params">T1 t</span>)</span> &#123; <span class="hljs-comment">//参数是基类对象</span><br>t.show();  <span class="hljs-comment">//因为show()函数是虚函数，所以在运行阶段才能确定show()函数的版本——根据对象t的类型</span><br>&#125;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> argc,<span class="hljs-built_in">char</span>** argv</span>)</span><br>&#123;<br>T1 t1;<br>T2 t2;<br>showT1(t1);<br>showT1(t2);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> T1<br><span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> T1 <span class="hljs-comment">//这里调用的是基类对象的show()函数</span><br></code></pre></td></tr></table></figure><p>这里将showT1()的参数定义成基类对象，而不是引用或者指针，这样在调用showT1()函数时，如果参数是派生类，会将派生类对象转换成基类对象，这样在showT1(t2)调用的是基类的show()函数。</p><h5 id="2-纯虚函数和抽象基类"><a href="#2-纯虚函数和抽象基类" class="headerlink" title="2. 纯虚函数和抽象基类"></a>2. 纯虚函数和抽象基类</h5><p>纯虚函数无须定义，如下所示。当然也可以为其定义，但是必须在类外。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">parent</span>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span>() <span class="hljs-keyword">const</span></span> =<span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>含有纯虚函数的类是抽象基类</strong>，抽象基类负责定义接口，而它的派生类覆盖这些接口。</p><p><strong>不能为抽象基类创建对象</strong></p><h5 id="3-虚析构函数"><a href="#3-虚析构函数" class="headerlink" title="3. 虚析构函数"></a>3. 虚析构函数</h5><p><strong>通常基类中的析构函数定义成虚析构函数。</strong>这是为了确保对象能够正确析构。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    virtual ~Base()=<span class="hljs-literal">default</span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base&#123;<br>  <span class="hljs-keyword">public</span>:<br>    ~ Derived()=<span class="hljs-literal">default</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>有的时候我们将Base*类型绑定到Derived派生类对象上，释放派生类对象时需要执行派生类对象自己版本的析构函数，所以要将基类的析构函数定义成虚函数。</p><p><strong>析构函数的属性会被继承</strong></p><h5 id="4-虚函数和类作用域"><a href="#4-虚函数和类作用域" class="headerlink" title="4. 虚函数和类作用域"></a>4. 虚函数和类作用域</h5><p>前文中讲了派生中的虚函数要和基类中的虚函数参数列表一致，这是因为在使用<strong>将基类对象的指针或引用绑定到派生类对象上</strong>这个规则的时候，对象的<strong>静态对象（变量声明时决定的）</strong>和<strong>动态对象（运行时决定）</strong>是不同的，静态对象是基类类型，动态对象是派生类类型。虚函数是动态类型绑定，所以即使将派生类对象绑定到了基类的引用或指针上，虚函数的对象类型依旧是派生类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">memfun</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">memfun</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<span class="hljs-comment">//参数类型不一致</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Base&amp;)</span></span>; <span class="hljs-comment">//参数是基类的引用</span><br>Derived d;Base b;<br>b.<span class="hljs-built_in">memfun</span>();<span class="hljs-comment">// 调用Base的memfun()函数</span><br>d.<span class="hljs-built_in">memfun</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//调用Derived的memfun(int)函数</span><br>d.<span class="hljs-built_in">memfun</span>();<span class="hljs-comment">//错误，Derived没有memfun()这个函数</span><br>d.Base::<span class="hljs-built_in">memfun</span>();<span class="hljs-comment">//正确，调用Base::memfun()</span><br><span class="hljs-built_in">test</span>(b); <span class="hljs-comment">//调用Base的memfun()函数</span><br><span class="hljs-built_in">test</span>(d);<span class="hljs-comment">//错误，Derived没有memfun()这个函数</span><br></code></pre></td></tr></table></figure><p><strong>派生类的作用域在基类作用域内</strong>。根据上面的自理，<strong>在编译阶段现在派生类作用域内按名字查找函数名memfun，</strong>找到memfun(int)函数，停止查找，但对于基类对象引用或指针，他没有memfun(int)这个函数，所以test(d)语句会报错。</p><p><strong>事实上派生类中的memfun(int)函数隐藏了基类中的memfun()函数。</strong></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关联容器map-pair-set</title>
    <link href="/2019/05/01/C++/%E5%AE%B9%E5%99%A8/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8map-pair-set/"/>
    <url>/2019/05/01/C++/%E5%AE%B9%E5%99%A8/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8map-pair-set/</url>
    
    <content type="html"><![CDATA[<p><strong>关联容器支持关键字查找和访问</strong>，主要有<strong>map</strong>和<strong>set</strong>这两种关键字。</p><p>map中的元素是关键字-值(key-value)对，map是有序的容器，元素的排序按照每个元素中的关键字排序。关键字起到索引作用，值是关键字对应的数据。</p><p>set中的元素只有关键字，set支持查询作用——检索某些内容是否在容器内。</p><p>除了map,set外还有mulimap,muliset,以及对应这四种的无序形式unordered_map,unordered_set, unordered_mulimap,unordered_muliset,这里不介绍这六种。</p><p><a href="http://www.cplusplus.com/reference/map/">参考 CPLUSPLUS网站</a></p><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><h5 id="1-创建map"><a href="#1-创建map" class="headerlink" title="1 创建map"></a>1 创建map</h5><p>map是模板类，形如 map&lt;T1,T2&gt;</p><figure class="highlight perl"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">map</span>&lt;string, <span class="hljs-keyword">int</span>&gt; mp = &#123; &#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">2</span>&#125; &#125;;<br><span class="hljs-regexp">//</span> 这里定义的一个<span class="hljs-keyword">map</span>对象mp，它的关键字类型是string，值类型<span class="hljs-keyword">int</span>。<br>用三个元素对它进行初始化。<br></code></pre></td></tr></table></figure><p><strong>注意：： 对上面对象mp初始化中三个元素的顺序是{“a”,1},{“d”,4}, {“b”,2}，但是因为map是有序容器，按照关键字排序，实际中mp中元素索引顺序是{“a”,1},{“b”,2}，{“d”,4}</strong></p><h5 id="2-索引-x2F-遍历map"><a href="#2-索引-x2F-遍历map" class="headerlink" title="2 索引&#x2F;遍历map"></a>2 索引&#x2F;遍历map</h5><p>map中的元素其实是<strong>pair</strong>类型。pair是用来生成特定类型的模板，他的格式是<strong>pair&lt;T1,T2&gt;</strong>,需要给它提供两个模板类型。每一个pair对象都是map中的一个键值对。</p><p>pair类型有first，second两个成员，分别表示pair中第一个和第二个值，也就对应关键字-值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">pair&lt;string,<span class="hljs-type">int</span>&gt; <span class="hljs-title">pr1</span><span class="hljs-params">(<span class="hljs-string">&quot;egg&quot;</span>,<span class="hljs-number">1</span>)</span></span>;<br>pair&lt;string,<span class="hljs-type">int</span>&gt; pr2 = &#123;<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-number">1</span>&#125;;<br><span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;apple&quot;</span>,<span class="hljs-number">1</span>);<span class="hljs-comment">//返回与参数类型相对应的pair元素</span><br></code></pre></td></tr></table></figure><p>** ********   下面介绍元素的遍历  ********** **</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 用for循环遍历</span><br>map&lt;string, <span class="hljs-type">int</span>&gt; mp = &#123; &#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">2</span>&#125; &#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;w : mp) &#123;<br>cout &lt;&lt; w.first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; w.second &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">// 用迭代器遍历</span><br><span class="hljs-keyword">auto</span> map_it = mp.<span class="hljs-built_in">begin</span>();<br><span class="hljs-comment">// map&lt;string, int&gt;::iterator map_it = mp.begin();</span><br><span class="hljs-keyword">while</span> (map_it != mp.<span class="hljs-built_in">cend</span>()) &#123;<br>cout &lt;&lt; map_it-&gt;first &lt;&lt; <span class="hljs-string">&quot;-&quot;</span> &lt;&lt; map_it-&gt;second &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>map_it++;<br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>-<span class="hljs-number">1</span> b-<span class="hljs-number">2</span> d-<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h5 id="3-插入元素"><a href="#3-插入元素" class="headerlink" title="3 插入元素"></a>3 插入元素</h5>  <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">mp.<span class="hljs-built_in">insert</span>(pair&lt;string, int&gt;(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>));<br>mp.<span class="hljs-built_in">insert</span>(make_pair(<span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-number">5</span>));<br><span class="hljs-comment">//也可以简单粗暴的方法</span><br>  mp[<span class="hljs-string">&quot;f&quot;</span>] = <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure><p>  <strong>注意：</strong></p><p> 通过insert函数插入元素时，如果新插入的元素的关键字在map中已经有了，那么不会插入。比如上边再执行<code>mp.insert(make_pair(&quot;e&quot;,10));</code>map中”e”关键字的值还是5.</p><p> 但是通过<code>mp[&quot;e&quot;] = 10;</code>这种方法插入e的值改为10</p><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">set&lt;<span class="hljs-type">int</span>&gt; s = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">12</span>,<span class="hljs-number">45</span>,<span class="hljs-number">23</span>,<span class="hljs-number">5</span> &#125;;<br>set&lt;<span class="hljs-type">int</span>&gt;::iterator set_it = s.<span class="hljs-built_in">cbegin</span>();<br><span class="hljs-keyword">while</span> (set_it != s.<span class="hljs-built_in">cend</span>()) &#123;<br>cout &lt;&lt; *set_it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>set_it++;<br>&#125;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">12</span> <span class="hljs-number">23</span> <span class="hljs-number">45</span><br><span class="hljs-regexp">//</span>输出按照大小排序<br></code></pre></td></tr></table></figure><p><strong>对于关联容器的其他操作，比如insert，find，erase,size,empty等见CPLUSPLUS网站</strong></p><p><a href="http://www.cplusplus.com/reference/map/map/">CPLUSPLUC</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gcc编译常用命令</title>
    <link href="/2019/04/30/C++/gcc%E7%BC%96%E8%AF%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2019/04/30/C++/gcc%E7%BC%96%E8%AF%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/ggjucheng/archive/2011/12/14/2287738.html"><strong>参考</strong></a></p><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>GCC 的意思也只是 GNU C Compiler 而已。经过了这么多年的发展，GCC 已经不仅仅能支持 C 语言；它现在还支持 Ada 语言、C++ 语言、Java 语言、Objective C 语言、Pascal 语言、COBOL语言，以及支持函数式编程和逻辑编程的 Mercury 语言，等等。而 GCC 也不再单只是 GNU C 语言编译器的意思了，而是变成了 GNU Compiler Collection 也即是 GNU 编译器家族的意思了。另一方面，说到 GCC 对于操作系统平台及硬件平台支持，概括起来就是一句话：无所不在。</p><h5 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h5><p>下面一个代码例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// file name : main.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is a  test!\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一步到位的编译</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">gcc -o <span class="hljs-selector-tag">main</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span><br></code></pre></td></tr></table></figure><p><strong>其实编译分成四步：预处理（也叫预编译，preprocessing)、编译(compilation)、汇编(assembly)、链接(linking)</strong></p><h5 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h5><p>在预处理阶段会将**#include<strong>的文件都包含到当前文件，上面例子中时间stdio.h文件中的内容包含进来，并且将</strong>define<strong>宏定义都进行替换。但注意</strong>typedef**类型定义不变。</p><p>指令如下，用**-E**选项</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc -E <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> -o <span class="hljs-selector-tag">main</span>.i<br></code></pre></td></tr></table></figure><h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><p>编译生成<strong>汇编代码</strong> ，用-S选项，如下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc -E <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.i</span> -o <span class="hljs-selector-tag">main</span>.s<br></code></pre></td></tr></table></figure><h5 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h5><p>这个阶段，将汇编文件生成目标文件</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc -c <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.s</span> -o <span class="hljs-selector-tag">main</span>.o<br></code></pre></td></tr></table></figure><h5 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h5><p>gcc连接器是gas提供的，负责将程序的目标文件与所需的所有附加的目标文件连接起来，最终生成可执行文件。附加的目标文件包括静态连接库和动态连接库。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">gcc -o <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> -o <span class="hljs-selector-tag">main</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据依赖RAW WAW WAR</title>
    <link href="/2019/04/30/IC/CPU/%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96RAW%20WAW%20WAR/"/>
    <url>/2019/04/30/IC/CPU/%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96RAW%20WAW%20WAR/</url>
    
    <content type="html"><![CDATA[<p><strong>本文是作者在学习过程中的理解，所以很可能存在不全面或者错误</strong></p><p>本文参考了<a href="https://blog.csdn.net/leishangwen/article/details/38298787">自己动手写CPU之第五阶段（1）——流水线数据相关问题</a>和<a href="http://www.techbulo.com/1963.html">cpu乱序原理</a></p><p>CPU指令中的相关性包括<strong>数据相关性，结构（资源）相关性和控制相关性</strong>。</p><p><strong>数据相关性</strong>：CPU基于流水线执行，在执行指令时，上一条指令没有执行完就要开始接下来指令的执行，如果当前指令中的操作数来源于上一条指令的执行结果，那么就会产生数据依赖。</p><p><strong>资源相关性</strong>：CPU内的硬件资源是有限的。所谓资源相关，是指多条指令进入流水线后在同一机器周期内争用同一个功能部件所发生的冲突。</p><p><strong>控制相关性</strong>：由于跳转指令引起指令跳转。CPU遇到跳转指令可能不跳转接着执行吓一跳指令；但如果跳转到其他的指令，PC值会由跳转指令执行结果而定，这会冲刷流水线。</p><p>这里只整理<strong>数据相关性</strong>内容。</p><hr><p>数据依赖性主要有三种RAW（写后读依赖）、WAR（读后写依赖）、WAW（写后写依赖）。</p><p><strong>RAW</strong>：Read After Write，假设指令j是在指令i后面执行的指令，RAW表示指令i将数据写入寄存器后，指令j才能从这个寄存器读取数据。如果指令j在指令i写入寄存器前尝试读出该寄存器的内容，将得到不正确的数据。</p><p>** WAR**：Write After Read，假设指令j是在指令i后面执行的指令，WAR表示指令i读出数据后，指令j才能写这个寄存器。如果指令j在指令i读出数据前就写该寄存器，将使得指令i读出的数据不正确。</p><p> <strong>WAW</strong>：Write After Write，假设指令j是在指令i后面执行的指令，WAW表示指令i将数据写入寄存器后，指令j才能将数据写入这个寄存器。如果指令j在指令i之前写该寄存器，将使得该寄存器的值不是最新值。</p><h5 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h5><p>对于5级流水线结构的CPU，取址、译码、执行、访存和写回。顺序执行的指令写寄存器实在写回阶段，后续的指令也是在写回阶段写寄存器，所以不存在WAW依赖。读寄存器实在译码阶段进行，而写寄存器实在写回阶段，所以不存在WAR依赖。<strong>只存在RAW依赖</strong>，这是因为读的数据是写操作执行完成写回寄存器操作后读的数据，必须等到前面的数据写回。</p><figure class="highlight armasm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">ADD</span> <span class="hljs-built_in">r1</span>,<span class="hljs-built_in">r2</span>,<span class="hljs-built_in">r3</span><br><span class="hljs-keyword">SUB</span> <span class="hljs-built_in">r4</span>,<span class="hljs-built_in">r5</span>,<span class="hljs-built_in">r1</span>     指令需要读取上一条指令的结果<br></code></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">流水线：<br><span class="hljs-keyword">ADD</span>       取指 译码 执行 访存 写回<br><span class="hljs-keyword">SUB</span>            取指 译码 执行 访存 写回<br></code></pre></td></tr></table></figure><p>SUB指令在“译码”阶段读取r1寄存器的值，但这时ADD指令还没有写回。</p><p><strong>解决RAW方法</strong></p><ol><li><p>添加空的周期</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">流水线：<br><span class="hljs-keyword">ADD</span>       取指 译码  执行  访存  写回<br>SUB            取指 <span class="hljs-keyword">empty</span> <span class="hljs-keyword">empty</span> 译码 执行 访存 写回<br></code></pre></td></tr></table></figure></li><li><p>编译器对指令进行调度</p></li></ol><p> 编译器将SUB指令之后的不与ADD、SUB两条指令存在相关性的指令添加到ADD和SUB这两条存在数据依赖的指令中间。这样执行效率不高。<br> <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm"> 编译器调度后的指令：<br><span class="hljs-keyword">ADD</span> <span class="hljs-built_in">r1</span>,<span class="hljs-built_in">r2</span>,<span class="hljs-built_in">r3</span><br>指令<span class="hljs-number">1</span><br>指令<span class="hljs-number">2</span><br><span class="hljs-keyword">SUB</span> <span class="hljs-built_in">r4</span>,<span class="hljs-built_in">r5</span>,<span class="hljs-built_in">r1</span>     指令需要读取上一条指令的结果<br></code></pre></td></tr></table></figure></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm">编译器调度之后的流水线：<br><span class="hljs-keyword">ADD</span>       取指 译码 执行 访存 写回<br>指令<span class="hljs-number">1</span>          取指 译码 执行 访存 写回<br>指令<span class="hljs-number">2</span>               取指 译码 执行 访存 写回<br><span class="hljs-keyword">SUB</span>                     取指 译码 执行 访存 写回<br></code></pre></td></tr></table></figure><ol start="3"><li>数据前推（数据旁路缓冲器）</li></ol><p>  （<strong>假设在执行阶段就能得到计算结果</strong>）。通过旁路缓冲器将执行阶段的结果直接给到下一条指令的译码阶段。这样就不需要等到写回寄存器。这要效率高，但是需要额外的复杂逻辑。<br>  <figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">流水线：<br><span class="hljs-keyword">ADD</span>       取指 译码 执行 访存 写回<br><span class="hljs-keyword">SUB</span><br></code></pre></td></tr></table></figure></p><hr><h5 id="乱序执行"><a href="#乱序执行" class="headerlink" title="乱序执行"></a>乱序执行</h5><p>由于访存、浮点运算等指令时间长，会阻塞流水线。乱序执行就是不必等前面的指令执行完就开始执行接下来的指令。乱序执行中的数据依赖三种都有：<strong>WAW,RAW,WAR</strong></p><p>乱序执行采用了如下图所示的保留站（Reservation Station ）这种类似于接待室的设施。</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/04/data_dependency1.png"></p><p>解码单元解码后的指令不是直接送到流水线，而是根据各自的指令种类，将解码后的指令送往各自的保留站中保存下来。如果操作数位于寄存器中，就把操作数从寄存器中读出来，和指令一起放入保留站。相反，如果操作数还在由前面的指令进行计算，那么就把那条指令的识别信息保存下来。</p><p>然后，保留站把操作数齐备、可执行的指令依次送到流水线进行运算。即使指令位于前面，如果操作数没准备好，也不能开始执行，所以保留站中的指令执行顺序与程序不一致（乱序）。另外，保留站会监视执行流水线输出的结果，如果产生的结果正好是等待中的指令的操作数，就将其读入，这样操作数齐备后，等待中的指令就可以执行了。</p><p>此外，上图给每种指令都设置了保留站，而有的处理器用一个保留站控制所有流水线。</p><h6 id="乱序执行中的反向依赖"><a href="#乱序执行中的反向依赖" class="headerlink" title="乱序执行中的反向依赖"></a>乱序执行中的反向依赖</h6><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">LD</span> <span class="hljs-built_in">r1</span>，［a］<span class="hljs-comment">; ←将内存的变量a 读入到寄存器r1（加载）</span><br><br><span class="hljs-keyword">ADD</span> <span class="hljs-built_in">r2</span>，<span class="hljs-built_in">r1</span>，<span class="hljs-built_in">r5</span><span class="hljs-comment">; ←r1与r5相加，保存到r2</span><br><br><span class="hljs-keyword">SUB</span> <span class="hljs-built_in">r1</span>，<span class="hljs-built_in">r5</span>，<span class="hljs-built_in">r4</span><span class="hljs-comment">; ←r5减去 r4，保存到 r1</span><br></code></pre></td></tr></table></figure><p>LD指令需要较长时钟周期，ADD与LD有r1寄存器的依赖关系，所以ADD也被阻塞不能执行。而SUB指令中的r4,r5都已知，根据乱序执行，SUB指令先执行。而SUB指令的保存结果位置是ADD指令的操作数r1，这样就产生的了反向依赖（anti-dependency)。SUB指令先于ADD执行，那么ADD指令执行时的r1值就不是LD指令的结果，而是SUB执行后保存在r1的值，程序执行如下图：</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/04/data_dependency2.png"></p><h6 id="寄存器重命名消除反向依赖"><a href="#寄存器重命名消除反向依赖" class="headerlink" title="寄存器重命名消除反向依赖"></a>寄存器重命名消除反向依赖</h6><p><a href="https://zh.wikipedia.org/wiki/%E5%AF%84%E5%AD%98%E5%99%A8%E9%87%8D%E5%91%BD%E5%90%8D">逻辑寄存器和物理寄存器</a> :<br>编译器或者汇编器生成的机器语言程序读写有限数量的指令集体系结构（ISA）寄存器。例如，Alpha ISA使用32个64位宽整数寄存器，32个64位宽浮点寄存器。这些体系结构寄存器，是程序可以直接访问的逻辑上的寄存器。如果程序员在调试器中把这个程序暂停，可以观察到这64个寄存器与一些状态寄存器当前存储的值。<br>一款特定的处理器，实现了这种处理器体系结构。例如Alpha 21264有80个整数寄存器、72个浮点寄存器，作为处理器内物理实现的寄存器。也就是说，Alpha 21264处理器有80个物理存在的位置存储整数运算的结果，72个位置存放浮点运算的结果。实际上，该款处理器有更多的物理存在的存储位置，但与寄存器重名关系不大。</p><p>重命名处理将程序中记载的寄存器编号（称为“逻辑寄存器”）对应到物理寄存器编号上。各指令写入结果的逻辑寄存器一定要分配到空闲的物理寄存器上。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">LD</span> <span class="hljs-built_in">p11</span>，［a］<span class="hljs-comment">; ←将内存的变量读入寄存器p11 （r1）</span><br><br><span class="hljs-keyword">ADD</span> <span class="hljs-built_in">p12</span>，<span class="hljs-built_in">p11</span>，<span class="hljs-built_in">r5</span><span class="hljs-comment">; ←p11 （r1）与 r5相加，保存到p12 （r2）</span><br><br><span class="hljs-keyword">SUB</span> <span class="hljs-built_in">p13</span>，<span class="hljs-built_in">r5</span>，<span class="hljs-built_in">r4</span><span class="hljs-comment">; ←r5减去 r4，保存到 p13 （r1）</span><br></code></pre></td></tr></table></figure><p>如图3 所示，LD指令要将结果保存到r1 ，而实际上被重命名，结果保存到了物理寄存器p11。解码下一条 ADD指令时，对应表中记载了 r1 &#x3D; p11 ，因此将使用 r1 的部分改变为使用p11。此外，存放 ADD指令结果的r2 寄存器对应到空闲物理寄存器p12。而SUB 指令的结果也要保存到r1 ，此时要将r1对应到空闲的物理寄存器p13 上。</p><p>这样，尽管逻辑寄存器都是r1 ，但保存LD指令结果和SUB指令结果的实际物理寄存器编号并不相同，因此即使SUB 指令比LD指令早完成，也不会发生任何问题。这种处理叫做寄存器重命名。<br><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/04/data_dependency3.png"></p><p>图3 重命名之后的情况</p><h6 id="寄存器重命名原理"><a href="#寄存器重命名原理" class="headerlink" title="寄存器重命名原理"></a>寄存器重命名原理</h6><p>为了实现寄存器重命名，乱序执行的处理器要有物理寄存器池，以及逻辑寄存器和物理寄存器的对应表。在译码时给逻辑寄存器分配物理寄存器，并且记录到对应表中。在解码的时候也要查找对应表中的对应关系，将后续指令中使用的逻辑寄存器转换成对应的物理寄存器。并且在指令执行结束后要释放物理寄存器到空闲物理寄存器池中。</p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>CPU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redhat虚拟机网络配置</title>
    <link href="/2019/04/19/linux/redhat%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    <url>/2019/04/19/linux/redhat%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h4 id="redhat虚拟机出现联网错误解决"><a href="#redhat虚拟机出现联网错误解决" class="headerlink" title="redhat虚拟机出现联网错误解决"></a>redhat虚拟机出现联网错误解决</h4><h5 id="1-设置windows主机的网络连接"><a href="#1-设置windows主机的网络连接" class="headerlink" title="1 设置windows主机的网络连接"></a>1 设置windows主机的网络连接</h5><p>(<a href="https://blog.csdn.net/wzygis/article/details/16829509">参考</a>)</p><p>在网络连接下有VMnet1,VMnet2,(vmnet1是host-only，也就是说，选择用vmnet1的话就相当于VMware给你提供了一个虚拟交换机，仅将虚拟机和真实系统连上了，虚 拟机可以与真实系统相互共享文件，但是虚拟机无法访问外部互联网，而vmnet8是NAT，就是网络地址转换，相当于给你一个虚拟交换机，将虚拟机和真实 系统连上去了，同时这台虚拟交换机又和外部互联网相连，这样虚拟机和真是系统可以相互共享，同时又都能访问外部互联网，而且虚拟机是借用真实系统的IP上 网的，不会受到IP-MAC绑定的限制。)</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/04/virtualmachinenet1.png"></p><p>将VMnet8的TCP&#x2F;IP4都设置成自动获取<br><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/04/virtualmachinenet4.png"></p><p>在windows命令行中查看ip地址 ipconfig<br><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/04/virtualmachinenet5.png"></p><p>在这里VMnet的ip是192.168.222.1</p><p>也可以在虚拟机软件的虚拟网络编辑器中查看子网ip<br><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/04/virtualmachinenet2.png"></p><h5 id="2-设置虚拟机的连接模式-NAT"><a href="#2-设置虚拟机的连接模式-NAT" class="headerlink" title="2 设置虚拟机的连接模式 NAT"></a>2 设置虚拟机的连接模式 NAT</h5><p>编辑虚拟机设置，将网络连接方式设成NAT方式</p><h5 id="3-设置虚拟机内的网络连接"><a href="#3-设置虚拟机内的网络连接" class="headerlink" title="3 设置虚拟机内的网络连接"></a>3 设置虚拟机内的网络连接</h5><p>在虚拟机内编辑网络连接eth0，如果没有就新建一个eth0。</p><p>在Redhat Linux虚拟机中选择system&gt;preferences&gt;network connections 打开如下对话框:</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/04/net1.png"></p><p>图中有一个网络，双击打开</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/04/net2.png"></p><p>如果没有就创建一个，其中MAC address，可以通过在命令行中输入ifconfig来查看，即HWaddr</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/04/virtualmachinenet3.png"><br>也是自动获取DHCP</p><h5 id="4-编辑-x2F-etc-x2F-sysconfig-x2F-network-script-x2F-ifcfg-eth0文件"><a href="#4-编辑-x2F-etc-x2F-sysconfig-x2F-network-script-x2F-ifcfg-eth0文件" class="headerlink" title="4 编辑&#x2F;etc&#x2F;sysconfig&#x2F;network-script&#x2F;ifcfg-eth0文件"></a>4 编辑&#x2F;etc&#x2F;sysconfig&#x2F;network-script&#x2F;ifcfg-eth0文件</h5><p>进入root权限，打开文件&#x2F;etc&#x2F;sysconfig&#x2F;network-script&#x2F;ifcfg-eth0，将以下内容复制到文件内</p><figure class="highlight ini"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">DEVICE</span>=eth0<br><span class="hljs-attr">TYPE</span>=Ethernet<br><span class="hljs-attr">ONBOOT</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">NM_CONTROLLED</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">BOOTPROTO</span>=dhcp<br><span class="hljs-attr">DEFROUTE</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">IPV4_FAILURE_FATAL</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">IPV6INIT</span>=<span class="hljs-literal">no</span><br><span class="hljs-attr">NAME</span>=<span class="hljs-string">&quot;System eth0&quot;</span><br><span class="hljs-attr">HWADDR</span>=A4:DB:<span class="hljs-number">30</span>:<span class="hljs-number">35</span>:<span class="hljs-number">75</span>:<span class="hljs-number">57</span><br><span class="hljs-attr">PEERDNS</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">PEERROUTES</span>=<span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><p>如果提示你不能对这个文件进行writing操作，那么先进入到目录下，然后新建一个文件ifcfg-ech0，再复制保存。</p><p><strong>经过以上步骤差不多能上网咯</strong></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>virtual machine</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 函数参数</title>
    <link href="/2019/04/18/C++/%E5%87%BD%E6%95%B0/C++%20%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/"/>
    <url>/2019/04/18/C++/%E5%87%BD%E6%95%B0/C++%20%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="C-中函数的参数类型"><a href="#C-中函数的参数类型" class="headerlink" title="C++中函数的参数类型"></a>C++中函数的参数类型</h4><ul><li>值传递</li><li>引用形参</li><li>const参数</li><li>数组参数</li></ul><h4 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h4><p><strong>将实参的值复制一份给形参</strong>。主要有两种：1）<strong>地址参数——实际是对实参操作</strong>。2）<strong>非地址参数——形参改变不会影响实参</strong></p><h4 id="引用形参"><a href="#引用形参" class="headerlink" title="引用形参"></a>引用形参</h4><p><strong>实参的引用，实际操作实参，但不会拷贝对象</strong></p><p>优点：</p><ol><li><strong>拷贝某些大的自定义类型的对象时效率低</strong></li><li><strong>某些类型(IO类型)不支持拷贝</strong></li></ol><p> 比如在<a href="https://east1203.github.io/2019/03/09/C++/19_03/IO%E6%B5%81/">IO流</a>中，重载输出运算符&lt;&lt;，将ostream对象的引用穿进去。<br> <figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="hljs-type">const</span> My_String &amp;str);<br></code></pre></td></tr></table></figure><br> 3. <strong>还可以用来返回多个参数，将需要修改的参数通过引用形参传进去</strong><br> <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"> <span class="hljs-built_in">int</span> <span class="hljs-constructor">MultiRe(<span class="hljs-params">int</span>&amp; <span class="hljs-params">n1</span>, <span class="hljs-params">int</span>&amp; <span class="hljs-params">n2</span>)</span><br>&#123;<br>n1 = n1 + <span class="hljs-number">1</span>;<br>n2 = n2 + <span class="hljs-number">1</span>;<br>return n1 + n2;<br>&#125;<br><span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span><br>&#123;<br><span class="hljs-built_in">int</span> n1 = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">int</span> n2 = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">int</span> n3 = <span class="hljs-constructor">MultiRe(<span class="hljs-params">n1</span>, <span class="hljs-params">n2</span>)</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;n1 is : &quot;</span> &lt;&lt;n1&lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;n2 is : &quot;</span> &lt;&lt; n2&lt;&lt;endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;n3 is : &quot;</span> &lt;&lt; n3&lt;&lt;endl;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br> 输出：<br> <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">n1 <span class="hljs-keyword">is</span> : 2<br>n2 <span class="hljs-keyword">is</span> : 2<br>n3 <span class="hljs-keyword">is</span> : 4<br></code></pre></td></tr></table></figure><br> n1和n2的值都改变了。</p><h4 id="const参数"><a href="#const参数" class="headerlink" title="const参数"></a>const参数</h4><ol><li>如果两个函数只有顶层const(<strong>顶层const是针对对象本身</strong>)不同，那么不能将两个函数却分开，编译器会报<strong>函数重复定义</strong>的错误。底层const(<strong>常量引用或常量的指针</strong>)，不会报错</li></ol><p> 下面两个show函数中，<strong>const int n</strong>是<strong>顶层const</strong>，会出现重复定义错误。<br> <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> <span class="hljs-keyword">show</span>(<span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> n)<br><span class="hljs-keyword">void</span> <span class="hljs-keyword">show</span>( <span class="hljs-built_in">int</span> n)<br></code></pre></td></tr></table></figure><br> 修改成底层const<br> <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> <span class="hljs-keyword">show</span>(<span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span>&amp; n)<br><span class="hljs-keyword">void</span> <span class="hljs-keyword">show</span>( <span class="hljs-built_in">int</span>&amp; n)<br></code></pre></td></tr></table></figure></p><ol start="2"><li>可以用非常量初始化底层const(当然顶层const也可以)，反之不行</li><li>**尽量使用常量引用 **</li></ol><p>   <strong>这是因为非常量的引用会给人这样的印象——允许你修改变量；如果形参是非常量引用，那么函数不能接受常量实参</strong></p><p><strong>对于const参数主要了解这个const属性到底加在哪？并且在操作中不能违背这个const属性</strong>。</p><p>顶层const修饰对象本身，比如</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">const</span> <span class="hljs-type">int</span> n1 = <span class="hljs-number">1</span> ;<br><span class="hljs-type">int</span> <span class="hljs-keyword">const</span> n2 = <span class="hljs-number">1</span> ;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> *<span class="hljs-keyword">const</span> <span class="hljs-keyword">ptr</span> = &amp;n;   //指针本身是常量，<span class="hljs-keyword">ptr</span>指向了n，这个指向不能变，但是可以修改<span class="hljs-keyword">ptr</span>指向的对象的值，也就是n的值。<br></code></pre></td></tr></table></figure><p>底层const是<strong>const引用或者常量的指针</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> n;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span>&amp; nn = n; <span class="hljs-comment">//nn是常量的引用</span><br><span class="hljs-keyword">const</span> cn = <span class="hljs-number">1</span>;  <span class="hljs-comment">//cn是常量，只有可以指向常量的指针才可以指向它，比如下面的ptr，</span><br>               <span class="hljs-comment">//如果一个非常量的指针指向cn，就违背了cn的const属性</span><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span>* ptr = &amp;cn; <span class="hljs-comment">//ptr是常量的指针，它可以指向常量和非常量</span><br></code></pre></td></tr></table></figure><h4 id="数组参数"><a href="#数组参数" class="headerlink" title="数组参数"></a>数组参数</h4><p><strong>数组的特性：</strong></p><ol><li>数组不允许拷贝</li><li>使用数组通常是将它转化成数组的首地址形式</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span>* arr</span>) <span class="hljs-comment">//只传数组首地址</span></span><br>&#123;<br><span class="hljs-keyword">if</span>(arr)<br><span class="hljs-keyword">while</span> (*arr)  <span class="hljs-comment">//通过判断是否到了数组末尾来终止函数</span><br>cout &lt;&lt; (*arr++) &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br><span class="hljs-built_in">int</span> arr[] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>print(arr); <span class="hljs-comment">//将数组的首地址传进去</span><br>&#125;<br></code></pre></td></tr></table></figure><p>也可以传递数组的首地址和尾地址的下一位，类似于STL操作</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* start,<span class="hljs-type">const</span> <span class="hljs-type">int</span>* end)</span></span>;<br></code></pre></td></tr></table></figure><p>也可以传递首地址和数组长度</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* arr,<span class="hljs-type">const</span> <span class="hljs-type">int</span> lenght)</span></span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>this指针和const成员函数</title>
    <link href="/2019/04/18/C++/%E7%B1%BB/this%E6%8C%87%E9%92%88%E5%92%8Cconst%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
    <url>/2019/04/18/C++/%E7%B1%BB/this%E6%8C%87%E9%92%88%E5%92%8Cconst%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>const对象只能调用const成员函数</strong></p></blockquote><h4 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h4><p>类的成员函数都有一个隐式的this指针来指向调用该函数的那个类对象，this总是指向这个对象，所以<strong>this指针是个指针常量，属于顶层const</strong>。</p><p>可以通过*this来返回对象。</p><p>以下是一个结构体类型（C++中的结构体可以有成员函数）</p><figure class="highlight csharp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">struct</span> INT &#123;<br>INT() = <span class="hljs-literal">default</span>;<br>INT(<span class="hljs-built_in">int</span> n):m_val(n)&#123;&#125;<br>INT&amp; <span class="hljs-keyword">add</span>(INT&amp; n)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_val = <span class="hljs-keyword">this</span>-&gt;m_val + n.m_val;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">//返回调用该函数的对象</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span>() <span class="hljs-keyword">const</span> <span class="hljs-comment">//const成员函数</span></span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;this value is :&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;m_val &lt;&lt; endl;<br>&#125;<br><span class="hljs-built_in">int</span> m_val;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h4><p>默认情况下this指针是<code>INT * const</code>类型，是<strong>指向非常量的指针常量</strong>（可以通过指针改变对象值，但不能改变指针指向），<strong>它是不可以指向常量对象</strong>，所以<strong>const类型的类对象不能调用普通的成员函数</strong>。</p><p>这个时候就需要const成员函数出马了。const成员函数的形式是在参数列表的括号后面加上一个const关键字，如上图中的show()函数</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span>() <span class="hljs-keyword">const</span></span>;<br></code></pre></td></tr></table></figure><p>const修改this指针的类型，使之变成<code>const INT* const</code>，即<strong>指向常量的指针常量</strong>，<strong>所以const对象只能调用const成员函数</strong></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重写class的默认函数</title>
    <link href="/2019/04/14/C++/%E7%B1%BB/%E9%87%8D%E5%86%99class%E7%9A%84%E9%BB%98%E8%AE%A4%E5%87%BD%E6%95%B0/"/>
    <url>/2019/04/14/C++/%E7%B1%BB/%E9%87%8D%E5%86%99class%E7%9A%84%E9%BB%98%E8%AE%A4%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>默认情况C++会自动为类生成<strong>构造函数、析构函数、复制构造函数、赋值构造函数</strong>，但是当类数据成员中有指针类型时，需要我们自己写这些默认的函数来更好的管理内存。</p><p>下面以一个字符串类为例子说明</p><figure class="highlight csharp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyString</span> &#123;<br><span class="hljs-keyword">public</span>:<br>MyString(); <span class="hljs-comment">//构造</span><br>MyString(<span class="hljs-built_in">char</span>* str = <span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">//构造</span><br>~MyString(); <span class="hljs-comment">//析构</span><br>MyString(MyString&amp;); <span class="hljs-comment">//复制</span><br>MyString&amp; <span class="hljs-keyword">operator</span>=(MyString&amp; str);<span class="hljs-comment">//赋值</span><br>friend ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt; (ostream&amp;, <span class="hljs-keyword">const</span> MyString &amp;); <span class="hljs-comment">//输出重载</span><br><span class="hljs-function">unsigned <span class="hljs-built_in">int</span> <span class="hljs-title">size</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">//返回char的个数</span><br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">empty</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">//是否为空</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span>()</span>;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">char</span>* m_Data;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">copy</span>(<span class="hljs-params"><span class="hljs-built_in">char</span>*</span>)</span>; <span class="hljs-comment">//把重复的操作封装一下。这个函数是申请一段空间，并将参数值赋值给对象</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> MyString::<span class="hljs-built_in">MyString</span>() &#123;&#125;<br>MyString::<span class="hljs-built_in">MyString</span>(<span class="hljs-type">char</span>* str)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">copy</span>(str); <span class="hljs-comment">//申请空间</span><br>&#125;<br>MyString::<span class="hljs-built_in">MyString</span>(MyString&amp; string)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">copy</span>(string.m_Data); <span class="hljs-comment">//申请空间</span><br>&#125;<br>MyString::~<span class="hljs-built_in">MyString</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (m_Data != <span class="hljs-literal">nullptr</span>)<br>&#123;<br><span class="hljs-keyword">delete</span>[] m_Data; <span class="hljs-comment">//释放空间</span><br>m_Data = <span class="hljs-literal">nullptr</span>;<br>&#125;<br>&#125;<br>MyString&amp; MyString::<span class="hljs-keyword">operator</span>=(MyString&amp; str)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;str)<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br><span class="hljs-keyword">if</span> (m_Data != <span class="hljs-literal">nullptr</span>)  <span class="hljs-comment">//先把原来的空间释放掉</span><br>&#123;<br><span class="hljs-keyword">delete</span>[] m_Data;<br>m_Data = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">copy</span>(str.m_Data); <span class="hljs-comment">//重新申请</span><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">MyString::size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-comment">//const成员函数不会修改对象内容</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">strlen</span>(m_Data);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MyString::empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (m_Data == <span class="hljs-literal">nullptr</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyString::copy</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(str);<br>m_Data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];<br><span class="hljs-built_in">memset</span>(m_Data, <span class="hljs-number">0</span>, len+<span class="hljs-number">1</span>);<br><span class="hljs-built_in">memcpy</span>(m_Data, str, len);<br>&#125;<br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt; (ostream&amp; os, <span class="hljs-type">const</span> MyString &amp; str)<br>&#123;<br><span class="hljs-keyword">if</span> (str.<span class="hljs-built_in">empty</span>())<br><span class="hljs-keyword">return</span> os;<br>os &lt;&lt; str.m_Data;<br><span class="hljs-keyword">return</span> os;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>构造函数、复制、赋值构造函数中都需要为对象重新申请内存</strong></p><p><strong>赋值构造函数中是将对象中m_Data保存的值赋值，而不是直接将m_Data指针赋值。先将原来的空间释放，然后申请新的空间</strong></p><p><strong>析构释放空间</strong></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>makefile</title>
    <link href="/2019/04/14/IC/script/makefile/"/>
    <url>/2019/04/14/IC/script/makefile/</url>
    
    <content type="html"><![CDATA[<h3 id="makefile-介绍"><a href="#makefile-介绍" class="headerlink" title="makefile 介绍"></a>makefile 介绍</h3><p>一个企业级项目，通常会有很多源文件，有时也会按功能、类型、模块分门别类的放在不同的目录中，有时候也会在一个目录里存放了多个程序的源代码。<br>这时，如何对这些代码的编译就成了个问题。Makefle就是为这个问题而生的，它定义了一套规则，决定了哪些文件要先编译，哪些文件后编译，哪些文件要重新编译。<br>整个工程通常只要一个make命令就可以完成编译、链接，甚至更复杂的功能。可以说，任何一个Linux源程序都带有一个Makefile文件。</p><h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h3><p>**  目标文件：依赖文件**</p><p>  <strong>规则</strong><br>每条规则要以tab键开头，如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span>:<span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span><br>   gcc -c <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> -o <span class="hljs-selector-tag">main</span>.o<br></code></pre></td></tr></table></figure><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li><strong>目标生成</strong></li></ol><p>  检查规则中的依赖文件是否存在，如果不存在寻找是否有生成该依赖文件的规则</p><p>  <img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/04/makefile1.png"></p><ol start="2"><li><strong>目标更新</strong></li></ol><p> 检查目标依赖文件，任何一个文件有更新，则重新生成目标；</p><p> 如果目标文件比依赖文件时间晚，重新生成目标</p><p> <img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/04/makefile2.png"></p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ol><li>$@ –&gt; 规则中的目标</li><li>$&lt; –&gt; 规则中的第一个依赖条件</li><li>$^ –&gt; 规则中的所有依赖条件</li><li>CC，PWD，CFLAG系统自带变量</li></ol><h3 id="模式规则"><a href="#模式规则" class="headerlink" title="模式规则"></a>模式规则</h3><p>模式规则是在目标及依赖条件中使用%来匹配对应的文件，比如在目录下有main.c, func1.c, func2.c三个文件，对这三个文件的编译可以由一条规则完成：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mel">%.o:%.c<br>    $(CC) –c  $&lt; -o $@<br></code></pre></td></tr></table></figure><p>这条模式规则表示：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">main.o由main.<span class="hljs-keyword">c</span>生成，<br>func<span class="hljs-number">1</span>.o由func<span class="hljs-number">1</span>.<span class="hljs-keyword">c</span>生成，<br>func<span class="hljs-number">2</span>.o由func<span class="hljs-number">2</span>.<span class="hljs-keyword">c</span>生成<br></code></pre></td></tr></table></figure><p>这就是模式规则的作用，可以一次匹配目录下的所有文件。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="wildcard"><a href="#wildcard" class="headerlink" title="wildcard:"></a>wildcard:</h4><p>用于查找指定目录下指定类型的文件，跟的参数就是目录+文件类型，比如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">src = $（wildcard .<span class="hljs-regexp">/src/</span>*.c)<br></code></pre></td></tr></table></figure><p>这句话表示：找到.&#x2F;src 目录下所有后缀为.c的文件，并赋给变量src。<br>命令执行完成后，src的值为：main.c func1.c fun2.c。</p><h4 id="patsubst"><a href="#patsubst" class="headerlink" title="patsubst:"></a>patsubst:</h4><p>匹配替换，例如以下例子，用于从src目录中找到所有.c 结尾的文件，并将其替换为.o文件，并赋值给obj。<br>  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">obj = <span class="hljs-constructor">$(<span class="hljs-params">patsubst</span> %.<span class="hljs-params">c</span> ,%.<span class="hljs-params">o</span> ,$(<span class="hljs-params">src</span>)</span>)<br></code></pre></td></tr></table></figure></p><p>把src变量中所有后缀为.c的文件替换成.o。<br>命令执行完成后，obj的值为main.o func1.o func2.o</p><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><h4 id="文档结构"><a href="#文档结构" class="headerlink" title="文档结构"></a>文档结构</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*main.c*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;func1.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;func2.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">func1</span>();<br><span class="hljs-built_in">func2</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*func1.h*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-comment">/*func1.c*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is func1\n&quot;</span>);<br>&#125;<br><span class="hljs-comment">/*func2.h*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-comment">/*func2.c*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;this func2&quot;</span>&lt;&lt;endl;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs makefile">sor = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.c)</span><br>obj = <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c,%.o,<span class="hljs-variable">$(sor)</span>)</span><br>tar = app<br>CFLAGS = -Wall -c<br>CC = g++<br><span class="hljs-variable">$(tar)</span>:<span class="hljs-variable">$(obj)</span><br><span class="hljs-variable">$(CC)</span>  <span class="hljs-variable">$(obj)</span> -o <span class="hljs-variable">$(tar)</span><br><br><span class="hljs-section">%.o:%.c</span><br><span class="hljs-variable">$(CC)</span>  <span class="hljs-variable">$&lt;</span> <span class="hljs-variable">$(CFLAGS)</span> -o <span class="hljs-variable">$@</span><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:clean</span><br><span class="hljs-section">clean:</span><br>rm -rf *.o *.out<br>rm -rf <span class="hljs-variable">$(tar)</span><br><br></code></pre></td></tr></table></figure><h3 id="在命令行向Makefile中传入参数"><a href="#在命令行向Makefile中传入参数" class="headerlink" title="在命令行向Makefile中传入参数"></a>在命令行向Makefile中传入参数</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># Makefile</span><br>dut=<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-section">vcs:</span><br>vcs $&#123;dut&#125;<br></code></pre></td></tr></table></figure><p>上面这个Makefile，用起来可以如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make dut=top.v<br></code></pre></td></tr></table></figure><p>这样就将${dut}替换成top.v</p>]]></content>
    
    
    <categories>
      
      <category>script</category>
      
      <category>Makefile</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vcs使用</title>
    <link href="/2019/04/14/tools/vcs/vcs%E4%BD%BF%E7%94%A8/"/>
    <url>/2019/04/14/tools/vcs/vcs%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="VCS仿真流程"><a href="#VCS仿真流程" class="headerlink" title="VCS仿真流程"></a>VCS仿真流程</h3><p>VCS将.v文件（verilog模型）编译成可执行二进制文件(simv)，然后运行可执行文件进行仿真。</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/2019/04/vcs1.png"></p><h3 id="常用options"><a href="#常用options" class="headerlink" title="常用options"></a>常用options</h3><ol><li>**-l filename  **</li></ol><p> 将需要编译的文件的地址写在filename文件下，每行一个文件</p><ol start="2"><li><p><strong>-R</strong><br> 编译之后直接运行simv进行仿真</p></li><li><p><strong>-sverilog</strong></p></li></ol><p> 识别system Verilog语法</p><ol start="4"><li><strong>-full64</strong></li></ol><p> 在64bit环境下编译和仿真</p><ol start="5"><li><strong>+v2k</strong></li></ol><p> IEEE 1364 -2001年的Verilog语法</p><ol start="6"><li><strong>+notimingcheck</strong></li></ol><p> Disables timing check system tasks in your design. Using this option at runtime can improve the simulation performance of your design, depending on the number of timing checks that this option disables.</p><ol start="7"><li><strong>-debug_all</strong></li></ol><p> 交互仿真，不知道具体什么意思，不过一般都是加这个的，这样可以用$finish来控制仿真停止。</p><ol start="8"><li>+incdir + 目录</li></ol><p> 在目录下搜索哪些&#96;include指定的文件</p><p>9）  -y 目录</p><p>在目录下的文件中搜索module的定义。</p><p>10） +libext+.v+.sv</p><p>配合-y使用，搜索目录下指定后缀的文件</p><p>11）+define+macro</p><p>定义宏，+define+ASSERT_ON</p><p>12） +lint&#x3D;TFIPC-L</p><p> 如果有的模块的端口定义了，但是没有连接，用这个选项，编译器会给出哪些端口没有连接</p><p>13）+vcs+vcdpluson</p><p>​    生成vpd波形文件</p><h3 id="仿真时加上自定义的选项-value-plusargs"><a href="#仿真时加上自定义的选项-value-plusargs" class="headerlink" title="仿真时加上自定义的选项 $value$plusargs"></a>仿真时加上自定义的选项 $value$plusargs</h3><p>功能：通过添加仿真选项，在仿真的时候控制代码的执行。</p><p>语法：</p><p>integer &#x3D; $value$plusargs(“plusarg_format”,signalname); </p><p>The plusarg_format argument specifies a user-defined runtime option for passing a value to the specified signal. It specifies the text of the option and the radix of the value that you pass to the signal. </p><p>比如存在代码：</p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span><br><span class="hljs-keyword">begin</span><br><span class="hljs-built_in">$monitor</span>(<span class="hljs-string">&quot;r1=%0d at %0t&quot;</span>,r1,<span class="hljs-built_in">$time</span>);<br>#<span class="hljs-number">1</span> r1=<span class="hljs-number">0</span>;<br>#<span class="hljs-number">1</span> status=<span class="hljs-built_in">$value$plusargs</span>(<span class="hljs-string">&quot;r1=%d&quot;</span>,r1);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>仿真脚本：</p><p>simv  +r1&#x3D;10</p><p>monitor的输出：</p><p>g:<br>r1&#x3D;x at 0<br>r1&#x3D;0 at 1<br>r1&#x3D;10 at 2 </p><p>上面的r1变量是用户自己指定的，仿真的时候代码会读取到这个值，读取成功返回真，失败返回假。也可以用这个传进来的值来控制代码执行，比如作为if语句的判断条件。</p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
      <category>EDA</category>
      
      <category>vcs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>vcs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>静态时序分析STA</title>
    <link href="/2019/04/13/IC/STA/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    <url>/2019/04/13/IC/STA/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li><h5 id="为什么要进行时序分析？"><a href="#为什么要进行时序分析？" class="headerlink" title="为什么要进行时序分析？"></a>为什么要进行时序分析？</h5></li><li><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5></li></ul></li><li><h4 id="STA优缺点"><a href="#STA优缺点" class="headerlink" title="STA优缺点"></a>STA优缺点</h4></li><li><h4 id="STA作用"><a href="#STA作用" class="headerlink" title="STA作用"></a>STA作用</h4></li><li><h4 id="STA的过程"><a href="#STA的过程" class="headerlink" title="STA的过程"></a>STA的过程</h4></li><li><h4 id="时序分析基本概念"><a href="#时序分析基本概念" class="headerlink" title="时序分析基本概念"></a>时序分析基本概念</h4></li></ul><hr><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li><h4 id="为什么要进行时序分析？-1"><a href="#为什么要进行时序分析？-1" class="headerlink" title="为什么要进行时序分析？"></a>为什么要进行时序分析？</h4></li></ul><p> 设计都会有性能指标，为了保证在物理制造后的电路功能正确并且满足设计指标，需要保证电路的时序满足设计要求，这就需要在电路设计好后对电路进行时序分析，满足时序才能进行接下来的设计和制造。</p><ul><li><h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4></li></ul><ol><li><strong>动态时序仿真</strong></li></ol><p>动态时序仿真是针对给定的输入信号波形，模拟电路实际工作时候的功能和延迟情况，给出相应的仿真输出波形。它主要用于验证设计在器件实际延时情况下的逻辑功能。由动态时序仿真报告无法得到设计的各项时序性能指标，如最高时钟频率等.(<strong>但是到底怎么来做不会</strong>）<br><strong>既能验证设计的功能，也能验证设计的时序。</strong></p><ol start="2"><li><strong>静态时序分析</strong></li></ol><p> 静态时序分析是分析每条路径上器件和连线延迟信息,计算出设计的各项性能，比如最高时钟频率，建立保持时间等。<br>    <strong>只能验证设计的时序信息，不能验证设计的功能。</strong></p><hr><h3 id="STA优缺点-1"><a href="#STA优缺点-1" class="headerlink" title="STA优缺点"></a>STA优缺点</h3><ol><li><strong>从动态时序仿真转到静态时序分析</strong><br> 在初期集成电路设计中，动态时许仿真来验证设计的时序很流行。但是随着设计规模不断增大，进行动态时序仿真需要花费大量时间设计时序向量和功能向量（用来验真功能和时序的），并且还不一定能保证100%覆盖率。所以快捷的静态时序分析受到青睐。</li><li><strong>STA优点</strong><ol><li>分析速度块</li><li>不需要仿真向量<br> 3）覆盖率几乎100%</li><li>静态分析还能完成动态仿真不能完成的复杂分析。例如最大最小路径延迟、建立保持时间分析、时钟信号质量分析。</li></ol></li><li><strong>STA缺点</strong><ol><li>不能验证设计的功能<br> 2）STA只能分析<strong>同步时序电路</strong>，对于异步电路，只能在门级动态仿真来验证<br> 3）不能自动识别特殊路径。比如多周期路径(multi-cycle path)，非正常路径(fault paths)，多时钟周期关系(multiple clocks）<strong>（这些到底是什么现在还不清楚txtx）</strong></li></ol><p> <em><strong>所以STA并不能完全取代动态时序仿真，二者必须协同存在</strong></em></p></li></ol><hr><h3 id="STA的作用"><a href="#STA的作用" class="headerlink" title="STA的作用"></a>STA的作用</h3><ol><li><strong>确定芯片的最高工作频率</strong><br>通过时序分析可以控制工程的综合、映射、布局布线等环节，减少延迟，从而尽可能提高工作频率</li><li><strong>检查时序是否满足</strong><br> 可以通过时序分析来查看目标模块是否满足约束，如不满足，可以定位到不满足约束的部分，并给出具体原因，进一步修改程序直至满足时序要求</li><li><strong>分析时钟质量</strong><br> 时钟存在抖动、偏移、占空比失真等不可避免的缺陷。通过时序分析可以验证其对目标模块的影响</li></ol><hr><h3 id="STA的过程-1"><a href="#STA的过程-1" class="headerlink" title="STA的过程"></a>STA的过程</h3><ol><li>将设计打散成一个个timing paths</li><li>计算每一条path上的延迟</li><li>检验延迟是否满足设计要求</li></ol><hr><h3 id="时序分析基本概念-1"><a href="#时序分析基本概念-1" class="headerlink" title="时序分析基本概念"></a>时序分析基本概念</h3><ol><li>建立时间(setup time)</li><li>保持时间(hold time)</li><li>恢复时间(recovery time)<br>置位或复位信号在时钟信号有效之前需要保持有效的最小时间，类似于setup time</li><li>移除时间(removal time)<br>置位或复位信号在时钟有效沿之后需要继续有效的时间。</li></ol><hr><h3 id="时序路径"><a href="#时序路径" class="headerlink" title="时序路径"></a>时序路径</h3><ul><li><h4 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h4></li></ul><ol><li>触发器到触发器</li><li>输入端口到触发器</li><li>触发器到输出端口</li><li>输入端口到输出端口</li></ol><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90/1.png"></p><hr><h3 id="静态时序分析的基本方法"><a href="#静态时序分析的基本方法" class="headerlink" title="静态时序分析的基本方法"></a>静态时序分析的基本方法</h3><ul><li><h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4> 时序图主要包括逻辑节点、连接关系、主要的输入输出。</li></ul><p> 下图是一个逻辑电路图<br> <img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90/2.png"></p><p> 设定好逻辑节点，可以得到时序图中间结果</p><p> <img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90/3.png"><br> 确定好时序图的输入和输出，得到最终的时序图<br> <img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90/4.png"></p><p> <strong>时序图的起点：输入端口、时序单元的输出和存储器输出</strong></p><p> <strong>时序图的中点：输出端口、时序单元的输入和存储器输入</strong></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>STA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>同步FIFO</title>
    <link href="/2019/04/13/IC/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F/%E5%90%8C%E6%AD%A5FIFO/"/>
    <url>/2019/04/13/IC/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F/%E5%90%8C%E6%AD%A5FIFO/</url>
    
    <content type="html"><![CDATA[<h3 id="fifo介绍"><a href="#fifo介绍" class="headerlink" title="fifo介绍"></a>fifo介绍</h3><p>先入先出的数据缓存器，没有外部读写地址线，可同时读写。<br><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/%E5%90%8C%E6%AD%A5fifo/1.png"></p><ul><li><h4 id="fifo种类"><a href="#fifo种类" class="headerlink" title="fifo种类"></a>fifo种类</h4><p> FIFO有同步fifo和异步fifo之分。同步fifo只有一个时钟，读写时钟一样；异步fifo读写时钟不同，可能不同频率，或者同频不同相。</p></li><li><h4 id="fifo用途"><a href="#fifo用途" class="headerlink" title="fifo用途"></a>fifo用途</h4><ol><li>缓存数据</li></ol><p>  如果输入端burst一个数据，接收端不能立马全部接受，需要fifo存住这些数据。<br>2. 跨时钟域数据传输</p><p>  同步数据。</p></li></ul><h3 id="同步fifo"><a href="#同步fifo" class="headerlink" title="同步fifo"></a>同步fifo</h3><p> 同步FIFO就是读写时钟是一个，读写地址是同步的。</p><ul><li><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4></li></ul><ol><li>读写地址是下一次要进行读写的地址，是否进行读写需要判断最终读写有效（通过输入读写位和空满标志）</li><li>最终读写有效才进行读写</li><li>地址变换：最终读写有效才进行地址跳变，否则的话这个地址还没进行读写就跳过去了。</li></ol><ul><li><h4 id="fifo空满判断"><a href="#fifo空满判断" class="headerlink" title="fifo空满判断"></a>fifo空满判断</h4></li></ul><ol><li><strong>可以在读写地址上增加一位，用来判断是否空满。空满只通过比较地址，与读写有效输入端口无关。</strong></li></ol><p>   <strong>空：读写地址的MSB相同，其他位也相同；满：读写地址的MSB不同，其他位相同</strong></p><div class="code-wrapper"><pre><code class="hljs">用组合逻辑实现，与时钟信号无关，没有延迟，直接根据当前的读写地址就可以判断</code></pre></div>   <figure class="highlight sas"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs sas">  // 空：读写地址相同    c<span class="hljs-meta">log2</span>()函数是求以2为底数的对数<br>assign full = (r_addr[c<span class="hljs-meta">log2</span>(Depth)-1:0]==w_addr[c<span class="hljs-meta">log2</span>(Depth)-1:0]) <span class="hljs-variable">&amp;&amp;</span> (r_addr[c<span class="hljs-meta">log2</span>(Depth)] ^ w_addr[c<span class="hljs-meta">log2</span>(Depth)]);<br> // 满：读写地址的MSB不同，其他位相同<br> assign empty =(r_addr[c<span class="hljs-meta">log2</span>(Depth)-1:0]==w_addr[c<span class="hljs-meta">log2</span>(Depth)-1:0]) <span class="hljs-variable">&amp;&amp;</span> (r_addr[c<span class="hljs-meta">log2</span>(Depth)] == w_addr[c<span class="hljs-meta">log2</span>(Depth)]);<br></code></pre></td></tr></table></figure><ol start="2"><li><p>也可以用一个<strong>计数器cnt</strong>来表示当前有多少个没有读走的数据，当写有效，+1，读有效-1，又读又写不变。但这需要额外的计数器，并且可能影响FIFO最终的速度</p></li><li><p><strong>读写地址位数不变，通过地址和读写有效输入端口共同判断</strong></p><p>用时序逻辑实现，有一个时钟的延迟，需要根据读写有效输入位判断空满，判断的是下一个周期的空满状态。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs verilog">  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  rd,wr 读写有效输入端口</span><br><span class="hljs-comment">  rp,wp 读写地址</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-comment">// Full signal generate</span><br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rst) <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">if</span>(!rst) full_in &lt;= <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">if</span>( (~rd &amp;&amp; wr)&amp;&amp;((wp==rp-<span class="hljs-number">1</span>)||(rp==<span class="hljs-number">4&#x27;h0</span>&amp;&amp;wp==<span class="hljs-number">4&#x27;hf</span>)))<br>  <span class="hljs-comment">// 下个周期只写不读，如果当前写地址落后读一个地址或者读地址是0000，写地址是1111，下个周期fifo满了。</span><br>      full_in &lt;= <span class="hljs-number">1&#x27;b1</span>;<br>  <span class="hljs-comment">// 如果这个周期已经满了，但是有个读信号，那么下个周期就不满了</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(full_in &amp;&amp; rd) full_in &lt;= <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">// Empty signal generate</span><br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rst) <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">if</span>(!rst) empty_in &lt;= <span class="hljs-number">1&#x27;b1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br><span class="hljs-comment">// 空跟满类似</span><br>  <span class="hljs-keyword">if</span>((rd&amp;&amp;~wr)&amp;&amp;(rp==wp-<span class="hljs-number">1</span> || (rp==<span class="hljs-number">4&#x27;hf</span>&amp;&amp;wp==<span class="hljs-number">4&#x27;h0</span>)))<br>    empty_in&lt;=<span class="hljs-number">1&#x27;b1</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(empty_in &amp;&amp; wr) empty_in&lt;=<span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></li></ol>  <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>- #### 读写地址产生<br><br> <span class="hljs-number">1.</span> FIFO的读写地址产生比较简单 当读使能有效时 在时钟作用下 读地址加<span class="hljs-number">1</span> 当写使能有效时 写地址加<span class="hljs-number">1</span>。<br> <span class="hljs-number">2.</span> 当FIFO深度较大时 同时FIFO的速度要求较高时 可以采用线性反馈移位计数器 LFSR它的速度非常快 但是要牺牲一个地址。<br><br>    **线性反馈移位寄存器关键是要设计出<span class="hljs-number">2</span>^n个状态。**<br>    <br></code></pre></td></tr></table></figure><p>   &#x2F;************************************************************\</p><ul><li><ul><li></li></ul></li><li>Generation of Read and Write address pointers. They use *</li><li>LFSR counters, which are very fast. Because of the *</li><li>nature of LFSR, one address is sacrificed. *</li><li><ul><li>************************************************************&#x2F;<br>wire read_linearfeedback, write_linearfeedback;<br>assign read_linearfeedback &#x3D; ! (read_addr[8] ^ read_addr[4]);<br>assign write_linearfeedback &#x3D; ! (write_addr[8] ^ write_addr[4]);<br>&#x2F;&#x2F; 读地址反馈<br>always @(posedge clock or posedge fifo_gsr)<br>if (fifo_gsr)<br> read_addr &lt;&#x3D; 9’h0;<br>else if (read_allow)<br> read_addr &lt;&#x3D; { read_addr[7], read_addr[6], read_addr[5],<br> read_addr[4], read_addr[3], read_addr[2],<br> read_addr[1], read_addr[0], read_linearfeedback };<br>&#x2F;&#x2F; 写地址反馈<br>always @(posedge clock or posedge fifo_gsr)<br>if (fifo_gsr)<br>write_addr &lt;&#x3D; 9’h0<br>else if (write_allow)<br>write_addr &lt;&#x3D; { write_addr[7], write_addr[6], write_addr[5],<br>write_addr[4], write_addr[3], write_addr[2],<br>write_addr[1], write_addr[0], write_linearfeedback };</li></ul></li></ul>  <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">- #### 同步fifo的verilog代码<br><br><br></code></pre></td></tr></table></figure><p>  &#x2F;&#x2F; file name          :          fifo_1.v<br>  &#x2F;&#x2F; email          :     <a href="mailto:&#x64;&#x79;&#107;&#x31;&#50;&#48;&#x33;&#64;&#49;&#x32;&#x36;&#x2e;&#x63;&#111;&#x6d;">&#x64;&#x79;&#107;&#x31;&#50;&#48;&#x33;&#64;&#49;&#x32;&#x36;&#x2e;&#x63;&#111;&#x6d;</a><br>  &#x2F;&#x2F; author                :         dong yk</p><p>  &#96;timescale 1ns&#x2F;100ps<br>  module fifo #(parameter Width&#x3D;8,<br>              parameter Depth&#x3D;8) &#x2F;&#x2F;FIFO的深度<br>          (    input clk,<br>              input rst,<br>              input we,<br>              input re,<br>              input [Width-1:0] data_i,<br>              output full,<br>              output empty,<br>              output[Width-1:0] data_o<br>              );</p><p>  function integer clog2;  &#x2F;&#x2F; 求2的对数 ，log2(x)。得到memory的地址宽度<br>  input integer value;<br>  begin<br>      for(clog2&#x3D;0;value&gt;1;value&#x3D;value&gt;&gt;1) begin<br>          clog2&#x3D;clog2+1;<br>      end<br>  end<br>  endfunction<br>  reg [Width-1:0] dout;<br>  reg [clog2(Depth):0] r_addr;  &#x2F;&#x2F; 读地址<br>  reg [clog2(Depth):0] w_addr; &#x2F;&#x2F; 写地址<br>  wire re_flag &#x3D; (re&#x3D;&#x3D;1’b1) &amp;&amp; (empty&#x3D;&#x3D;1’b0); &#x2F;&#x2F; 在输入读有效，且fifo不为空时，读有效<br>  wire we_flag &#x3D; (we&#x3D;&#x3D;1’b1) &amp;&amp; (full &#x3D;&#x3D; 1’b0);&#x2F;&#x2F; 在输入写有效，且fifo不为满时，写有效</p><p>  reg[Width-1:0] memory[0:Depth-1]; &#x2F;&#x2F; 申请fifo内的存储空间<br>  &#x2F;&#x2F; 空：读写地址相同<br>  assign full &#x3D; (r_addr[clog2(Depth)-1:0]&#x3D;&#x3D;w_addr[clog2(Depth)-1:0]) &amp;&amp; (r_addr[clog2(Depth)] ^ w_addr[clog2(Depth)]);<br>  &#x2F;&#x2F; 满：读写地址的MSB不同，其他位相同<br>  assign empty &#x3D;(r_addr[clog2(Depth)-1:0]&#x3D;&#x3D;w_addr[clog2(Depth)-1:0]) &amp;&amp; (r_addr[clog2(Depth)] &#x3D;&#x3D; w_addr[clog2(Depth)]);<br>  assign data_o &#x3D; dout;</p><p>  always@(posedge clk or negedge rst) begin<br>      if(!rst) begin<br>          r_addr &lt;&#x3D; 0;<br>          dout &lt;&#x3D; 0;<br>      end else begin<br>          r_addr &lt;&#x3D; re_flag?(r_addr+1) : r_addr ; &#x2F;&#x2F; 读地址累加<br>          dout &lt;&#x3D; re_flag?memory[r_addr[clog2(Depth)-1:0]]:dout; &#x2F;&#x2F; 数据输出<br>      end<br>  end<br>  always @(posedge clk or negedge rst) begin<br>      if(!rst) begin<br>          w_addr &lt;&#x3D; 0;<br>      end else begin<br>          w_addr &lt;&#x3D; we_flag?(w_addr+1) : w_addr; &#x2F;&#x2F; 写地址累加<br>          memory[w_addr[clog2(Depth)-1:0]] &lt;&#x3D; we_flag?data_i:memory[w_addr[clog2(Depth)-1:0]]; &#x2F;&#x2F; 写入数据<br>      end<br>  end<br>  endmodule</p>  <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">- #### 在fifo中增加一个表示当前剩余多少数据的值usedw<br><br></code></pre></td></tr></table></figure><p>  &#x2F;&#x2F; file name          :        fifo_1.v<br>  &#x2F;&#x2F;<br>  &#x2F;&#x2F; author            :         dong yk<br>  &#x2F;&#x2F; description      ：      增加usedw 表示fifo中已经有了的数据个数<br>  &#96;timescale 1ns&#x2F;100ps<br>  module fifo #(parameter Width&#x3D;8,<br>              parameter Depth&#x3D;8) &#x2F;&#x2F;FIFO的深度<br>          (    input clk,<br>              input rst,<br>              input we,<br>              input re,<br>              input [Width-1:0] data_i,<br>              output full,<br>              output empty,<br>              output[Width-1:0] data_o，<br>              output [clog2(Depth)-1:0] usedw<br>              );</p><p>  function integer clog2;  &#x2F;&#x2F; 求2的对数 ，log2(x)。得到memory的地址宽度<br>  input integer value;<br>  begin<br>      for(clog2&#x3D;0;value&gt;1;value&#x3D;value&gt;&gt;1) begin<br>          clog2&#x3D;clog2+1;<br>      end<br>  end<br>  endfunction<br>  reg [Width-1:0] dout;<br>  reg [clog2(Depth):0] r_addr;  &#x2F;&#x2F; 读地址<br>  reg [clog2(Depth):0] w_addr; &#x2F;&#x2F; 写地址<br>  reg [clog2(Depth)-1:0] usedw_r;<br>  wire re_flag &#x3D; (re&#x3D;&#x3D;1’b1) &amp;&amp; (empty&#x3D;&#x3D;1’b0); &#x2F;&#x2F; 在输入读有效，且fifo不为空时，读有效<br>  wire we_flag &#x3D; (we&#x3D;&#x3D;1’b1) &amp;&amp; (full &#x3D;&#x3D; 1’b0);&#x2F;&#x2F; 在输入写有效，且fifo不为满时，写有效</p><p>  reg[Width-1:0] memory[0:Depth-1]; &#x2F;&#x2F; 申请fifo内的存储空间<br>  &#x2F;&#x2F; 空：读写地址相同<br>  assign full &#x3D; (r_addr[clog2(Depth)-1:0]&#x3D;&#x3D;w_addr[clog2(Depth)-1:0]) &amp;&amp; (r_addr[clog2(Depth)] ^ w_addr[clog2(Depth)]);<br>  &#x2F;&#x2F; 满：读写地址的MSB不同，其他位相同<br>  assign empty &#x3D;(r_addr[clog2(Depth)-1:0]&#x3D;&#x3D;w_addr[clog2(Depth)-1:0]) &amp;&amp; (r_addr[clog2(Depth)] &#x3D;&#x3D; w_addr[clog2(Depth)]);<br>  assign data_o &#x3D; dout;</p><p>  always@(posedge clk or negedge rst) begin<br>      if(!rst) begin<br>          r_addr &lt;&#x3D; 0;<br>          dout &lt;&#x3D; 0;<br>      end else begin<br>          r_addr &lt;&#x3D; re_flag?(r_addr+1) : r_addr ; &#x2F;&#x2F; 读地址累加<br>          dout &lt;&#x3D; re_flag?memory[r_addr[clog2(Depth)-1:0]]:dout; &#x2F;&#x2F; 数据输出<br>      end<br>  end<br>  always @(posedge clk or negedge rst) begin<br>      if(!rst) begin<br>          w_addr &lt;&#x3D; 0;<br>      end else begin<br>          w_addr &lt;&#x3D; we_flag?(w_addr+1) : w_addr; &#x2F;&#x2F; 写地址累加<br>          memory[w_addr[clog2(Depth)-1:0]] &lt;&#x3D; we_flag?data_i:memory[w_addr[clog2(Depth)-1:0]]; &#x2F;&#x2F; 写入数据<br>      end<br>  end<br>  assign usedw &#x3D; usedw_r;<br>  always @(posedge clk or negedge rst) begin<br>      if(!rst) begin<br>          usedw_r &lt;&#x3D; 0;<br>      end&#x2F;&#x2F;if<br>      else begin<br>          case({we_flag,re_flag})<br>          2’b00: begin<br>              usedw_r &lt;&#x3D; usedw_r;<br>          end&#x2F;&#x2F;00<br>          2’b01: begin<br>              if(usedw_r&#x3D;&#x3D;(Depth-1))<br>                  usedw_r &lt;&#x3D; usedw_r;<br>              else<br>                  usedw_r &lt;&#x3D; usedw_r + 1’b1;<br>          end&#x2F;&#x2F;01<br>          2’b10: begin<br>              if(usedw_r&#x3D;&#x3D;0)<br>                  usedw_r &lt;&#x3D; usedw_r;<br>              else<br>                  usedw_r &lt;&#x3D; usedw_r - 1’b1;<br>          end&#x2F;&#x2F;10<br>          2’b11: begin<br>              usedw_r &lt;&#x3D; usedw_r;<br>          end&#x2F;&#x2F;11<br>          default: usedw_r &lt;&#x3D; 0;<br>          endcase<br>      end&#x2F;&#x2F;else<br>  end&#x2F;&#x2F;always</p><p>  endmodule<br>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>Asynchronous</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>Asynchronous</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异步FIFO</title>
    <link href="/2019/04/13/IC/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F/%E5%BC%82%E6%AD%A5fifo/"/>
    <url>/2019/04/13/IC/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F/%E5%BC%82%E6%AD%A5fifo/</url>
    
    <content type="html"><![CDATA[<h3 id="异步fifo"><a href="#异步fifo" class="headerlink" title="异步fifo"></a>异步fifo</h3><p>  异步FIFO就是读写地址不同，要么不同频率，要么同频不同相。读地址和空标志由读时钟产生，写地址和满标志由写时钟产生<br>  <img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/%E5%BC%82%E6%AD%A5fifo/6.png"></p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol><li><p>异步fifo读写时钟不一致，当要产生fifo的空满标志位时，需要比较读写地址。比如产生空标志位需要在读时钟下采样写地址，并跟读地址进行比较。由于地址一般是多位，在读时钟下各位跳变不一样，产生毛刺，要过一段时间才能稳定，如果在不稳定阶段采样到了数据会发生错误</p><p><strong>解决方法是格雷码，格雷码每次跳变一位。</strong> 格雷码相邻数据只跳变一位</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/%E5%BC%82%E6%AD%A5fifo/%E5%BC%82%E6%AD%A5fifo1.png"></p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/%E5%BC%82%E6%AD%A5fifo/2.png"></p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/%E5%BC%82%E6%AD%A5fifo/3.png"></p></li><li><p><a href="http://guqian110.github.io/pages/2015/10/02/fifo_design_notes.html">跨时钟采样读写地址可能会有1T的延迟，但这个延迟并不会导致full&#x2F;empty错误置位。</a></p><h4 id="读"><a href="#读" class="headerlink" title="读"></a>读</h4></li></ol><p>如果地址信号传递到读时钟域时延时了 1T，此时接收端并不知道数据已经写入了 FIFO，仍然认为 FIFO 是空的，这种情况只会对 FIFO 的吞吐率 throughput 有影响，但是不会导致 underflow；   如下图，先写满 FIFO，然后开始读：在 t6 时 FIFO 读空，empty &#x3D; 1，在 t7 时，写入了一个新数据，此时 FIFO 内已经有有效数据了，但是 wr_ptr 同步到读时钟域要花费 2T，所以在 t9 时 empty &#x3D; 0。有两个时钟周期（t7, t8） rd 被阻塞了，但是并不影响 FIFO 正常工作。</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/%E5%BC%82%E6%AD%A5fifo/4.png"><br>wtr_ptr_asyn这个异步的写地址是读时钟域延迟两拍采样到的写地址，用来进行进行读空判断。</p><h4 id="写"><a href="#写" class="headerlink" title="写"></a>写</h4><p>如果地址信号传递到写时钟域时延是了 1T，此时发送端并不知道 FIFO 已经有空余地址了，仍然认为 FIFO 是满的，这种情况也是只会对 FIFO 的吞吐率 throughput 有影响，但是不会导致 overflow； 如下图，先写满 FIFO，然后开始读：在 t5 时，full &#x3D; 1，在 t6 时，读出了一个数据，此时 FIFO 已经有空余地址了，但是 rd_ptr 同步到写时钟域要花费 2T，所以在 t8 时 full &#x3D; 0。有两个时钟周期（t6, t7） wr 被阻塞了，但是并不影响 FIFO 正常工作。</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/%E5%BC%82%E6%AD%A5fifo/5.png"><br>rd_ptr_asyn这个异步的读地址是写时钟域延迟两拍采样到的读地址，用来进行进行写满判断。</p><h4 id="空满标志"><a href="#空满标志" class="headerlink" title="空满标志"></a>空满标志</h4><ol><li>异步fifo也可以增加一位地址位作为空满的判断，根据格雷码的格式</li></ol><p> <img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/%E5%BC%82%E6%AD%A5fifo/7.png"><br> 如上图，如果还是按照同步fifo的判断方式，读写地址一样时判断为空，如圆圈1，2，这样是正确的；但如果根据MSB不同，其他位相同，判断fifo满，如圆圈3，这样出错，此时fifo并没有满。</p><p>  异步FIFO增加一位地址用来判断空满。如果读写指针最高位不同，此时如果读写对同一块内存区域，那么会产生满标志。从上面格雷码中可以看到，对于内存地址只有三位，表示的FIFO空间只有8个字节，第四位是添加的一位。如果内存地址被套圈，比如读0000，写1100，最高位不同，次高位也不同，其他位相同。所以空满的关系如下：</p><p>  <strong>空：读写地址相同</strong></p><p>  <strong>满：MSB和次MSB位不同，其他位相同</strong></p><h4 id="Cummings异步fifo设计"><a href="#Cummings异步fifo设计" class="headerlink" title="Cummings异步fifo设计"></a>Cummings异步fifo设计</h4><p>以下是参考Cummings的异步fifo论文</p><p>2002-SD_Simulation and Synthesis Techniques for Asynchronous FIFO Design</p><p>FIFO的结构如下图</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/%E5%BC%82%E6%AD%A5fifo/afifo2.png"></p><p>其中格雷码转换器的结构如下图，将n位的二进制地址和其转换成的格雷码用寄存器寄存</p><p><img src="https://raw.githubusercontent.com/east1203/MarkdownPhoto/master/%E5%BC%82%E6%AD%A5fifo/afifo1.png"></p><p>这篇论文中fifo的空满判断：  <strong>空：读写地址相同；满：MSB和次MSB位不同，其他位相同。</strong></p><p>根据结构图分成五个子模块和一个top模块，代码如下：</p><p><strong>注意：代码基本上跟论文中的一样，编译通过了，但没有进行测试</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> asyn_fifo_top<br>#(  <br> <span class="hljs-keyword">parameter</span> WIDTH=<span class="hljs-number">8</span>,<br> <span class="hljs-keyword">parameter</span> DEPTH=<span class="hljs-number">4</span><br>)<br>(<br>  <span class="hljs-keyword">input</span> wclk,winc,wrst_n,<br>  <span class="hljs-keyword">input</span> rclk,rinc,rrst_n,<br>  <span class="hljs-keyword">input</span>[WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] data_i,<br>  <span class="hljs-keyword">output</span> [WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] data_o,<br>  <span class="hljs-keyword">output</span> full,<br>  <span class="hljs-keyword">output</span> empty<br>);<br><span class="hljs-keyword">wire</span> [DEPTH:<span class="hljs-number">0</span>] wptr,rptr;<br><span class="hljs-keyword">wire</span> [DEPTH  :<span class="hljs-number">0</span>] r2_wptr;<br><span class="hljs-keyword">wire</span> [DEPTH  :<span class="hljs-number">0</span>] w2_rptr;<br><span class="hljs-keyword">wire</span> [DEPTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] raddr,waddr;<br><br><span class="hljs-comment">// 写地址被采样到读时钟域</span><br>w2r <span class="hljs-variable">#(DEPTH) w2r_u(.rclk(rclk),.rrst_n(rrst_n),.wptr(wptr),.r2_wptr(r2_wptr))</span>;<br><span class="hljs-comment">// 读地址被采样到写时钟域</span><br>r2w <span class="hljs-variable">#(DEPTH) r2w_u(.wclk(wclk),.wrst_n(wrst_n),.rptr(rptr),.w2_rptr(w2_rptr))</span>;<br><span class="hljs-comment">// 空标志产生模块</span><br>empty_r <span class="hljs-variable">#(WIDTH,DEPTH) empty_u(.rclk(rclk),.rrst_n(rrst_n),.rinc(rinc),.r2_wptr(r2_wptr),.rptr(rptr),.raddr(raddr),.empty(empty))</span>;<br><span class="hljs-comment">// 满标志产生模块</span><br>full_w <span class="hljs-variable">#(WIDTH,DEPTH) full_u(.wclk(wclk),.wrst_n(wrst_n),.winc(winc),.w2_rptr(w2_rptr),.wptr(wptr),.waddr(waddr),.full(full))</span>;<br><span class="hljs-comment">// fifo读写模块</span><br>fifomem <span class="hljs-variable">#(WIDTH,DEPTH) mem_u(.wclk(wclk),.winc(winc),.full(full),.raddr(raddr),.waddr(waddr),.data_i(data_i),.data_o(data_o))</span>;<br><span class="hljs-keyword">endmodule</span><br><br><span class="hljs-comment">// w2r.v</span><br><span class="hljs-keyword">module</span> w2r<br>#(<br><span class="hljs-keyword">parameter</span> DEPTH=<span class="hljs-number">4</span><br>)<br>(<br><span class="hljs-keyword">input</span> rclk,rrst_n,<br><span class="hljs-keyword">input</span> [DEPTH:<span class="hljs-number">0</span>] wptr,<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>[DEPTH:<span class="hljs-number">0</span>] r2_wptr<br>);<br><br><span class="hljs-keyword">reg</span> [DEPTH:<span class="hljs-number">0</span>] r1_wptr;<br><br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> rclk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rrst_n) <span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">if</span>(rrst_n == <span class="hljs-number">1&#x27;b0</span>) &#123;r2_wptr,r1_wptr&#125; &lt;= <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">else</span> &#123;r2_wptr,r1_wptr&#125; &lt;= &#123;r1_wptr,wptr&#125;; <br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br><span class="hljs-comment">// r2w.v</span><br><span class="hljs-keyword">module</span> r2w<br>#(<br><span class="hljs-keyword">parameter</span> DEPTH=<span class="hljs-number">4</span><br>)<br>(<br><span class="hljs-keyword">input</span> wclk,wrst_n,<br><span class="hljs-keyword">input</span> [DEPTH:<span class="hljs-number">0</span>] rptr,<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [DEPTH:<span class="hljs-number">0</span>] w2_rptr<br>);<br><span class="hljs-keyword">reg</span> [DEPTH:<span class="hljs-number">0</span>] w1_rptr;<br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> wclk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> wrst_n) <span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">if</span>(wrst_n == <span class="hljs-number">1&#x27;b0</span>) &#123;w2_rptr,w1_rptr&#125; &lt;= <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">else</span> &#123;w2_rptr,w1_rptr&#125; &lt;= &#123;w1_rptr,rptr&#125;; <br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br><br><span class="hljs-comment">// empty_r.v</span><br><span class="hljs-keyword">module</span> empty_r<br>#(<br><span class="hljs-keyword">parameter</span> WIDTH=<span class="hljs-number">8</span>,<br><span class="hljs-keyword">parameter</span> DEPTH=<span class="hljs-number">4</span><br>)<br>(<br><span class="hljs-keyword">input</span> rclk,rrst_n,rinc,<br><span class="hljs-keyword">input</span> [DEPTH:<span class="hljs-number">0</span>] r2_wptr,<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>[DEPTH:<span class="hljs-number">0</span>] rptr,<br><span class="hljs-keyword">output</span> [DEPTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] raddr,<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> empty<br>);<br><span class="hljs-keyword">reg</span> [DEPTH:<span class="hljs-number">0</span>] rbin;<br><span class="hljs-keyword">wire</span> [DEPTH:<span class="hljs-number">0</span>] binnext,graynext;<br><span class="hljs-keyword">wire</span> empty_val;<br><span class="hljs-keyword">assign</span> binnext = (rinc &amp; !empty) ? rbin : rbin+<span class="hljs-number">1&#x27;b1</span>;<br><span class="hljs-keyword">assign</span> graynext = binnext ^ (binnext&gt;&gt;<span class="hljs-number">1</span>);<br><span class="hljs-keyword">assign</span> raddr = rbin[DEPTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];<br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> rclk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rrst_n) <span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">if</span>(rrst_n == <span class="hljs-number">1&#x27;b0</span>)    &#123;rbin,rptr&#125; &lt;= <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">else</span>   &#123;rbin,rptr&#125; &lt;= &#123;binnext,graynext&#125;;<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">// empty </span><br><span class="hljs-keyword">assign</span> empty_val = (r2_wptr==rptr);<br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> rclk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rrst_n) <span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">if</span>(rrst_n == <span class="hljs-number">1&#x27;b0</span>) empty &lt;= <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">else</span> empty &lt;= empty_val;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br><br><span class="hljs-comment">// full_w.v</span><br><span class="hljs-keyword">module</span> full_w<br>#(<br><span class="hljs-keyword">parameter</span> WIDTH=<span class="hljs-number">8</span>,<br><span class="hljs-keyword">parameter</span> DEPTH=<span class="hljs-number">4</span><br>)<br>(<br><span class="hljs-keyword">input</span> wclk,wrst_n,winc,<br><span class="hljs-keyword">input</span> [DEPTH:<span class="hljs-number">0</span>] w2_rptr,<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>[DEPTH:<span class="hljs-number">0</span>] wptr,<br><span class="hljs-keyword">output</span> [DEPTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] waddr,<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> full<br>);<br><span class="hljs-keyword">wire</span> full_val;<br><span class="hljs-keyword">reg</span> [WIDTH:<span class="hljs-number">0</span>] wbin;<br><span class="hljs-keyword">wire</span> [WIDTH:<span class="hljs-number">0</span>] binnext,graynext;<br><br><span class="hljs-keyword">assign</span> waddr = wbin[WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];<br><span class="hljs-keyword">assign</span> binnext = wbin + (winc &amp; !full);<br><span class="hljs-keyword">assign</span> graynext = binnext ^ (binnext&gt;&gt;<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> wclk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> wrst_n) <span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">if</span>(wrst_n==<span class="hljs-number">1&#x27;b0</span>) &#123;wbin,wptr&#125; &lt;= <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">else</span> &#123;wbin,wptr&#125; &lt;= &#123;binnext,graynext&#125;;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">assign</span> full_val = w2_rptr == &#123;~wptr[DEPTH:DEPTH-<span class="hljs-number">1</span>],wptr[DEPTH-<span class="hljs-number">2</span>:<span class="hljs-number">0</span>]&#125;;<br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> wclk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> wrst_n) <span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">if</span>(wrst_n==<span class="hljs-number">1&#x27;b0</span>) full &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>  <span class="hljs-keyword">else</span> full &lt;= full_val;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br><br><span class="hljs-comment">// fifomem.v</span><br><span class="hljs-keyword">module</span> fifomem<br>#(<br><span class="hljs-keyword">parameter</span> WIDTH=<span class="hljs-number">8</span>,<br><span class="hljs-keyword">parameter</span> DEPTH=<span class="hljs-number">4</span><br>)<br>(<br><span class="hljs-keyword">input</span> wclk,winc,full,<br><span class="hljs-keyword">input</span> [DEPTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] raddr,<br><span class="hljs-keyword">input</span> [DEPTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] waddr,<br><span class="hljs-keyword">input</span> [WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] data_i,<br><span class="hljs-keyword">output</span> [WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] data_o<br>);<br><span class="hljs-keyword">reg</span> [WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] memory[<span class="hljs-number">0</span>:(<span class="hljs-number">1</span>&lt;&lt;DEPTH)-<span class="hljs-number">1</span>];<br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> wclk ) <span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">if</span>(winc &amp; !full) memory[waddr] &lt;= data_i;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">assign</span> data_o = memory[raddr];<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>Asynchronous</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>Asynchronous</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生成仿真波形vcd vpd fsdb</title>
    <link href="/2019/04/11/tools/vcs/%E7%94%9F%E6%88%90%E4%BB%BF%E7%9C%9F%E6%B3%A2%E5%BD%A2.vcd%20.fsdb%20.vpd/"/>
    <url>/2019/04/11/tools/vcs/%E7%94%9F%E6%88%90%E4%BB%BF%E7%9C%9F%E6%B3%A2%E5%BD%A2.vcd%20.fsdb%20.vpd/</url>
    
    <content type="html"><![CDATA[<h3 id="1-verilog系统函数生成vcd"><a href="#1-verilog系统函数生成vcd" class="headerlink" title="1. verilog系统函数生成vcd"></a>1. verilog系统函数生成vcd</h3><p>VCD （Value Change Dump）是一个通用的格式。 VCD文件是IEEE1364标准(Verilog HDL语言标准)中定义的一种ASCII文件。它主要包含了头信息，变量的预定义和变量值的变化信息。正是因为它包含了信号的变化信息，就相当于记录了整个仿真的信息，我们可以用这个文件来再现仿真，也就能够显示波形。</p><p>特别说明的一点是，正是因为VCD记录了信号的完整变化信息，我们还可以通过VCD文件来估计设计的功耗，而这一点也是其他波形文件所不具备的。Encounter 和 PrimeTime PX （Prime Power）都可以通过输入网表文件，带功耗信息的库文件以及仿真后产生的VCD文件来实现功耗分析。</p><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 指明生成的文件名<br><span class="hljs-variable">$dumpfile</span>(<span class="hljs-string">&quot;tb.dump&quot;</span>) ;<br><span class="hljs-regexp">//</span><span class="hljs-string">&quot;tb.vcd&quot;</span>也可以<br><span class="hljs-regexp">//</span>dumpfile(<span class="hljs-string">&quot;tb.vcd&quot;</span>);<br><br><span class="hljs-regexp">//</span>记录所有变量的值，也可以给函数设置参数只记录某些模块的某些变量<br><span class="hljs-variable">$dumpfile</span>;<br><span class="hljs-regexp">//</span>还可以控制文件生成的时间，也可以不加这两句<br><span class="hljs-variable">$dumpfileon</span>; <span class="hljs-regexp">//</span>开始dump波形<br><span class="hljs-variable">$dumpfileoff</span>;<span class="hljs-regexp">//</span>停止<br></code></pre></td></tr></table></figure><h3 id="2-生成vpd波形"><a href="#2-生成vpd波形" class="headerlink" title="2. 生成vpd波形"></a>2. 生成vpd波形</h3><p>vpd波形是synopsys公司的vcs dve需要读入的文件格式，可以用<br>**$vpdpluson;**产生</p><h3 id="3-生成fsdb波形"><a href="#3-生成fsdb波形" class="headerlink" title="3. 生成fsdb波形"></a>3. 生成fsdb波形</h3><p>fsdb波形文件是verdi工具支持的文件格式，可以用vcs来产生。</p><p>步骤：</p><ol><li>设计环境变量</li></ol><p>   在.bashrc文件下设置NOVAS_HOME变量</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">NOVAS_HOME</span>=<span class="hljs-variable">$Synopsys_Dir</span>/Verdi2015<br></code></pre></td></tr></table></figure><ol start="2"><li>用System verilog系统函数生成fsdb波形</li></ol>  <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ruby">initial <span class="hljs-keyword">begin</span><br>  <span class="hljs-variable">$fsdbDumpfile</span>(<span class="hljs-string">&quot;tb.fsdb&quot;</span>);<br>  <span class="hljs-variable">$fsdbDumpvars</span>;<br>  <span class="hljs-variable">$fsdbDumpon</span>;<br>  <span class="hljs-comment">#10000;</span><br>  <span class="hljs-variable">$fsdbDumpoff</span>;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><ol start="3"><li><p>还要再VCS仿真命令中设置-P选项</p>  <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs livescript"> novas = <span class="hljs-string">&quot;/opt/Synopsys/Verdi2015/share/PLI/VCS/LINUXAMD64/novas.tab&quot;</span><br> pli = <span class="hljs-string">&quot;/opt/Synopsys/Verdi2015/share/PLI/VCS/LINUXAMD64/pli.a&quot;</span><br>vcs <span class="hljs-string">\</span><br>-full64<span class="hljs-string">\</span><br>+v2k<span class="hljs-string">\</span><br>-f filelist<span class="hljs-string">\</span><br>-debug_all<span class="hljs-string">\</span><br>-sverilog<span class="hljs-string">\</span><br>-R<span class="hljs-string">\</span><br>-P $(novas) $(pli)<br></code></pre></td></tr></table></figure></li><li><p>另一个参考方法</p></li></ol><p><a href="http://blog.chinaaet.com/heyuanpi/p/5100058552">http://blog.chinaaet.com/heyuanpi/p/5100058552</a></p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
      <category>EDA</category>
      
      <category>vcs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vcs</tag>
      
      <tag>EDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2019/03/11/others/hello-world/"/>
    <url>/2019/03/11/others/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>others</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>欢迎使用 Cmd Markdown 编辑阅读器</title>
    <link href="/2019/03/11/others/%E6%AC%A2%E8%BF%8E%E4%BD%BF%E7%94%A8%20Cmd%20Markdown%20%E7%BC%96%E8%BE%91%E9%98%85%E8%AF%BB%E5%99%A8/"/>
    <url>/2019/03/11/others/%E6%AC%A2%E8%BF%8E%E4%BD%BF%E7%94%A8%20Cmd%20Markdown%20%E7%BC%96%E8%BE%91%E9%98%85%E8%AF%BB%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是-Cmd-Markdown"><a href="#什么是-Cmd-Markdown" class="headerlink" title="什么是 Cmd Markdown"></a>什么是 Cmd Markdown</h2><p>您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 <strong>编辑&#x2F;发布&#x2F;阅读</strong> Markdown 的在线平台——您可以在任何地方，任何系统&#x2F;设备上管理这里的文字。</p><h3 id="1-实时同步预览"><a href="#1-实时同步预览" class="headerlink" title="1. 实时同步预览"></a>1. 实时同步预览</h3><p>我们将 Cmd Markdown 的主界面一分为二，左边为<strong>编辑区</strong>，右边为<strong>预览区</strong>，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！</p><h3 id="2-编辑工具栏"><a href="#2-编辑工具栏" class="headerlink" title="2. 编辑工具栏"></a>2. 编辑工具栏</h3><p>也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 <strong>编辑区</strong> 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。</p><p><img src="https://www.zybuluo.com/static/img/toolbar-editor.png" alt="tool-editor"></p><h3 id="3-编辑模式"><a href="#3-编辑模式" class="headerlink" title="3. 编辑模式"></a>3. 编辑模式</h3><p>完全心无旁骛的方式编辑文字：点击 <strong>编辑工具栏</strong> 最右侧的拉伸按钮或者按下 <code>Ctrl + M</code>，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！</p><h3 id="4-实时的云端文稿"><a href="#4-实时的云端文稿" class="headerlink" title="4. 实时的云端文稿"></a>4. 实时的云端文稿</h3><p>为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 <strong>编辑工具栏</strong> 的最右侧提示 <code>已保存</code> 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。</p><h3 id="5-离线模式"><a href="#5-离线模式" class="headerlink" title="5. 离线模式"></a>5. 离线模式</h3><p>在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。</p><h3 id="6-管理工具栏"><a href="#6-管理工具栏" class="headerlink" title="6. 管理工具栏"></a>6. 管理工具栏</h3><p>为了便于管理您的文稿，在 <strong>预览区</strong> 的顶部放置了如下所示的 <strong>管理工具栏</strong>：</p><p><img src="https://www.zybuluo.com/static/img/toolbar-manager.jpg" alt="tool-manager"></p><p>通过管理工具栏可以：</p><p><i class="icon-share"></i> 发布：将当前的文稿生成固定链接，在网络上发布，分享<br><i class="icon-file"></i> 新建：开始撰写一篇新的文稿<br><i class="icon-trash"></i> 删除：删除当前的文稿<br><i class="icon-cloud"></i> 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地<br><i class="icon-reorder"></i> 列表：所有新增和过往的文稿都可以在这里查看、操作<br><i class="icon-pencil"></i> 模式：切换 普通&#x2F;Vim&#x2F;Emacs 编辑模式</p><h3 id="7-阅读工具栏"><a href="#7-阅读工具栏" class="headerlink" title="7. 阅读工具栏"></a>7. 阅读工具栏</h3><p><img src="https://www.zybuluo.com/static/img/toolbar-reader.jpg" alt="tool-manager"></p><p>通过 <strong>预览区</strong> 右上角的 <strong>阅读工具栏</strong>，可以查看当前文稿的目录并增强阅读体验。</p><p>工具栏上的五个图标依次为：</p><p><i class="icon-list"></i> 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落<br><i class="icon-chevron-sign-left"></i> 视图：互换左边编辑区和右边预览区的位置<br><i class="icon-adjust"></i> 主题：内置了黑白两种模式的主题，试试 <strong>黑色主题</strong>，超炫！<br><i class="icon-desktop"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验<br><i class="icon-fullscreen"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境</p><h3 id="8-阅读模式"><a href="#8-阅读模式" class="headerlink" title="8. 阅读模式"></a>8. 阅读模式</h3><p>在 <strong>阅读工具栏</strong> 点击 <i class="icon-desktop"></i> 或者按下 <code>Ctrl+Alt+M</code> 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。</p><h3 id="9-标签、分类和搜索"><a href="#9-标签、分类和搜索" class="headerlink" title="9. 标签、分类和搜索"></a>9. 标签、分类和搜索</h3><p>在编辑区任意行首位置输入以下格式的文字可以标签当前文档：</p><p>标签： 未分类</p><p>标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：</p><p><img src="https://www.zybuluo.com/static/img/file-list.png" alt="file-list"></p><h3 id="10-文稿发布和分享"><a href="#10-文稿发布和分享" class="headerlink" title="10. 文稿发布和分享"></a>10. 文稿发布和分享</h3><p>在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class="icon-share"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！</p><hr><p>再一次感谢您花费时间阅读这份欢迎稿，点击 <i class="icon-file"></i> (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！</p><p>作者 <a href="http://weibo.com/ghosert">@ghosert</a><br>2016 年 07月 07日</p><p>[^LaTeX]: 支持 <strong>LaTeX</strong> 编辑显示支持，例如：$\sum_{i&#x3D;1}^n a_i&#x3D;0$， 访问 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">MathJax</a> 参考更多使用方法。</p><p>[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，<strong>四十一</strong>种主流编程语言。</p>]]></content>
    
    
    <categories>
      
      <category>others</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>git使用</title>
    <link href="/2019/03/11/tools/git/git%E4%BD%BF%E7%94%A8/"/>
    <url>/2019/03/11/tools/git/git%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="git四个区域"><a href="#git四个区域" class="headerlink" title="git四个区域"></a>git四个区域</h3><ol><li><h4 id="remote-repository"><a href="#remote-repository" class="headerlink" title="remote repository"></a>remote repository</h4></li><li><h4 id="local-repository"><a href="#local-repository" class="headerlink" title="local repository"></a>local repository</h4></li></ol><p> git commit之后，会将stage area区域的文件提交到local repository<br> 3. #### stage area 临时区域</p><p> git add文件之后，会将文件的内容更新到临时区域<br> 4. #### work area<br> 就是仓库目录下的那些源文件</p><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><ol><li><p>本机和github账户绑定</p></li><li><p>在文件夹中打开git  bash</p></li><li><p>git init 初始化一个仓库，当然也可以clone一个仓库来初始化</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">git init<br></code></pre></td></tr></table></figure></li><li><p>git add filename 跟踪本地要修改的文件，也就是建立文件和本地仓库的联系，让仓库直到打算要提交哪些文件，如果想要取消这种联系用git remove filename</p></li><li><p>git commit -m “message” 将跟踪到的修改记录添加到本地仓库的记录中，为了在上传的时候git来比较是否修改了文件.将修改的文件提交到了真正的本地仓库区域，在object文件夹下。message随便写，是个提示信息</p></li><li><p>git remote add origin 仓库的url   <strong>关联仓库</strong>，就是将文件提交到这个仓库,origin是这个远端仓库名</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote add origin https://github.com/east1203/MarkDownFiles.git<br></code></pre></td></tr></table></figure><p>  如果出现错误fatal: remote origin already exists，那么运行：</p><p>  git remote rm origin再执行“git remote add origin 仓库的url”</p><div class="code-wrapper"><pre><code class="hljs">7. git pull origin master</code></pre></div><p>如果出现错误<strong>failed to push some refs to</strong>就用这个命令</p><p> 把remote repository的内容下下来，跟local repository合并</p><p>  如果出错，加上–allow-unrelated-histories 选项<br>  8. git push -u origin master 上传文件</p><h3 id="删除仓库中的文件"><a href="#删除仓库中的文件" class="headerlink" title="删除仓库中的文件"></a>删除仓库中的文件</h3><ol><li>git rm -r –cached filename   要删除的文件名</li><li>git commit -m “remove file”</li><li>git push -u origin master</li></ol><h3 id="克隆仓库到本地文件夹"><a href="#克隆仓库到本地文件夹" class="headerlink" title="克隆仓库到本地文件夹"></a>克隆仓库到本地文件夹</h3><p>  git clone 仓库的url</p><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><ol><li><p>git status 跟踪本地仓库状态</p></li><li><p>.gitignore文件 在仓库目录下，建立一个.gitignore文件，里面可以写不想要提交的文件的名字，那么git在add所有文件文件的时候会避免这些文件</p></li><li><h4 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h4></li></ol><p> git diff –staged : 比较work area和stage area中文件有没有不同，默认git diff不加任何Option就是这个</p><p> git diff –cached : 比较stage area和local repository中的文件的不同。</p><ol start="4"><li>git reset &#x2F; git checkout 恢复文件</li></ol><p> 如果删除了文件，但是没有git commit到本地仓库，那么还可以恢复过来。</p><p> 先用git reset ,(这里可以git status查看以下提示)</p><p> 然后git checkout – deletedfilename</p><p> 这样就可以恢复了，但是如果git commit了，这样操作不能恢复。<br> 5. git log</p><p> 查看都commit哪些。就是查看repository的版本<br> 6. git whatchanged</p><p> 有哪些修改<br> 7. pull  &#x2F; fetch</p><p> pull 将remote repository下载下来，跟本地repository合并</p><p> fetch 也是把remote repository下载，但是不跟本地合并，而是建立一个新的分支</p><h3 id="git分支管理"><a href="#git分支管理" class="headerlink" title="git分支管理"></a>git分支管理</h3><h4 id="1-git-branch"><a href="#1-git-branch" class="headerlink" title="1. git branch"></a>1. git branch</h4><p> git branch 查看有哪些分支</p><p> git branch branchname 新建立一个分支</p><p> git checkout branchname 切换到另一个分支</p><p> git show-branch 显示分支的差异</p><p> git diff branch1 branch2 比较分支</p><h4 id="2-合并分支-merge"><a href="#2-合并分支-merge" class="headerlink" title="2. 合并分支 merge"></a>2. 合并分支 merge</h4><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><p> 假如当前分支是master，</p><p> git merge “merge message随便写” HEAD branchname</p><p> HEAD就是当前分支master的最新版本，不写的话默认，branchname是要合并过来的分支</p><h3 id="撤销添加或者提交的内容"><a href="#撤销添加或者提交的内容" class="headerlink" title="撤销添加或者提交的内容"></a>撤销添加或者提交的内容</h3><p>参考自CSDN<a href="https://blog.csdn.net/kongbaidepao/article/details/52253774"><strong>git add ， git commit 添加错文件 撤销</strong></a></p><h4 id="1-git-add-添加-多余文件"><a href="#1-git-add-添加-多余文件" class="headerlink" title="1. git add 添加 多余文件"></a>1. git add 添加 多余文件</h4><p>这样的错误是由于， 有的时候 可能</p><p>git add . （空格+ 点） 表示当前目录所有文件，不小心就会提交其他文件</p><p>git add 如果添加了错误的文件的话</p><p>撤销操作</p><p>git status 先看一下add 中的文件<br>git reset HEAD 如果后面什么都不跟的话 就是上一次add 里面的全部撤销了<br>git reset HEAD XXX&#x2F;XXX&#x2F;XXX.java 就是对某个文件进行撤销了</p><h4 id="2-git-commit-错误"><a href="#2-git-commit-错误" class="headerlink" title="2. git commit 错误"></a>2. git commit 错误</h4><p>如果不小心 弄错了 git add后 ， 又 git commit 了。<br>先使用<br>git log 查看节点<br>commit xxxxxxxxxxxxxxxxxxxxxxxxxx<br>Merge:<br>Author:<br>Date:</p><p>然后<br>git reset commit_id</p><p>over</p><p>PS：还没有 push 也就是 repo upload 的时候</p><p>git reset commit_id （回退到上一个 提交的节点 代码还是原来你修改的）<br>git reset –hard commit_id （回退到上一个commit节点， 代码也发生了改变，变成上一次的）</p><h4 id="3-如果要是-提交了以后，可以使用-git-revert"><a href="#3-如果要是-提交了以后，可以使用-git-revert" class="headerlink" title="3.如果要是 提交了以后，可以使用 git revert"></a>3.如果要是 提交了以后，可以使用 git revert</h4><p>还原已经提交的修改<br>此次操作之前和之后的commit和history都会保留，并且把这次撤销作为一次最新的提交<br>git revert HEAD 撤销前一次 commit<br>git revert HEAD^ 撤销前前一次 commit<br>git revert commit-id (撤销指定的版本，撤销也会作为一次提交进行保存）<br>git revert是提交一个新的版本，将需要revert的版本的内容再反向修改回去，版本会递增，不影响之前提交的内容。</p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11 新特性</title>
    <link href="/2019/03/09/C++/C++11%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2019/03/09/C++/C++11%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="用花括号来初始化变量"><a href="#用花括号来初始化变量" class="headerlink" title="用花括号来初始化变量{}"></a>用花括号来初始化变量{}</h4></li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs abnf">int i&#123;<span class="hljs-number">10</span>&#125;<span class="hljs-comment">;</span><br>int i(<span class="hljs-number">10</span>)<span class="hljs-comment">;</span><br>int i <span class="hljs-operator">=</span> <span class="hljs-number">10</span><span class="hljs-comment">;</span><br>int i <span class="hljs-operator">=</span> &#123;<span class="hljs-number">10</span>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ul><li><h4 id="auto类型——编译器通过初始值自动推算变量的类型"><a href="#auto类型——编译器通过初始值自动推算变量的类型" class="headerlink" title="auto类型——编译器通过初始值自动推算变量的类型"></a>auto类型——编译器通过初始值自动推算变量的类型</h4>当我们希望编译器根据表达式的结果来确定变量的类型，并且通过表达式结果来赋值</li><li><h4 id="decltype类型"><a href="#decltype类型" class="headerlink" title="decltype类型"></a>decltype类型</h4></li></ul><p> 当我们希望编译器根据表达式的结果来确定变量的类型，但又不是通过表达式结果来赋值时，用decltype声明变量。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">decltype(f()) <span class="hljs-built_in">sum</span> = x; //根据函数f()的返回值来确定<span class="hljs-built_in">sum</span>类型，并用x给<span class="hljs-built_in">sum</span>赋值<br></code></pre></td></tr></table></figure><ul><li><h4 id="范围for"><a href="#范围for" class="headerlink" title="范围for"></a>范围for</h4><p>传统的for循环就不多说了，C++11引进的新的for循环——范围for，能够遍历容器或者其他序列的所有元素，更加简洁:</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">for (declaration:expression)<br>&#123;&#125;<br></code></pre></td></tr></table></figure><p>  其中expression是序列，可以是花括号括起来的一组值，数组或者vector\list之类的容器。declaration是个变量，它的类型是expression中元素类型，所以一般用auto类型让编译器自己判断。</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">vector</span>&lt;int&gt; v=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-attribute">for</span>(auto i:v)<br>  <span class="hljs-attribute">cout</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-attribute">cout</span>&lt;&lt;endl;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++问题记录(1)</title>
    <link href="/2019/03/09/C++/%E4%B8%80%E4%BA%9BC++%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95(1)/"/>
    <url>/2019/03/09/C++/%E4%B8%80%E4%BA%9BC++%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95(1)/</url>
    
    <content type="html"><![CDATA[<hr><h4 id="1-模板函数定义在-h文件"><a href="#1-模板函数定义在-h文件" class="headerlink" title="1. 模板函数定义在.h文件"></a>1. 模板函数定义在.h文件</h4><p>对普通函数来说，声明放在头文件中，定义放在源文件中，其它的地方要使用该函数时，仅需要包含头文件即可，<em><strong>因为编译器编译时是以一个源文件作为单元编译的，当它遇到不在本文件中定义的函数时，若能够找到其声明，则会将此符号放在本编译单元的外部符号表中，链接的时候自然就可以找到该符号的定义了。</strong></em></p><p>而对模板函数来说，首先明确，<strong>模板函数是在编译器遇到使用模板的代码时才将模板函数实例化的。</strong> 若将模板函数声明放在tem.h，模板定义放在tem.cpp,在main.cpp中包含头文件，调用add,按道理说应该实例化int add(int,int)函数，即生成add函数的相应代码，但是此时仅有声明，找不到定义，因此此时，它只会实例化函数的符号，并不会实例化函数的实现，即这个时候，在main.o编译单元内，它只是将add函数作为一个外部符号，这就是与普通函数的区别，对普通函数来说，此时的add函数已经由编译器生成相应的代码了，而对模板函数来说，此时并没有生成add函数对应的代码。此时编译main.cpp单元不会报错，但链接就会出现add函数未定义的错误。</p><h4 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a><a href="https://blog.csdn.net/cllcsy/article/details/50485324">原文链接</a></h4><hr><h4 id="2-类型别名"><a href="#2-类型别名" class="headerlink" title="2. 类型别名"></a>2. 类型别名</h4><p>  使用方法：</p>  <figure class="highlight angelscript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">typedef</span> 别名 原本类型名<br></code></pre></td></tr></table></figure><p>  C++11 中引入了新的定义方法，原来的也可以用<br>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-keyword">using</span> 别名 = 原本类型名<br></code></pre></td></tr></table></figure><br>  <em><strong>类型别名在使用的时候不能简单理解为把类型别名替换成原本的样子</strong></em></p><p>  例如：</p>  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">typedef char *pstring<span class="hljs-comment">;</span><br>const pstring cstr <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>  这里的<strong>cstr是指向char的常量指针，而不是指向char常量的指针</strong>。pstring是char指针，const 修饰pstring，是在修饰指针而不是常量。不能理解成<code>const char* cstr=0</code>.</p><ul><li><h4 id="string对象初始化C风格的char指针"><a href="#string对象初始化C风格的char指针" class="headerlink" title="string对象初始化C风格的char指针"></a>string对象初始化C风格的char指针</h4><p>C++中的string字符串类来源于<string>文件。</p><p>C风格的字符串是以空格’\0’结尾的字符数组，可以直接用这种字符数组给string对象赋值，但反之不可以。为了解决这一问题，string中有一个成员函数c_str().使用如下：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">string str <span class="hljs-operator">=</span> <span class="hljs-string">&quot;This is a test&quot;</span><span class="hljs-comment">;</span><br>const char* ch <span class="hljs-operator">=</span> str.c_str()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><h4 id="预处理器追踪定义的几个调试变量"><a href="#预处理器追踪定义的几个调试变量" class="headerlink" title="预处理器追踪定义的几个调试变量"></a>预处理器追踪定义的几个调试变量</h4><ol><li>_<em>func</em>_ : 当前运行的函数名</li><li>_<em>FILE</em>_ : 存放文件名的字符串字面值</li><li>_<em>LINE</em>_ : 存放当前行号的整性字面值</li><li>_<em>TIME</em>_ : 存放文件编译时间的字符串字面值</li><li>_<em>DATE</em>_ : 存放文件编译日期的字符攒字面值</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板类、模板函数声明定义在一起</title>
    <link href="/2019/03/09/C++/%E6%A8%A1%E6%9D%BF%E7%B1%BB%E3%80%81%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%AE%9A%E4%B9%89%E5%9C%A8%E4%B8%80%E8%B5%B7/"/>
    <url>/2019/03/09/C++/%E6%A8%A1%E6%9D%BF%E7%B1%BB%E3%80%81%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%AE%9A%E4%B9%89%E5%9C%A8%E4%B8%80%E8%B5%B7/</url>
    
    <content type="html"><![CDATA[<p><em><strong>模板函数、模板类声明和定义要放在一起，不要再.h中声明了，然后再.cpp中定义，这要编译器再链接时会提示找不到函数或类的标识符。</strong></em></p><p><strong>这是因为编译时是以文件为基础逐个文件编译的。对于普通的函数，如果定义在.h，实现在.cpp文件，程序在执行的时候可以通过.h文件找到函数在.cpp文件中的定义，可以执行。</strong></p><p>** 但是模板函数如果定义在.h,实现在.cpp文件， 程序在执行的时候找不到函数的实现——不知道模板函数中的类型到底是什么，所以提示找不到标识符之类的错误 **</p><h3 id="模板函数"><a href="#模板函数" class="headerlink" title="模板函数"></a>模板函数</h3><ul><li><p>定义：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs angelscript">templete &lt;<span class="hljs-keyword">class</span>\<span class="hljs-symbol">typename</span> <span class="hljs-symbol">T</span>&gt; 返回类型 函数名（包含类型<span class="hljs-symbol">T</span>的参数列表）<br>&#123;<br>函数主体;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用：</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">函数名（参数列表）<br></code></pre></td></tr></table></figure></li><li><p>例子：</p>  <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt; <span class="hljs-symbol">T</span> <span class="hljs-symbol">add</span>(<span class="hljs-symbol">const</span> <span class="hljs-symbol">T</span>&amp; <span class="hljs-symbol">a, <span class="hljs-symbol">const</span></span> <span class="hljs-symbol">T</span>&amp; <span class="hljs-symbol">b</span>)<br>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-built_in">int</span> main(<span class="hljs-built_in">void</span>)<br>&#123;<br><span class="hljs-built_in">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">int</span> b = <span class="hljs-number">2</span>;<br>cout &lt;&lt; add(a, b) &lt;&lt; endl;<br><span class="hljs-built_in">float</span> n1 = <span class="hljs-number">3.0</span>;<br><span class="hljs-built_in">float</span> n2 = <span class="hljs-number">4.5</span>;<br>cout &lt;&lt; add(n1, n2) &lt;&lt; endl;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="模板类"><a href="#模板类" class="headerlink" title="模板类"></a>模板类</h3></li><li><p>定义：</p>  <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template &lt;<span class="hljs-keyword">class</span>\<span class="hljs-symbol">typename</span> <span class="hljs-symbol">T</span>&gt; <span class="hljs-symbol">class</span> 类名&#123;<br>   类定义<br>  &#125;；<br></code></pre></td></tr></table></figure></li><li><p>类外声明成员函数</p>  <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br>返回类型 类名&lt;<span class="hljs-symbol">T</span>&gt;::函数名（参数）&#123;定义&#125;<br></code></pre></td></tr></table></figure><p>  如果返回类型是类对象，形式为 ：类名<T>，而不只是类名</p></li><li><p>使用——实例化对象：</p>  <figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">类名<span class="hljs-attribute">&lt;数据类型（可以是自定义类型也可以是基本类型）&gt;</span> 对象名；<br></code></pre></td></tr></table></figure></li><li><p><strong>注意</strong></p></li></ul><p>  <em><strong>在定义成员函数的时候，不能使用参数列表赋值</strong></em></p><ul><li>例子：</li></ul>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test1</span>()</span><br>&#123;<br><span class="hljs-built_in">int</span> n = <span class="hljs-number">10</span>;<br><span class="hljs-function">ForTest&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">t1</span>(<span class="hljs-params">n</span>)</span>;<br>cout &lt;&lt; t1.<span class="hljs-keyword">get</span>() &lt;&lt; endl;<br>t1.<span class="hljs-keyword">set</span>(<span class="hljs-number">20</span>);<br>cout &lt;&lt; t1.<span class="hljs-keyword">get</span>() &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)</span><br>&#123;<br>test1();<br><br><span class="hljs-function">test <span class="hljs-title">t1</span>(<span class="hljs-params"><span class="hljs-number">1</span></span>), <span class="hljs-title">t2</span>(<span class="hljs-params"><span class="hljs-number">2</span></span>)</span>;<br>cout &lt;&lt; t1.<span class="hljs-keyword">get</span>() &lt;&lt; <span class="hljs-string">&quot;   &quot;</span> &lt;&lt; t2.<span class="hljs-keyword">get</span>() &lt;&lt; endl;<br><br><span class="hljs-function">SmPt&lt;test&gt; <span class="hljs-title">s1</span>(<span class="hljs-params">test(<span class="hljs-number">1</span></span>))</span>;<br><span class="hljs-function">SmPt&lt;test&gt; <span class="hljs-title">s2</span> (<span class="hljs-params">s1</span>)</span>;<br>s1.<span class="hljs-keyword">get</span>()-&gt;<span class="hljs-keyword">set</span>(<span class="hljs-number">10</span>);<br>cout &lt;&lt; *s1.<span class="hljs-keyword">get</span>() &lt;&lt; endl;<br>cout &lt;&lt; *s2.<span class="hljs-keyword">get</span>() &lt;&lt; endl;<br><br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>模板类声明为其他类的友元类</li></ul><p>  那么在其他类中，需要这么写：<br>  <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span>\<span class="hljs-symbol">typename</span> <span class="hljs-symbol">T</span>&gt; <span class="hljs-symbol">friend</span> <span class="hljs-symbol">class</span> 模板类名<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Verilog小电路(1)</title>
    <link href="/2019/03/09/Verilog/Verilog%E5%B0%8F%E7%94%B5%E8%B7%AF(1)/"/>
    <url>/2019/03/09/Verilog/Verilog%E5%B0%8F%E7%94%B5%E8%B7%AF(1)/</url>
    
    <content type="html"><![CDATA[<ul><li>1 存储器建模</li><li>2 三分频时钟，占空比50%</li><li>3 普通分频–2分频 4分频</li><li>4 同步复位&#x2F;异步复位&#x2F;异步复位同步释放</li><li>5 串并转化电路</li></ul><h4 id="1-存储器建模"><a href="#1-存储器建模" class="headerlink" title="1. 存储器建模"></a>1. 存储器建模</h4><figure class="highlight stata"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs stata"> module ram_basic (clk, <span class="hljs-keyword">CS</span>, WR, addr, data_in, data_out, <span class="hljs-keyword">en</span>);<br> <span class="hljs-keyword">input</span>         clk;<br> <span class="hljs-keyword">input</span>         <span class="hljs-keyword">CS</span>;  <span class="hljs-comment">//CS = 1, RAM enable</span><br> <span class="hljs-keyword">input</span>         WR;  <span class="hljs-comment">//WR =1 then WRite enable; WR = 0 then read enable</span><br> <span class="hljs-keyword">input</span>         <span class="hljs-keyword">en</span>;  <span class="hljs-comment">//data_out enable, convert the data sequency</span><br> <span class="hljs-keyword">input</span>  [5:0]  addr;<br> <span class="hljs-keyword">input</span>  [7:0]  data_in;<br> output [7:0]  data_out;<br><br> <span class="hljs-keyword">reg</span> [7:0] RAM8x64 [0:63];<br> <span class="hljs-keyword">reg</span> [7:0] mem_data;<br><br>     always @ (posedge clk)<br>         <span class="hljs-keyword">if</span> (WR &amp;&amp; <span class="hljs-keyword">CS</span>) <span class="hljs-comment">//WRite</span><br>            RAM8x64 [addr] &lt;= data_in [7:0];<br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (~WR &amp;&amp; <span class="hljs-keyword">CS</span> ) <span class="hljs-comment">// read</span><br>            mem_data &lt;= RAM8x64 [addr];<br><br>  assign data_out = (<span class="hljs-keyword">en</span>)? mem_data[7:0] : &#123;~mem_data[7], mem_data[6:0]&#125;;<br><br>endmodule<br></code></pre></td></tr></table></figure><h4 id="2-三分频时钟，占空比50"><a href="#2-三分频时钟，占空比50" class="headerlink" title="2.  三分频时钟，占空比50%"></a>2.  三分频时钟，占空比50%</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs verilog"> <span class="hljs-keyword">module</span> clk_3div (clk,reset,clk_out);<br><br>  <span class="hljs-keyword">input</span> clk, reset;<br>  <span class="hljs-keyword">output</span> clk_out;<br>  <span class="hljs-keyword">reg</span>[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] state;<br>  <span class="hljs-keyword">reg</span> clk1;<br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> reset)<br>      <span class="hljs-keyword">if</span>(!reset)<br>         state&lt;=<span class="hljs-number">2&#x27;b00</span>;<br>      <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">case</span>(state)<br>          <span class="hljs-number">2&#x27;b00</span>:state&lt;=<span class="hljs-number">2&#x27;b01</span>;<br>          <span class="hljs-number">2&#x27;b01</span>:state&lt;=<span class="hljs-number">2&#x27;b11</span>;<br>          <span class="hljs-number">2&#x27;b11</span>:state&lt;=<span class="hljs-number">2&#x27;b00</span>;<br>          <span class="hljs-keyword">default</span>:state&lt;=<span class="hljs-number">2&#x27;b00</span>;<br>        <span class="hljs-keyword">endcase</span><br><br>  <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">negedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> reset)<br>      <span class="hljs-keyword">if</span>(!reset)<br>         clk1&lt;=<span class="hljs-number">1&#x27;b0</span>;<br>      <span class="hljs-keyword">else</span><br>         clk1&lt;=state[<span class="hljs-number">0</span>];<br><br>  <span class="hljs-keyword">assign</span> clk_out=state[<span class="hljs-number">0</span>]&amp;clk1;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h4 id="3-普通分频–2分频-4分频"><a href="#3-普通分频–2分频-4分频" class="headerlink" title="3. 普通分频–2分频 4分频"></a>3. 普通分频–2分频 4分频</h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">module</span> <span class="hljs-type">clk_div</span><span class="hljs-type">_phase</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">rst</span><span class="hljs-operator">,</span> <span class="hljs-type">clk_</span><span class="hljs-number">200</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-type">clk_</span><span class="hljs-number">100</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-type">clk_</span><span class="hljs-number">50</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-type">clk_</span><span class="hljs-number">25</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br><br><span class="hljs-variable">input</span>        <span class="hljs-type">clk_</span><span class="hljs-number">200</span><span class="hljs-built_in">K</span><span class="hljs-operator">;</span><br><span class="hljs-variable">input</span>        <span class="hljs-variable">rst</span><span class="hljs-operator">;</span><br><span class="hljs-variable">output</span>       <span class="hljs-type">clk_</span><span class="hljs-number">100</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-type">clk_</span><span class="hljs-number">50</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-type">clk_</span><span class="hljs-number">25</span><span class="hljs-built_in">K</span><span class="hljs-operator">;</span><br><span class="hljs-variable">wire</span>         <span class="hljs-type">clk_</span><span class="hljs-number">100</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-type">clk_</span><span class="hljs-number">50</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-type">clk_</span><span class="hljs-number">25</span><span class="hljs-built_in">K</span><span class="hljs-operator">;</span><br><br><span class="hljs-variable">reg</span> <span class="hljs-punctuation">[</span><span class="hljs-number">2</span><span class="hljs-operator">:</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span> <span class="hljs-variable">cnt</span><span class="hljs-operator">;</span><br><br><span class="hljs-variable">always</span> <span class="hljs-operator">@</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">posedge</span> <span class="hljs-type">clk_</span><span class="hljs-number">200</span><span class="hljs-built_in">K</span> <span class="hljs-variable">or</span> <span class="hljs-variable">negedge</span> <span class="hljs-variable">rst</span><span class="hljs-punctuation">)</span><br>   <span class="hljs-variable">if</span> <span class="hljs-punctuation">(</span><span class="hljs-operator">!</span><span class="hljs-variable">rst</span><span class="hljs-punctuation">)</span><br>      <span class="hljs-variable">cnt</span> <span class="hljs-operator">&lt;=</span> <span class="hljs-number">3</span><span class="hljs-operator">&#x27;</span><span class="hljs-variable">b000</span><span class="hljs-operator">;</span><br>   <span class="hljs-variable">else</span><br>      <span class="hljs-variable">cnt</span> <span class="hljs-operator">&lt;=</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span><span class="hljs-operator">;</span><br><br><span class="hljs-variable">assign</span> <span class="hljs-type">clk_</span><span class="hljs-number">100</span><span class="hljs-built_in">K</span> <span class="hljs-operator">=</span> <span class="hljs-operator">~</span><span class="hljs-variable">cnt</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br><span class="hljs-variable">assign</span> <span class="hljs-type">clk_</span><span class="hljs-number">50</span><span class="hljs-built_in">K</span>  <span class="hljs-operator">=</span> <span class="hljs-operator">~</span><span class="hljs-variable">cnt</span> <span class="hljs-punctuation">[</span><span class="hljs-number">1</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br><span class="hljs-variable">assign</span> <span class="hljs-type">clk_</span><span class="hljs-number">25</span><span class="hljs-built_in">K</span>  <span class="hljs-operator">=</span> <span class="hljs-operator">~</span><span class="hljs-variable">cnt</span> <span class="hljs-punctuation">[</span><span class="hljs-number">2</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br><br><span class="hljs-variable">endmodule</span><br></code></pre></td></tr></table></figure><h4 id="4-同步复位-x2F-异步复位-x2F-异步复位同步释放"><a href="#4-同步复位-x2F-异步复位-x2F-异步复位同步释放" class="headerlink" title="4. 同步复位&#x2F;异步复位&#x2F;异步复位同步释放"></a>4. 同步复位&#x2F;异步复位&#x2F;异步复位同步释放</h4><p>大多数的PLD和ASIC库中的触发器包含异步复位端口。自己考到的RTL大多是异步复位。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rst_n)<br></code></pre></td></tr></table></figure><p>无论异步还是同步都有优缺点，推荐采用异步复位同步释放的方式。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs verilog"> <span class="hljs-keyword">module</span> asyn_rst_syn_release(clk, rst_, cnt1, cnt2);<br><br><span class="hljs-keyword">input</span>        clk;<br><span class="hljs-keyword">input</span>        rst_;<br><span class="hljs-keyword">output</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] cnt1 , cnt2;<br><span class="hljs-keyword">reg</span>    [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] cnt1 , cnt2;<br><br><span class="hljs-comment">// reset release circuit</span><br><span class="hljs-keyword">reg</span> reset_reg;<br><span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">posedge</span> clk)<br>     reset_reg &lt;= rst_;<br><span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> reset_reg)<br>   <span class="hljs-keyword">if</span> (!rst_)<br>      <span class="hljs-keyword">begin</span><br>        cnt1 &lt;= <span class="hljs-number">4&#x27;b0</span>;<br>        cnt2 &lt;= <span class="hljs-number">4&#x27;b0</span>;<br>      <span class="hljs-keyword">end</span><br>   <span class="hljs-keyword">else</span><br>      <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> (cnt1 &lt; <span class="hljs-number">2&#x27;b11</span>)<br>            cnt1 &lt;= cnt1 + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            cnt1 &lt;= cnt1;<br>        cnt2 &lt;= cnt1 - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">end</span><br><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h4 id="5-串并转化电路"><a href="#5-串并转化电路" class="headerlink" title="5. 串并转化电路"></a>5. 串并转化电路</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs verilog"> <span class="hljs-comment">//串转并</span><br> <span class="hljs-comment">//这里的时钟是串口的时钟(串口时钟频率高)</span><br> <span class="hljs-keyword">module</span> srl2pal (clk, rst, srl_in, pal_out);<br><br><span class="hljs-keyword">input</span>        clk;<br><span class="hljs-keyword">input</span>        rst;<br><span class="hljs-keyword">input</span>        srl_in;<br><span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] pal_out;<br><span class="hljs-keyword">reg</span>    [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] pal_out;<br><br><span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rst)<br>   <span class="hljs-keyword">if</span> (!rst)<br>      pal_out &lt;= <span class="hljs-number">8&#x27;b0</span>;<br>   <span class="hljs-keyword">else</span><br>      pal_out &lt;= &#123;pal_out,srl_in&#125;;<br><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">//并转串</span><br><span class="hljs-comment">//这里的时钟也是串口的时钟(串口时钟频率高)</span><br><span class="hljs-keyword">module</span> pal2srl(clk,rst,pal_in,srl_out);<br><span class="hljs-keyword">input</span> clk,rst;<br><span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] pal_in;<br><span class="hljs-keyword">output</span> srl_out;<br><br><span class="hljs-keyword">reg</span> d_o;<br><span class="hljs-keyword">reg</span>[<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] index;<br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rst) <span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">if</span>(!rst) <span class="hljs-keyword">begin</span><br>    index &lt;= <span class="hljs-number">3&#x27;b000</span>;<br>  <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">case</span>(index)<br>      <span class="hljs-number">3&#x27;b000</span>:index &lt;= <span class="hljs-number">3&#x27;b001</span>;<br>      <span class="hljs-number">3&#x27;b001</span>:index &lt;= <span class="hljs-number">3&#x27;b010</span>;<br>      <span class="hljs-number">3&#x27;b010</span>:index &lt;= <span class="hljs-number">3&#x27;b011</span>;<br>      <span class="hljs-number">3&#x27;b011</span>:index &lt;= <span class="hljs-number">3&#x27;b100</span>;<br>      <span class="hljs-number">3&#x27;b100</span>:index &lt;= <span class="hljs-number">3&#x27;b101</span>;<br>      <span class="hljs-number">3&#x27;b101</span>:index &lt;= <span class="hljs-number">3&#x27;b110</span>;<br>      <span class="hljs-number">3&#x27;b110</span>:index &lt;= <span class="hljs-number">3&#x27;b111</span>;<br>      <span class="hljs-number">3&#x27;b111</span>:index &lt;= <span class="hljs-number">3&#x27;b000</span>;<br>      <span class="hljs-keyword">default</span>:index &lt;= <span class="hljs-number">3&#x27;b000</span>;<br>    <span class="hljs-keyword">endcase</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rst) <span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">if</span>(!rst) <span class="hljs-keyword">begin</span><br>    srl_out &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>  <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>    d_o &lt;= pal_in[index];<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">assign</span> srl_out = d_o;<br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure><p><strong>串并转换也可以通过移位寄存器来实现</strong></p><p>下图是串行转并行</p><p><img src="/assets/markdown-img-paste-20190329194032690.png"></p><p>如果是并行转串行，就是同时将四位数据置入移位寄存器的四个触发器中，然后加入四个移位脉冲(clk)，数据串行地从D0输出。</p><h4 id="6-不用下降沿触发的11分频电路"><a href="#6-不用下降沿触发的11分频电路" class="headerlink" title="6. 不用下降沿触发的11分频电路"></a>6. 不用下降沿触发的11分频电路</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">timescale</span> 1ns/1ps</span><br><br><span class="hljs-comment">//11分频电路</span><br><span class="hljs-keyword">module</span> test(<br><span class="hljs-keyword">input</span> clk,<br><span class="hljs-keyword">input</span> rst_n,<br><span class="hljs-keyword">output</span> clk_div11<br>);<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] cnt;<br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rst_n)<span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span>(!rst_n)<span class="hljs-keyword">begin</span><br>            cnt&lt;=<span class="hljs-number">4&#x27;d0</span>;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>            <span class="hljs-keyword">if</span>(cnt&lt;<span class="hljs-number">4&#x27;d10</span>)<span class="hljs-keyword">begin</span><br>                cnt&lt;=cnt+<span class="hljs-number">1&#x27;b1</span>;<br>            <span class="hljs-keyword">end</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>                cnt&lt;=<span class="hljs-number">4&#x27;d0</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-comment">// 在波形中观察比较清楚</span><br>    <span class="hljs-keyword">assign</span> clk_div11= (cnt&lt;<span class="hljs-number">4&#x27;d5</span>)?<span class="hljs-number">1&#x27;b1</span>:((cnt&gt;<span class="hljs-number">4&#x27;d5</span>)?<span class="hljs-number">1&#x27;b0</span>:clk);<br>    <br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Verilog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Verilog语法小结(1)</title>
    <link href="/2019/03/09/Verilog/Verilog%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93(1)/"/>
    <url>/2019/03/09/Verilog/Verilog%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93(1)/</url>
    
    <content type="html"><![CDATA[<ol><li><strong>逻辑综合忽略延时信息</strong></li></ol><p> 比如”# 10 a &#x3D; 1’b1;”在逻辑综合的时候会将延时信息忽略。<br>2. <strong>always语句的规则：重复执行always后的语句</strong></p><p> 如果always后接”@(posedge clk)”,当执行到这时，always语句块的进程被挂起来，直到满足”posedge clk”条件，执行always块中的语句。然后always块会马上重复执行,到”@(posedge clk)”又被挂机，等待被激活<br>3. <strong>reg变量不代表映射成寄存器，而是在仿真时需要保存值</strong></p><p>  众所周知，在过程语句中的左值都要是reg类型，但其并不一定会被映射成寄存器。这个寄存器变量的实际意义是在仿真的时候保持它的值，就是寄存器变量在仿真时占据一定的内存空间。</p>  <figure class="highlight llvm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs llvm">always(a<span class="hljs-punctuation">,</span>b)<br><span class="hljs-keyword">begin</span><br>   <span class="hljs-keyword">c</span> <span class="hljs-operator">=</span> a  &amp; b<span class="hljs-comment">;</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>当a,b的值不变的时候，c的值也不会变，那么就需要保存c的值，所以c定义成reg寄存器变量。<br>4.  <strong>过程连续赋值</strong></p><p> assign - deassign:对寄存器变量强制赋值和放开</p><p> force-release: 对寄存器和线网进行强制赋值和放开</p> <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span>@(Clr)<br><span class="hljs-keyword">begin</span><br>   <span class="hljs-keyword">if</span>(!Clr)<br>    <span class="hljs-keyword">assign</span> o = <span class="hljs-number">1&#x27;b0</span>;   <span class="hljs-comment">//清零，将o强制赋值为0，d的值对o无效</span><br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">deassign</span> o;    <span class="hljs-comment">//放开</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk)<br>  o &lt;= d;<br></code></pre></td></tr></table></figure><ol start="5"><li><strong>模块例化时端口属性</strong></li></ol><p> 与input相连的可以是线网也可以是寄存器类型。</p><p> 与output相连的一定是线网</p><p> 与inout相连，输入从一个<strong>线网</strong>来，输出驱动到一个<strong>线网</strong></p><ol start="6"><li><p><strong>case 和if –else建模是无优先级的</strong></p></li><li><p><strong>连续赋值</strong></p></li></ol><p>  wire在定义的时候可以给赋值，这里算连续赋值，与assign相同。<br>  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">wire tmp <span class="hljs-operator">=</span> data_i<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></p><ol start="8"><li><strong>在描述仿真激励的时候可以使用for循环，但是在RTL级编码时要慎用for</strong></li></ol><p> 综合工具会将for循环展开为所有变量情况的行为，每个变量独立占用寄存器资源，不利于硬件资源的复用。</p><p> 相反，如果有些硬件资源确实不能复用的话，用for循环会增加代码的可读性。</p>]]></content>
    
    
    <categories>
      
      <category>Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Verilog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阻塞和非阻塞赋值</title>
    <link href="/2019/03/09/Verilog/%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC/"/>
    <url>/2019/03/09/Verilog/%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="1-阻塞赋值"><a href="#1-阻塞赋值" class="headerlink" title="1 阻塞赋值"></a>1 阻塞赋值</h3><h3 id="2-非阻塞赋值"><a href="#2-非阻塞赋值" class="headerlink" title="2 非阻塞赋值"></a>2 非阻塞赋值</h3><h3 id="3-自触发always块"><a href="#3-自触发always块" class="headerlink" title="3 自触发always块"></a>3 自触发always块</h3><ul><li><h4 id="使用阻塞赋值不能自触发"><a href="#使用阻塞赋值不能自触发" class="headerlink" title="使用阻塞赋值不能自触发"></a>使用阻塞赋值不能自触发</h4><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> osc(clk);<br><span class="hljs-keyword">output</span> clk;<br><span class="hljs-keyword">reg</span> clk;<br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>   #<span class="hljs-number">10</span> clk = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">end</span><span class="hljs-comment">//initial</span><br><span class="hljs-keyword">always</span> @(clk)<br>    #<span class="hljs-number">5</span> clk = ~clk;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>当语句执行到 <strong>clk &#x3D; ~clk</strong>,clk的值立马改变，在此期间不允许其他语句干扰，<strong>always块也无法感知到clk的翻转</strong>，所以不能出发always块</p></li><li><h4 id="非阻塞赋值可以产生自触发振荡器"><a href="#非阻塞赋值可以产生自触发振荡器" class="headerlink" title="非阻塞赋值可以产生自触发振荡器"></a>非阻塞赋值可以产生自触发振荡器</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> osc(clk);<br><span class="hljs-keyword">output</span> clk;<br><span class="hljs-keyword">reg</span> clk;<br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>   #<span class="hljs-number">10</span> clk = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">end</span><span class="hljs-comment">//initial</span><br><span class="hljs-keyword">always</span> @(clk)<br>    #<span class="hljs-number">5</span> clk &lt;= ~clk;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>当clk第一次改变的时候，@(clk)被触发，此时赋值表达式的RLS就已经被计算出来了，并将给LHS赋值的事件安排在更新事件队列中。在非阻塞赋值事件更新队列被激活后，又遇到了@(clk)触发语句，always再次对clk的值变化产生感应。非阻塞的LHS被更新时，always再次被触发。</p></li></ul><h3 id="使用原则"><a href="#使用原则" class="headerlink" title="使用原则"></a>使用原则</h3><ul><li>组合逻辑块使用阻塞赋值</li><li>时序逻辑使用非阻塞赋值</li><li>组合和时序逻辑同时存在使用非阻塞赋值</li><li>在一个always中不要既有阻塞又有非阻塞赋值</li></ul>]]></content>
    
    
    <categories>
      
      <category>Verilog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Verilog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MentorSources</title>
    <link href="/2019/03/09/links/MentorSources/"/>
    <url>/2019/03/09/links/MentorSources/</url>
    
    <content type="html"><![CDATA[<blockquote><p> Mentor Academy Resource</p></blockquote><p><a href="https://verificationacademy.com/conferences">Industry Conferences</a>：各个年份DAC、DVCon会议的现场录像视频，也可以下载PPT文件。</p><p><a href="https://verificationacademy.com/seminars/low-power-verification-forum">Low Power Verification Forum</a>：his forum will explore the new and unique low-power coverage methodologies that enable designers to verify and track how well they have tested their power management architecture. It will also show how to track not only metrics for how much power is used in the RTL, but also how much power is still being wasted and has potential to be reduced for IP qualification. </p><p>视频+PPT</p><p><a href="https://verificationacademy.com/courses/portable-stimulus-basics"><strong>Portable Stimulus Basics</strong></a>：The new Portable Test and Stimulus Standard from Accellera provides the next leap in verification productivity needed to support the verification of our ever-growing system-on-chip (SoC) designs. </p><p>视频+PPT</p><p><a href="https://verificationacademy.com/courses/systemverilog-oop-for-uvm-verification">SystemVerilog OOP for UVM Verification</a>：视频+PPT</p><p><a href="https://verificationacademy.com/academy-courses">Academy Courses</a>：Menter家的课程</p><p><a href="https://verificationacademy.com/cookbook/uvm"><strong>UVM Cookbook</strong></a>：有offline 的PDF文档，已下载到有道云笔记</p><p><a href="https://verificationacademy.com/cookbook/coverage">Coverage Cookbook</a></p><p><a href="https://verificationacademy.com/technical-resources">Technical Resources</a>：各种关于验证的文章</p><p><a href="https://verificationacademy.com/news/monthly-newsletter-archive">Verification Academy Newsletter &amp; Archive</a>：每月的最新咨询</p><p><a href="https://verificationacademy.com/verification-horizons">Verification Horizons</a>：算是个杂志吧，一年出三次</p><p><a href="https://www.mentor.com/products/fv/">Function Verification</a>：下面有一些链接。有一些Write Paper下载。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ic_Companies</title>
    <link href="/2019/03/09/links/ic_Companies/"/>
    <url>/2019/03/09/links/ic_Companies/</url>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/a92KEYABQXeED3008T65Mg">IC公司介绍</a></p><h2 id="SOC厂商"><a href="#SOC厂商" class="headerlink" title="SOC厂商"></a>SOC厂商</h2><h3 id="紫光展锐"><a href="#紫光展锐" class="headerlink" title="紫光展锐"></a>紫光展锐</h3><ol><li><a href="https://mp.weixin.qq.com/s/5wTAwMr_o_oCMmVkLOikGQ">紫光展锐的芯片大局</a></li></ol><h3 id="联发科"><a href="#联发科" class="headerlink" title="联发科"></a>联发科</h3><ol><li><a href="https://mp.weixin.qq.com/s/IKmspbzEJxtt26R664rtTA">5G 天玑1000</a></li></ol><h2 id="独角兽公司"><a href="#独角兽公司" class="headerlink" title="独角兽公司"></a>独角兽公司</h2><h3 id="寒武纪"><a href="#寒武纪" class="headerlink" title="寒武纪"></a>寒武纪</h3><ol><li><a href="https://mp.weixin.qq.com/s/LamuBG-nql1AtA3Oa65m6Q">AI芯片独角兽寒武纪冲刺科创板</a></li></ol><h2 id="IP厂商"><a href="#IP厂商" class="headerlink" title="IP厂商"></a>IP厂商</h2><h2 id="晶圆厂商"><a href="#晶圆厂商" class="headerlink" title="晶圆厂商"></a>晶圆厂商</h2><p><strong>中芯国际</strong>：</p><h2 id="设备厂商"><a href="#设备厂商" class="headerlink" title="设备厂商"></a>设备厂商</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ic_LowPower</title>
    <link href="/2019/03/09/links/ic_LowPower/"/>
    <url>/2019/03/09/links/ic_LowPower/</url>
    
    <content type="html"><![CDATA[<h4 id="0-低功耗设计"><a href="#0-低功耗设计" class="headerlink" title="0.  低功耗设计"></a>0.  低功耗设计</h4><p><a href="https://zhuanlan.zhihu.com/p/20808891"><strong>功耗对处理器的限制究竟有多大</strong></a><br>    功耗与工艺、面积、速度之间的相互关系</p><h3 id="1-低功耗技术"><a href="#1-低功耗技术" class="headerlink" title="1. 低功耗技术"></a>1. 低功耗技术</h3><p><a href="https://zhuanlan.zhihu.com/p/59080218">知乎-数字芯片实验室-数字IC设计低功耗概述</a></p><p><a href="https://www.cnblogs.com/IClearner/tag/%E4%BD%8E%E5%8A%9F%E8%80%97%E8%AE%BE%E8%AE%A1/">博客园-IC learner-数字IC 低功耗入门</a></p><p><a href="https://mp.weixin.qq.com/s/vGyq5DFXctJjhDz-6Ky8aQ">艾瑞后端设计微信公众号-浅谈芯片低功耗的设计实现（上）</a></p><p><a href="https://mp.weixin.qq.com/s/7u8U1AjNByyqo8UrSwOxew">艾瑞后端设计微信公众号-浅谈芯片低功耗的设计实现（下）</a></p><p><a href="https://mp.weixin.qq.com/s/8bc4vASuohCapnAd--SlZA"><strong>大话芯片功耗</strong></a>：并行化和流水话可以降低功耗。</p><h4 id="1-1-clock-gating"><a href="#1-1-clock-gating" class="headerlink" title="1.1 clock gating"></a>1.1 clock gating</h4><p><a href="https://mp.weixin.qq.com/s/1Nb52676QgV4UrIPnilhnA">门控时钟 clock gating</a></p><h3 id="2-低功耗书籍"><a href="#2-低功耗书籍" class="headerlink" title="2. 低功耗书籍"></a>2. 低功耗书籍</h3><ol><li>《low power design essentials》_—一本书，讲功耗、频率、面积、成本之间的关系</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ic_backend</title>
    <link href="/2019/03/09/links/ic_backend/"/>
    <url>/2019/03/09/links/ic_backend/</url>
    
    <content type="html"><![CDATA[<h3 id="1-时钟树"><a href="#1-时钟树" class="headerlink" title="1. 时钟树"></a>1. 时钟树</h3><p><a href="http://www.sohu.com/a/219354626_99933533"><strong>介绍CTS</strong></a></p><h4 id="1-1-clock-tree-problem"><a href="#1-1-clock-tree-problem" class="headerlink" title="1.1 clock tree problem"></a>1.1 clock tree problem</h4><p><a href="https://semiengineering.com/the-trouble-with-clock-trees/"><strong>The Trouble With Clock Trees</strong></a></p><h3 id="2-person"><a href="#2-person" class="headerlink" title="2. person"></a>2. person</h3><ul><li><a href="https://dl.acm.org/author_page.cfm?id=81100139674&coll=DL&dl=ACM&trk=0">Charles J. Alpert</a> <strong>时钟网络研究</strong></li></ul><h3 id="3-文章"><a href="#3-文章" class="headerlink" title="3. 文章"></a>3. 文章</h3><h4 id="3-1-process"><a href="#3-1-process" class="headerlink" title="3.1 process"></a>3.1 process</h4><p><a href="https://mp.weixin.qq.com/s/yFshgulcTNVS8bsCG40Zlg">论STA | POCV&#x2F; SOCV 之分析</a>：【陌上骑驴看IC】微信公众号分享的关于工艺波动的分析，链接中有好几篇文章，作者打算收集成一个体系，<strong>等写大论文的时候看一下</strong>。</p><h3 id="4-网站、实验室"><a href="#4-网站、实验室" class="headerlink" title="4. 网站、实验室"></a>4. 网站、实验室</h3><p><a href="https://vlsicad.ucsd.edu/index.html">UCLD加州圣地亚哥分校</a>：VLIS CAD实验室，<a href="http://vlsicad.ucsd.edu/~abk/">Andrew B. Kahng </a>的课题组，关于物理设计。除此之外还有一些指导研究的文章建议。</p><p><a href="http://mp.sohu.com/profile?xpt=c29odW1wMTV4b2pvQHNvaHUuY29t&_f=index_pagemp_2">数字后端IC芯片设计</a>  <strong>关于后端设计的文章</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ic_design</title>
    <link href="/2019/03/09/links/ic_design/"/>
    <url>/2019/03/09/links/ic_design/</url>
    
    <content type="html"><![CDATA[<h3 id="0-设计"><a href="#0-设计" class="headerlink" title="0. 设计"></a>0. 设计</h3><p><a href="https://mp.weixin.qq.com/s/jr3oK6_mSjOqJ0uqkBSNQA">芯片性能小谈——时间并行</a>：不多文章，还未细看</p><h4 id="1-相关知识"><a href="#1-相关知识" class="headerlink" title="1. 相关知识"></a>1. 相关知识</h4><p><a href="https://mp.weixin.qq.com/s/fsSCL1N8PulPnc91cBgADA">各种概念介绍</a></p><h5 id="1-时序分析"><a href="#1-时序分析" class="headerlink" title="1. 时序分析"></a>1. 时序分析</h5><p> <a href="http://blog.eetop.cn/blog-1582944-564133.html"><strong>静态时许分析中的setup和hold存在负值的问题</strong></a></p><p> <a href="http://www.sohu.com/a/241570304_99933533"><strong>时序分析基本概念介绍<Skew></strong></a></p><p><a href="https://vlsiuniverse.blogspot.com/2017/02/fixing-setup-violations.html"><strong>How to fix setup violations</strong></a></p><p><a href="https://vlsiuniverse.blogspot.com/2017/11/what-is-meant-by-drive-strength-of.html"><strong>What is meant by drive strength of a standard cell</strong></a></p><p><a href="https://vlsiuniverse.blogspot.com/2017/12/how-delay-of-standard-cell-changes-with.html"><strong>How delay of a standard cell changes with drive strength</strong></a></p><h5 id="2-数字IC设计中的时钟"><a href="#2-数字IC设计中的时钟" class="headerlink" title="2.  数字IC设计中的时钟"></a>2.  数字IC设计中的时钟</h5><p><a href="https://east1203.github.io/2019/05/23/IC/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E8%AE%BE%E8%AE%A1/">我自己写的-跨时钟域设计</a></p><p><a href="http://www.cnblogs.com/IClearner/p/6440488.html">IC learner的博客-数字设计中的时钟</a></p><p><a href="https://www.cnblogs.com/IClearner/p/6485389.html">IC learner的博客-跨时钟域信号传输一</a></p><p><a href="https://www.cnblogs.com/IClearner/p/6579754.html">IC learner的博客-跨时钟域信号传输二</a></p><p><a href="https://mp.weixin.qq.com/s/1Nb52676QgV4UrIPnilhnA">门控时钟 clock gating</a></p><p><a href="https://blog.csdn.net/u011729865/article/details/49281713#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E5%A4%8D%E4%BD%8D%E4%BF%A1%E5%8F%B7%E9%9C%80%E8%A6%81%E5%81%9A%E5%BC%82%E6%AD%A5%E5%A4%8D%E4%BD%8D%E5%90%8C%E6%AD%A5%E9%87%8A%E6%94%BE%E5%A4%84%E7%90%86">异步复位同步释放</a></p><h5 id="3-EDA工具"><a href="#3-EDA工具" class="headerlink" title="3. EDA工具"></a>3. EDA工具</h5><blockquote><p>功能仿真</p></blockquote><p><strong>VCS</strong></p><p><a href="https://mp.weixin.qq.com/s/ncWfvloZ1tpYwjJp6xEX1w">用VCS对综合后以及布局布线后的门级网表进行仿真的方法</a></p><p><a href="https://blog.csdn.net/limanjihe/article/details/52430286">使用<strong>VCS</strong>生成覆盖率报告</a></p><p><a href="http://bbs.eetop.cn/forum.php?mod=viewthread&tid=481243&extra=page=1&filter=digest&digest=1&orderby=dateline&_dsign=325ad204"> UVM+VCS+Verdi基本平台搭建</a> ：eetop上的教程</p><p><a href="https://www.edaplayground.com/home">EDA playground</a>：在线的仿真综合网站，用 学校邮箱登陆。</p><blockquote><p>逻辑综合</p></blockquote><p><strong>Designer Compiler</strong></p><p><a href="https://www.cnblogs.com/IClearner/tag/DC/">博客园-IC learner-DC使用总结</a></p><p><strong>开源的综合工具 Icarus Verilog</strong> </p><ul><li><a href="http://iverilog.icarus.com/">官网</a></li><li><a href="**https://github.com/steveicarus/iverilog**">GitHub代码位置</a></li><li><a href="https://mp.weixin.qq.com/s/9p1cl8-2dDzOinyGr0FEQA">Verilog开源仿真工具Icarus Verilog的工作原理</a>：一个公众号，介绍这个开源综合工具</li></ul><blockquote><p> PR</p></blockquote><p><strong>IC Compiler</strong></p><blockquote><p>其他</p></blockquote><p><strong>spice</strong></p><ul><li><p><a href="http://ngspice.sourceforge.net/">NGspice</a></p><p>open source spice simulator</p></li></ul><h5 id="4-Verilog"><a href="#4-Verilog" class="headerlink" title="4. Verilog"></a>4. Verilog</h5><blockquote><p> <strong>4.1 Verilog coding style</strong></p></blockquote><p><a href="http://guqian110.github.io/pages/2015/04/21/verilog_hdl_coding_style_guide.html">北邮学生写的比较详细的一篇介绍coding style的</a></p><p>  包括模块划分、要避免哪些点、命名规则、语法规范等等。</p><blockquote><p> <strong>4.2 语法规范</strong></p></blockquote><blockquote><p> <strong>4.3 Verilog技巧</strong></p></blockquote><h5 id="5-FPGA"><a href="#5-FPGA" class="headerlink" title="5. FPGA"></a>5. FPGA</h5><p><strong>5.1 FPGA介绍</strong></p><p><a href="https://mp.weixin.qq.com/s/WWVc6821U5eAlX9Uq1OsjA">FPGA介绍文章</a></p><p><strong>5.2  FPGA小技巧</strong></p><p><a href="https://blog.csdn.net/shshine/article/details/52583842">防止FPGA中的信号被优化掉</a></p><p><a href="https://blog.csdn.net/Pieces_thinking/article/details/90183507">vivado开发</a>：在CSDN上分享的vivado开发的视频资料</p><p><strong>5.3 FPGA中的时钟与复位</strong></p><p><a href="http://guqian110.github.io/pages/2014/06/20/the_art_of_reset_design_in_fpga.html">FPGA复位设计</a></p><h5 id="6-脚本语言"><a href="#6-脚本语言" class="headerlink" title="6.脚本语言"></a>6.脚本语言</h5><p><a href="https://zhuanlan.zhihu.com/p/27400825">数字集成电路设计中各种脚本的优缺点分析</a>：snow的知乎分享</p><p><a href="http://www.dooccn.com/perl/">在线工具</a>：可以在线运行perl、python、C++等代码。</p><h5 id="7-DFT"><a href="#7-DFT" class="headerlink" title="7. DFT"></a>7. DFT</h5><p><a href="https://mp.weixin.qq.com/s/6srcpJ-wMkQZGjqImUlYHw">大牛访谈：DFT一哥老K</a></p><p><a href="https://mp.weixin.qq.com/s/nz-hQfNXppBSbFq54lkyPA">扫盲！DFT到底是什么?</a></p><p>以前对dft做过一些总结，我觉得可以按照以下产品特点进行分类：1. 超大规模soc&#x2F;asic芯片，这类芯片规模超级大，但是芯片结构&#x2F;时钟结构比较简单，有大量重复例化的ip，由于芯片规模太大，后端一般采用channelless flow，dft相应一般也要考虑复用以及层次化设计。比如数通类芯片、视频处理芯片、ai芯片等。2. 芯片规模虽然没有前面说的规模大，但是soc 比较复杂，集成的ip数量，种类比较多，芯片时钟定义比较复杂，产品的定义也比较复杂，比如手机soc芯片，媒体处理芯片等。3.芯片规模比较小，但是芯片对成本非常敏感，对测试成本要求比较高，比如mcu的dft设计。4.这两年兴起的汽车电子类芯片。对测试成本要求没有那么高，但是对测试质量要求非常高。从dft的角度，大部分芯片都可以归入上面几类。上面几种芯片，产品特点不同，在进行制定dft设计的时候，应用的策略也不同，dft的技术细节也不同。三家eda公司也都有相应的参考流程。</p><p><a href="https://semiwiki.com/eda/282104-bringing-hierarchy-to-dft/">Bringing Hierarchy to DFT</a>：介绍Mentor公司的hierarchy DFT。</p><h5 id="8-ChipLet"><a href="#8-ChipLet" class="headerlink" title="8. ChipLet"></a>8. ChipLet</h5><p><a href="https://mp.weixin.qq.com/s/oMA9RSaq0nuSNgKDRwHavQ">Chiplet最强科普</a></p><h5 id="9-hls"><a href="#9-hls" class="headerlink" title="9. hls"></a>9. hls</h5><p><a href="https://mp.weixin.qq.com/s/6I42jTnfSKxpMjLT1QmYfA">高阶综合的“红与黑”｜High-Level Synthesis</a></p><h4 id="2-person"><a href="#2-person" class="headerlink" title="2. person"></a>2. person</h4><ul><li><p><a href="https://home.cnblogs.com/u/IClearner/feed/blog/">IC_learner</a> <strong>博客园博主，分享关于IC设计内容</strong></p></li><li><p><a href="http://guqian110.github.io/category/fpga.html">停止更新-一个北邮学生的</a></p></li><li><p><a href="http://cc.ee.ntu.edu.tw/~ywchang/">常耀文</a> ： <strong>EDA算法，集成电路</strong></p></li><li><p><a href="www.sunburst-design.com">Cummings</a>  ：  <strong>可以下他 的论文。</strong></p><p>地址跳转不过去，点击 <a href="http://www.sunburst-design.com/">www.sunburst-design.com</a></p></li><li><p><a href="http://www.zimmerdesignservices.com/"><em>Paul Zimmer</em></a> ：<strong>异步设计的论文</strong></p></li></ul><h4 id="3-论坛、网站、博客"><a href="#3-论坛、网站、博客" class="headerlink" title="3. 论坛、网站、博客"></a>3. 论坛、网站、博客</h4><h5 id="3-1-知识学习"><a href="#3-1-知识学习" class="headerlink" title="3.1 知识学习"></a>3.1 知识学习</h5><p><a href="https://vlsiuniverse.blogspot.com/">VLSI UNIVERSE</a></p><p> Let us learn together the basics and intricacies of VLSI</p><p><a href="https://www.design-reuse.com/">Design Resue</a>：可以搜索一些与设计验证相关的文章，不翻墙也可以用。</p><p><a href="https://www.chipverify.com/verilog/verilog-tutorial"><strong>ChipVerify</strong></a>：非常好的关于设计和验证的网站，以后要仔细看看。</p><p><a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0479b/BABHFBHD.html">ARM社区</a>：可以查一些arm的设计文档和设计例子。</p><p><a href="https://www.paripath.com/blog/variation-blog/secrets-sauce-of-creating-a-digital-corner">PariPath Inc</a>：与工艺相关的一些分析</p><p><a href="https://hdlbits.01xz.net/wiki/Main_Page">HDLBits</a>：Verilog学习网站，每一节都可以进行<strong>在线综合</strong>。</p><p><a href="http://asic-world.com/">Asic world</a>: verilog, systemverilog， systemc学习</p><h5 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h5><p><a href="https://en.wikichip.org/wiki/WikiChip">WikiChip-各种芯片介绍</a></p><p> WikiChip is the preeminent resource for computer architectures and semiconductor (logic) engineering.</p><p><a href="https://semiwiki.com/">SemiWiki</a>：Open Forum for Semiconductor professionals</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p><a href="http://www.dooccn.com/perl/">在线工具</a>：可以在线运行perl、python、C++等代码。</p><p><a href="http://www.ictown.com/">IC小镇</a>：<strong>论坛、资料下载等。</strong></p><h4 id="4-开源项目"><a href="#4-开源项目" class="headerlink" title="4. 开源项目"></a>4. 开源项目</h4><ol><li><h5 id="NVIDIA-Deep-Learning-Accelerator-NVDLA"><a href="#NVIDIA-Deep-Learning-Accelerator-NVDLA" class="headerlink" title="NVIDIA Deep Learning Accelerator (NVDLA)"></a><a href="https://github.com/nvdla/hw">NVIDIA Deep Learning Accelerator (NVDLA)</a></h5><h5 id="英伟达开源的深度学习加速器"><a href="#英伟达开源的深度学习加速器" class="headerlink" title="英伟达开源的深度学习加速器"></a>英伟达开源的深度学习加速器</h5></li><li><h5 id="EDA课程"><a href="#EDA课程" class="headerlink" title="EDA课程"></a><a href="http://cc.ee.ntu.edu.tw/~cchen/course.html">EDA课程</a></h5><p> Computer Aided Analysis &amp; Optimization of Integrated Circuit</p></li><li><p><a href="https://openrisc.io/"><strong>open</strong> risc</a></p><p>Welcome to the project overview of the OpenRISC project. The major goal of the project it to create a free and open processor for embedded systems. This includes:</p><p>a free and open RISC instruction set architecture with DSP features</p><p>a set of free, open source implementations of the architecture</p><p>a complete set of free, open source software development tools, libraries, operating systems and applications</p><p>a variety of system-on-chip and system simulators</p></li><li><p><a href="https://github.com/chipsalliance/Cores-SweRV">西部数据开源RISC-V芯片</a></p><p><a href="https://github.com/east1203/Cores-SweRV">自己也保存了</a></p></li><li><p><a href="http://ptm.asu.edu/"> PTM-晶体管模型</a></p><p>   PTM(<strong>Predictive Technology Model</strong>).<strong>PTM</strong> provides accurate, customizable, and predictive model files for future transistor and interconnect technologies. These predictive model files are compatible with standard circuit simulators, such as SPICE, and scalable with a wide range of process variations.</p></li><li><p>ARM cortexM系列开源处理器——<a href="https://developer.arm.com/ip-products/designstart/eval">下载</a></p><p><a href="https://github.com/east1203/ExamplesCode/tree/master/armcortexm0">ARM cortexM0</a></p><p><a href="https://github.com/east1203/ExamplesCode/tree/master/armcortexm3">ARM cortexM3</a></p></li><li><p><a href="https://github.com/east1203/rocket-chip">伯克利大学开源RISC-V芯片</a></p></li><li><p><a href="https://github.com/east1203/AI-Chip">总结AI芯片的GitHub项目</a></p></li><li><p><a href="https://github.com/east1203/wujian100_open">平头哥的无剑100 RISC-V</a></p></li><li><p><a href="https://github.com/east1203/ExamplesCode/blob/master/eetop.cn_h265enc_v2.0.zip">复旦的H.265视频编解码IP</a>：它由  复旦大学  专用集成电路与系统国家重点实验室 （State Key Lab of asic &amp; System，Fudan University）  视频图像处理实验室 （VIP Lab）  范益波教授研究团队开发完成，并开放源代码。</p></li></ol><h4 id="5-Books"><a href="#5-Books" class="headerlink" title="5.  Books"></a>5.  Books</h4><p><a href="https://epdf.tips/reuse-methodology-manual-for-system-on-a-chip-designs4a91cd793bfa24079f6880ac1d185f3231127.html">《Reuse Methodology Manual for System-On-A-Chip Designs,Third Edition》</a></p><p>中文版本：《片上系统－可重用设计方法学》，2004年，电子工业出版社出版，220多页。</p><p>介绍了设计一个macro或者说IP模块的流程——定义管教、寄存器、参数定义等。<br>在第5章：RTL编码指南用了几十页详细介了coding style，。内容涉及可重用IP核的各个方面。</p><p><a href="http://bbs.eetop.cn/thread-266690-1-1.html">《Static Timing Analysis for Nanometer Designs:A Practical Approach》</a></p><p>做芯片最重要的就是Timing，这本书就是讲timing的。</p><p>IC圆桌派荐书，芯片架构设计学习书单</p><ul><li><p>计算机体系结构-量化研究方法</p></li><li><p>EMBEDDED SYSTEM DESIGN-INTRODUCTION TO SOC SYSTEM ARCHITECTURE</p></li><li><p>ARM-system on chip architecture</p></li><li><p>微处理器设计-从设计规划到工艺制造</p></li><li><p>微处理器设计-架构，电路及实现</p></li><li><p>RISC-V处理器</p></li><li><p>A Practical Approach to VLSI System on Chip (SoC) Design</p></li><li><p>看看arm coresight，pl301，nic文档，或者用ambadesigner生成一套soc结构比看啥书都理解的快</p></li><li><p>Parallel Programming for FPGAs</p></li><li><p>Modern Processor Design - Fundamentals of Superscalar Processors</p></li><li><p>A Primer on Memory Consistency and Cache Coherence</p></li><li><p>Processor MIcroarchitecture– An Implementation Perspective</p></li></ul><p><a href="https://mp.weixin.qq.com/s/zRnklaaNDgZYDywmrQy-wA">极刊・IC极客荐书，一起学习，一起挂科</a></p><p><a href="https://mp.weixin.qq.com/s/DauMkUAKgM4bFe9FrBeXQg">最全的数字IC设计经典书籍电子版下载</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ic_verification</title>
    <link href="/2019/03/09/links/ic_verification/"/>
    <url>/2019/03/09/links/ic_verification/</url>
    
    <content type="html"><![CDATA[<h4 id="1-验证介绍"><a href="#1-验证介绍" class="headerlink" title="1. 验证介绍"></a>1. 验证介绍</h4><p><a href="https://www.zhihu.com/question/26109157">IC验证工程师心得有哪些？</a></p><p><a href="https://xiaotanzhong.github.io/2018/04/08/20180401formal/">形式化芯片验证：救世主还是乌托邦</a></p><p><a href="http://blog.sina.com.cn/s/blog_13f7886010102x5u7.html">芯片验证–验证工程师的自我修养</a></p><p><a href="https://mp.weixin.qq.com/s/AnCQw4wt5rwb-JvWC8xTlQ">验证工程师岗位介绍、薪资、公司</a></p><h4 id="2-搭建环境"><a href="#2-搭建环境" class="headerlink" title="2. 搭建环境"></a>2. 搭建环境</h4><p><a href="http://bbs.eetop.cn/forum.php?mod=viewthread&tid=481243&extra=page=1&filter=digest&digest=1&orderby=dateline&_dsign=325ad204"> UVM+VCS+Verdi基本平台搭建</a> ：eetop上的教程</p><p><a href="https://blog.csdn.net/limanjihe/article/details/52430286">使用<strong>VCS</strong>生成覆盖率报告</a></p><h4 id="3-进阶资料"><a href="#3-进阶资料" class="headerlink" title="3. 进阶资料"></a>3. 进阶资料</h4><p><a href="https://cloud.tencent.com/developer/news/338248"><strong>验证的资料收藏</strong></a>：包括哪些书？有哪些在线的SV,UVM教程？关于验证的会议等。** ** 很重要 ** ** </p><p><a href="http://bbs.eetop.cn/forum.php?mod=viewthread&tid=857746&extra=page=1&filter=author&orderby=dateline&_dsign=cba328f2">E课网的一些SV代码资料，code和文档</a></p><p><a href="http://bbs.eetop.cn/thread-0382237-1-1.html?_dsign=2dd70436"><strong>synopsis 内部实验workshop, lab1-6附代码，实验指导书</strong></a></p><p><a href="http://bbs.eetop.cn/thread-611621-1-1.html?_dsign=a4e8e1e3"><strong>重发《The UVM Primer》中文翻译, 附上下载的源码和一点读后感</strong></a> ：推荐有一定SV基础之后读这个，然后再看张强的《UVM实战》</p><p><a href="https://github.com/east1203/ExamplesCode/blob/master/ces_uvm-1.2_2016.06.zip">synopsys uvm1.2 lab</a>：在我的github上。</p><p><a href="https://east1203.github.io/2019/03/09/links/MentorSources/"><strong>Mentor 网站上的资料整理</strong></a>：Mentor网站上的东西太多了，看起来比较乱。而且网速比较慢，找的时候还费劲，这样我就把一些东西整理一下，分成不同的链接，需要看哪些比较好找。</p><h4 id="4-验证相关期刊、会议"><a href="#4-验证相关期刊、会议" class="headerlink" title="4. 验证相关期刊、会议"></a>4. 验证相关期刊、会议</h4><p><a href="https://ieeexplore.ieee.org/xpl/conhome/1001112/all-proceedings"><strong>Microprocessor Test and Verification (MTV), International Workshop on</strong></a></p><h4 id="5-网站、社区、博客"><a href="#5-网站、社区、博客" class="headerlink" title="5. 网站、社区、博客"></a>5. 网站、社区、博客</h4><ol><li><a href="https://verificationacademy.com/">Mentor-Verification Academy</a> ：Mentor公司的验证教程</li><li><a href="https://verificationacademy.com/verification-horizons">Verification Horizon</a>：也是Mentor的网站，像个杂志一样，每隔几个月会发一些文章。</li><li><a href="https://www.verificationguide.com/p/home.html">verificationguide</a>：包括SV\UVM\SYSTEM C教程</li><li><a href="https://www.accellera.org/downloads/standards/uvm">accellera——UVM官方下载网站</a></li><li><a href="http://www.verilab.com/">verilab开源SV库</a>：字符串、正则、文件目录等</li><li><a href="http://cluelogic.com/tools/cluelib/api/framed_html/">cluelib公司的开源SV库</a>：Cluelib包括文本处理、容器</li><li><a href="http://cluelogic.com/">cluelogic</a>：这个机构的网站，有一些UVM教程。</li><li><a href="https://www.doulos.com/">Doulos该公司有开源代码生成器</a>：easierUVM</li><li><a href="https://www.edaplayground.com/">EDA playground</a>：在线的EDA工具，可以进行仿真编译Verilog、SystemVerilog、UVM、perl、SystemC等。</li><li><a href="https://www.design-reuse.com/">Design Resue</a>：可以搜索一些与设计验证相关的文章，不翻墙也可以用。</li><li><a href="https://www.chipverify.com/verilog/verilog-tutorial"><strong>ChipVerify</strong></a>：非常好的关于设计和验证的网站，以后要仔细看看。</li><li><a href="http://www.learnuvmverification.com/index.php/2015/07/04/187/"><a href="http://www.learnuvmverification.com/"><strong>UNIVERSAL VERIFICATION METHODOLOGY</strong></a></a>：也有很丰富的验证的教程，也很值得一看。</li><li><a href="https://blog.csdn.net/wonder_coole">wonder_coole CSDN博客</a></li><li><a href="http://blog.sina.com.cn/u/5359830529">赵中民博客</a>：有一些验证的经验分享，目前还在更新，可喜可贺（2020-11-30）</li><li></li></ol><h4 id="6-书籍"><a href="#6-书籍" class="headerlink" title="6. 书籍"></a>6. 书籍</h4><ol><li><a href="https://ieeexplore.ieee.org/document/7932212">1800.2-2017 - IEEE Standard for Universal Verification Methodology Language Reference Manual</a>：UVM参考手册</li><li>《UVM实战》——张强</li><li>《system verilog 测试平台编写指南》</li><li>《UVMPrimer》</li><li>《芯片验证漫游指南》——路科验证</li></ol><h4 id="7-文章"><a href="#7-文章" class="headerlink" title="7. 文章"></a>7. 文章</h4><ol><li><a href="https://verificationacademy.com/verification-horizons/june-2019-volume-15-issue-2/fun-with-uvm-sequences-coding-and-debugging?mid=29813506&PC=L&c=2019_08_26_verification_tech_news_aug_201">Fun with UVM Sequences - Coding and Debugging</a>：一篇讲怎么写sequence的文章，Mentor Verification上的。很好。</li><li><a href="http://www.learnuvmverification.com/index.php/2015/07/04/187/">Introduction about Advanced Functional Verification</a>：介绍function verification的文章</li></ol><h5 id="7-1-UVM"><a href="#7-1-UVM" class="headerlink" title="7.1 UVM"></a>7.1 UVM</h5><p>​    <strong>7.1.1 sequence library</strong></p><p>​    <a href="https://www.design-reuse.com/articles/42497/uvm-sequence-library-usage-advantages-and-limitations.html">UVM Sequence Library - Usage, Advantages, and Limitations</a></p><h4 id="8-视频"><a href="#8-视频" class="headerlink" title="8. 视频"></a>8. 视频</h4><ol><li><a href="https://www.mentor.com/products/fv/multimedia/player/questa-clock-reset-domain-crossing-verification-mentor-functional-safety-compliance-what-s-new-in-functional-verification-from-mentor-session-5-34f53dd1-78e5-49cf-aedd-66ab2c461a1c">关于跨时钟域的时钟和复位的验证</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>useful links</title>
    <link href="/2019/03/09/links/links/"/>
    <url>/2019/03/09/links/links/</url>
    
    <content type="html"><![CDATA[<blockquote><h3 id="收集一些有用的链接"><a href="#收集一些有用的链接" class="headerlink" title="收集一些有用的链接"></a><strong>收集一些有用的链接</strong></h3></blockquote><h3 id="一、AI"><a href="#一、AI" class="headerlink" title="一、AI"></a><a href="https://east1203.github.io/2019/03/09/links/links_AI/"><strong>一、AI</strong></a></h3><p>​    <strong>关于Ai的学习资料、网站。</strong></p><h3 id="二、IC"><a href="#二、IC" class="headerlink" title="二、IC"></a><a href=""><strong>二、IC</strong></a></h3><p>​    <strong>包括但不限于IC设计、验证、后端、低功耗等相关的学习资料、网站、项目、文章、代码等。</strong></p><h4 id="2-1-Verification"><a href="#2-1-Verification" class="headerlink" title="2.1 Verification"></a><a href="https://east1203.github.io/2019/03/09/links/ic_verification/"><strong>2.1 Verification</strong></a></h4><h4 id="2-2-Design"><a href="#2-2-Design" class="headerlink" title="2.2 Design"></a><a href="https://east1203.github.io/2019/03/09/links/ic_design/"><strong>2.2 Design</strong></a></h4><h4 id="2-3-LowPower"><a href="#2-3-LowPower" class="headerlink" title="2.3 LowPower"></a><a href="https://east1203.github.io/2019/03/09/links/ic_LowPower/"><strong>2.3 LowPower</strong></a></h4><h4 id="2-4-Backend"><a href="#2-4-Backend" class="headerlink" title="2.4 Backend"></a><a href="https://east1203.github.io/2019/03/09/links/ic_backend/"><strong>2.4 Backend</strong></a></h4><h4 id="2-5-MentorSources"><a href="#2-5-MentorSources" class="headerlink" title="2.5 MentorSources"></a><a href="https://east1203.github.io/2019/03/09/links/MentorSources/">2.5 MentorSources</a></h4><h4 id="2-6-Companies"><a href="#2-6-Companies" class="headerlink" title="2.6 Companies"></a><a href="https://east1203.github.io/2019/03/09/links/ic_Companies/">2.6 Companies</a></h4><h3 id="三、software"><a href="#三、software" class="headerlink" title="三、software"></a><a href="https://east1203.github.io/2019/03/09/links/links_softwares/">三、software</a></h3><p>​    <strong>一些有用的作图、文件处理软件。</strong></p><h3 id="四、Interest"><a href="#四、Interest" class="headerlink" title="四、Interest"></a><a href="https://east1203.github.io/2019/03/09/links/links_interest/">四、Interest</a></h3><p>​    <strong>包括但不限于英语、画画、唱歌等相关的内容。</strong></p><h3 id="五、NewTech"><a href="#五、NewTech" class="headerlink" title="五、NewTech"></a><a href="https://east1203.github.io/2019/03/09/links/links_NewTech/">五、NewTech</a></h3><p>​    <strong>一些新的科技</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>AI</title>
    <link href="/2019/03/09/links/links_AI/"/>
    <url>/2019/03/09/links/links_AI/</url>
    
    <content type="html"><![CDATA[<h3 id="0-Introduction"><a href="#0-Introduction" class="headerlink" title="0.Introduction"></a>0.Introduction</h3><p>收集关于AI（Artificial Intelligence）的学习资料，包括但不限于文章、技术博客、在线课程、书籍、学习进阶路线。</p><h3 id="1-学习进阶路线"><a href="#1-学习进阶路线" class="headerlink" title="1. 学习进阶路线"></a>1. 学习进阶路线</h3><ol><li><a href="https://github.com/nndl/nndl.github.io/blob/master/md/DeepGuide.md">复旦大学——深度学习上手指南</a></li><li><a href="https://blog.csdn.net/qq_38701868/article/details/96183069">机器学习入门书籍推荐</a></li></ol><h3 id="2-在线课程（排名不分先后）"><a href="#2-在线课程（排名不分先后）" class="headerlink" title="2. 在线课程（排名不分先后）"></a>2. 在线课程（排名不分先后）</h3><ol><li><p><a href="https://cloud.tencent.com/edu/paths/series/ai">腾讯云大学——人工智能学习路径</a></p></li><li><p><a href="https://www.coursera.org/learn/machine-learning">Coursera——机器学习</a></p></li><li><h5 id="神经网络与深度学习——链接中附几个在线课程"><a href="#神经网络与深度学习——链接中附几个在线课程" class="headerlink" title="神经网络与深度学习——链接中附几个在线课程"></a><a href="https://nndl.github.io/">神经网络与深度学习</a>——链接中附几个在线课程</h5><p>本课程主要介绍神经网络与深度学习中的基础知识、主要模型（前馈网络、卷积网络、循环网络等）以及在计算机视觉、自然语言处理等领域的应用。</p></li><li></li></ol><h3 id="3-博客、社区等"><a href="#3-博客、社区等" class="headerlink" title="3. 博客、社区等"></a>3. 博客、社区等</h3><ol><li><p><a href="https://github.com/apachecn">Github上的AI社区apachecn</a></p></li><li><p><a href="https://oldpan.me/">OldMe个人博客</a></p><p><strong>一个个人博主，讲的关于机器学习的东东</strong></p></li><li><p><a href="http://freemind.pluskid.org/">Free mind </a></p><p>有机器学习的，也有自己的日常</p></li><li><p><a href="http://www.tensorfly.cn/">Tensorflow中文社区</a></p></li></ol><h3 id="4-行业人才"><a href="#4-行业人才" class="headerlink" title="4. 行业人才"></a>4. 行业人才</h3><h3 id="5-AI书籍"><a href="#5-AI书籍" class="headerlink" title="5. AI书籍"></a>5. AI书籍</h3><ol><li><a href="http://zh.d2l.ai/"><strong>动手学深度学习</strong></a></li></ol><h3 id="6-AI项目"><a href="#6-AI项目" class="headerlink" title="6. AI项目"></a>6. AI项目</h3><ol><li><a href="https://github.com/fastai/fastai">fastai</a>：给黑白图片着色</li></ol><h3 id="7-AI公司"><a href="#7-AI公司" class="headerlink" title="7. AI公司"></a>7. AI公司</h3><ol><li><a href="https://blog.csdn.net/weixin_42229404/article/details/84306658">L4级自动驾驶方案芯片选型—AI芯片选型</a></li><li><a href="http://www.eetop.cn/cpu_soc/6946369.html">NVIDIA发布世界最小边缘AI超算：功耗仅10W</a></li><li><a href="https://mp.weixin.qq.com/s/fHZuiGRNAMs3ZEP3nMe0IQ">2019–AI芯片市场最新研究</a></li><li><a href="https://mp.weixin.qq.com/s/8ifkk_kVrkpkTKf2zON7HA">2019–不以“算力”论英雄，云天励飞公布AI芯片打法</a></li></ol><h4 id="寒武纪"><a href="#寒武纪" class="headerlink" title="寒武纪"></a>寒武纪</h4><ol><li><a href="http://www.cambricon.com/news/index.php?c=show&id=275">2019-11 思元220边缘计算</a><ol start="2"><li><a href="http://www.cambricon.com/news/index.php?c=show&id=265">2019-06 思元270云端AI芯片</a></li></ol></li><li><a href="https://mp.weixin.qq.com/s/8gXXpTwSafTHHQQY7Z-KVQ">甲小姐对话陈天石：通往伟大芯片公司的赛程很长 </a></li></ol><h4 id="地平线"><a href="#地平线" class="headerlink" title="地平线"></a>地平线</h4><ol><li><a href="http://www.baige.me/v?i=SbD">2019-08 征程2.0 中国首款车规级芯片</a></li><li><a href="http://www.baige.me/v?i=SbC">2019-10 旭日2.0 AIOT芯片 智能应用</a></li><li><a href="http://www.baige.me/v?i=Sb7">地平线智能驾驶</a></li><li><a href="http://www.baige.me/v?i=Sb8">地平线智能物联</a></li></ol><h4 id="旷世"><a href="#旷世" class="headerlink" title="旷世"></a>旷世</h4><ol><li><a href="https://mp.weixin.qq.com/s/XPPDcRCit66qnudOnHgmAw">2020-03-26 旷视“天元”深度学习框架全解读</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>useful NewTech</title>
    <link href="/2019/03/09/links/links_NewTech/"/>
    <url>/2019/03/09/links/links_NewTech/</url>
    
    <content type="html"><![CDATA[<h3 id="1-生物医学"><a href="#1-生物医学" class="headerlink" title="1. 生物医学"></a>1. 生物医学</h3><p><a href="http://www.eetop.cn/othertech/6946351.html">皮肤移植新突破！美国研发出3D打印带血管皮肤：与皮肤完美结合</a></p><h3 id="2-新材料"><a href="#2-新材料" class="headerlink" title="2. 新材料"></a>2. 新材料</h3><h3 id="3-天文物理"><a href="#3-天文物理" class="headerlink" title="3. 天文物理"></a>3. 天文物理</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>articles</title>
    <link href="/2019/03/09/links/links_articles/"/>
    <url>/2019/03/09/links/links_articles/</url>
    
    <content type="html"><![CDATA[<h3 id="全球变化"><a href="#全球变化" class="headerlink" title="全球变化"></a>全球变化</h3><ol><li><a href="https://mp.weixin.qq.com/s/Lm4ZNA3eeMiTE1j9uNK40g">2020-03-30 桥水基金达利欧最新万字长文：悄悄变化的世界格局与宏观周期</a></li></ol><h3 id="学业相关"><a href="#学业相关" class="headerlink" title="学业相关"></a>学业相关</h3><ol><li><a href="https://mp.weixin.qq.com/s/fzMhEvbNhFc7Dr-bjrTTrw">江苏144篇硕士论文抽检不及格！广东又发现8份“存在问题”，会是什么“下场”</a></li></ol><h3 id="思维方式"><a href="#思维方式" class="headerlink" title="思维方式"></a>思维方式</h3><ol><li><a href="https://mp.weixin.qq.com/s/I-f9dXTMLMc2HPNtZ5gaNA">自控力极差的人如何自救</a></li><li><a href="https://mp.weixin.qq.com/s/BhLRA_dVqw4y7pWOnmS4-A">来华永居–外国人应该是谁</a></li></ol><h3 id="半导体"><a href="#半导体" class="headerlink" title="半导体"></a>半导体</h3><ol><li><p><a href="https://mp.weixin.qq.com/s/aDwU-8A4XpRhIqV5PQ-dLw">顶级半导体公司中国布局情况跟踪</a></p></li><li><p><a href="https://baijiahao.baidu.com/s?id=1599616307408698440&wfr=spider&for=pc">全球AI芯片排行榜发布 解读入围的七家中国公司</a></p></li><li><p><a href="https://blog.csdn.net/weixin_42229404/article/details/84306658">L4级自动驾驶方案芯片选型—AI芯片选型</a></p></li><li><p><a href="https://blog.csdn.net/cf2SudS8x8F0v/article/details/78898399">2017年全球AI芯片公司大盘点</a></p></li><li><p><a href="https://blog.csdn.net/weixin_42229404/article/details/81409096">无人驾驶公司实力排名—自动驾驶初创企业排名（roadstar.ai、pony.ai、momenta、景驰和驭势科技等）</a></p></li><li><p><a href="http://www.eetop.cn/ai/6945839.html">盘点｜2019年最受市场关注的AI安防芯片企业之「前端」</a></p></li><li><p><a href="http://www.eetop.cn/semi/6945807.html">2019全国集成电路设计大会在青岛举办</a>：真诚期盼各位院士、专家和嘉宾把更好的技术引入青岛，把更好的项目布局青岛，把发展的重心转到青岛，努力把青岛建设为国家级集成电路的产业基地，共同推动我国集成电路产业实现跨越式发展。</p></li><li><p><a href="http://www.eetop.cn/semi/6946352.html">我国各省市集成电路产业政策情况分析与建议：最高支持可达3000万元</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/vdyUC1RAXplunZeS5DbcRA">清华博导尹首一， 带你吃透 AI 芯片来龙去脉！</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/wv4g22jekQyJ7lEtuxRkSA">一页芯片并购史：美式创业像养猪，亚洲老板是在养儿子</a></p></li><li><p><a href="https://www.qianzhan.com/analyst/detail/329/191106-93e7a35d.html">进击的2019 AI芯片十大新势力！内斗、赛道争夺与口水战</a></p></li><li></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>interest</title>
    <link href="/2019/03/09/links/links_interest/"/>
    <url>/2019/03/09/links/links_interest/</url>
    
    <content type="html"><![CDATA[<h3 id="1-English"><a href="#1-English" class="headerlink" title="1. English"></a>1. English</h3><blockquote><h3 id="English"><a href="#English" class="headerlink" title="English"></a>English</h3></blockquote><h5 id="USA-Learns"><a href="#USA-Learns" class="headerlink" title="USA Learns"></a><a href="https://www.usalearns.org/">USA Learns</a></h5><h5 id="VOA"><a href="#VOA" class="headerlink" title="VOA"></a><a href="http://www.51voa.com/">VOA</a></h5><blockquote><h3 id="Drawing"><a href="#Drawing" class="headerlink" title="Drawing"></a><strong>Drawing</strong></h3></blockquote><h2 id="2-Drawing"><a href="#2-Drawing" class="headerlink" title="2. Drawing"></a>2. Drawing</h2><h5 id="proko"><a href="#proko" class="headerlink" title="proko"></a><a href="https://www.proko.com/">proko</a></h5><p><strong>国外教画画网站，配有youTube视频</strong></p><blockquote><p>People</p></blockquote><h3 id="3-人"><a href="#3-人" class="headerlink" title="3. 人"></a>3. 人</h3><ul><li><p><a href="http://91biji.com/social/leon/framebook/notes/note/9174/">王小波和编程</a></p></li><li><p><a href="https://www.cnblogs.com/ECJTUACM-873284962/">Angel_Kitty</a>    <strong>漂亮的个人网站、优质博客、励志大学生。 以为是个汉子，原来是个妹子。不，我说反了，以为是个妹子，原来是个汉子。哈哈</strong></p></li><li><p><a href="https://seisman.info/">SeisMan</a>  <strong>level很高的个人网站</strong></p></li><li><p><a href="https://github.com/mulder21c">SEONG BONG JI</a>  <strong>这个人写了amorfati这个hexo框架的主题</strong></p></li></ul><blockquote><p> others webs</p></blockquote><h2 id="3-网站"><a href="#3-网站" class="headerlink" title="3. 网站"></a>3. 网站</h2><h5 id="企信网"><a href="#企信网" class="headerlink" title="企信网"></a><a href="http://www.yarnn.com/">企信网</a></h5><p><a href="https://www.university-list.net/chinese.htm">各国大学排名网站</a></p><p><a href="http://121.248.63.139/nstudent/"><strong>学校的个人主页</strong></a></p><blockquote><h3 id="download"><a href="#download" class="headerlink" title="download"></a>download</h3></blockquote><h2 id="4-各种下载网站"><a href="#4-各种下载网站" class="headerlink" title="4. 各种下载网站"></a>4. 各种下载网站</h2><h5 id="老殴科技"><a href="#老殴科技" class="headerlink" title="老殴科技"></a><a href="https://www.laomoit.com/">老殴科技</a></h5><p>   免费分享软件、影视、小说等的下载</p><p><a href="https://www.5xiaobo.com/?cate=1">吴晓波</a></p><p>各种教程，视频、音频下载资源。</p><h5 id="academia"><a href="#academia" class="headerlink" title="academia"></a><a href="https://www.academia.edu/">academia</a></h5><p>   英文书籍下载</p><h5 id="EEPDF"><a href="#EEPDF" class="headerlink" title="EEPDF"></a><a href="https://epdf.tips/">EEPDF</a></h5><p>   英文文档下载</p><h5 id="ZLibrary"><a href="#ZLibrary" class="headerlink" title="ZLibrary***"></a><a href="https://b-ok.org/">ZLibrary</a>***</h5><p>  英文文档书籍</p><h5 id="libGen"><a href="#libGen" class="headerlink" title="libGen***"></a><a href="https://libgen.me/">libGen</a>***</h5><p>海量英文书籍</p><h5 id="电子书网站汇总"><a href="#电子书网站汇总" class="headerlink" title="电子书网站汇总"></a><a href="http://oxingtui.com/other/resource.htm#_Toc31038">电子书网站汇总</a></h5><h5 id="SOURCEFORGE"><a href="#SOURCEFORGE" class="headerlink" title="SOURCEFORGE"></a><a href="https://sourceforge.net/">SOURCEFORGE</a></h5><p>  开源软件下载</p><p><a href="https://link-springer-com-s.vpn.seu.edu.cn:8118/">Springer Link</a>：参考书籍，需要连接VPN</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>softwares</title>
    <link href="/2019/03/09/links/links_softwares/"/>
    <url>/2019/03/09/links/links_softwares/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Document</p></blockquote><h2 id="1-文档处理工具"><a href="#1-文档处理工具" class="headerlink" title="1.  文档处理工具"></a>1.  文档处理工具</h2><h5 id="SmallPDF"><a href="#SmallPDF" class="headerlink" title="SmallPDF"></a><a href="https://smallpdf.com/">SmallPDF</a></h5><p> <strong>We make PDF easy</strong></p><h5 id="ILovePDF"><a href="#ILovePDF" class="headerlink" title="ILovePDF"></a><a href="https://www.ilovepdf.com/">ILovePDF</a></h5><p>  ** Every tool you need with PDF**</p><h5 id="ILoveIMG"><a href="#ILoveIMG" class="headerlink" title="ILoveIMG"></a><a href="https://www.iloveimg.com/">ILoveIMG</a></h5><p> <strong>Every tool you need to work with images</strong></p><h5 id="Convertio"><a href="#Convertio" class="headerlink" title="Convertio"></a><a href="https://convertio.co/zh/">Convertio</a></h5><p> ** Converts for fonts, video, audio, presentation, image, ebook et al.**</p><h5 id="Squoosh"><a href="#Squoosh" class="headerlink" title="Squoosh"></a><a href="https://squoosh.app/">Squoosh</a></h5><p> <strong>Image compression web app provided by Google</strong></p><p><a href="https://lab.lyric.im/wxformat/">markdown转微信文章工具</a></p><blockquote><p>Drawing</p></blockquote><h2 id="2-画图软件"><a href="#2-画图软件" class="headerlink" title="2.  画图软件"></a>2.  画图软件</h2><h5 id="Graphviz-基于语言画结构图"><a href="#Graphviz-基于语言画结构图" class="headerlink" title="Graphviz-基于语言画结构图"></a><a href="http://www.graphviz.org/">Graphviz-基于语言画结构图</a></h5><p> 基于DOT图形描述语言的画图工具，可以帮助我们画数据结构图、模块图、流程图等。</p><ul><li><p><a href="http://guqian110.github.io/pages/2015/01/20/drawing_fsm_state_diagram_using_graphviz.html">简明教程</a></p></li><li><p><a href="https://www.cnblogs.com/onemorepoint/p/8310996.html">windows下Graphviz安装及入门教程</a></p></li><li><p><a href="https://www.ibm.com/developerworks/cn/aix/library/au-aix-graphviz/">使用 Graphviz 生成自动化系统图</a></p></li></ul><h5 id="TimeGen-画时序波形"><a href="#TimeGen-画时序波形" class="headerlink" title="TimeGen-画时序波形"></a><a href="http://xfusionsoftware.com/">TimeGen-画时序波形</a></h5><p> 画时序波形的软件，但是免费版只能同时添加5个信号，建议用Timing designer</p><h5 id="Fizzim-画状态机图"><a href="#Fizzim-画状态机图" class="headerlink" title="Fizzim-画状态机图"></a><a href="http://www.fizzim.com/">Fizzim-画状态机图</a></h5><p> 有限状态机(FSM)设计工具，开源，图形化界面，自动生成设计代码，支持Verilog，VHDL和SystemVerilog。</p><h5 id="TimingDesigner画时序波形"><a href="#TimingDesigner画时序波形" class="headerlink" title="TimingDesigner画时序波形"></a><a href="http://www.edaceo.com/forum.php?mod=viewthread&tid=179727">TimingDesigner画时序波形</a></h5><h5 id="TimingDesigner安装使用"><a href="#TimingDesigner安装使用" class="headerlink" title="TimingDesigner安装使用"></a><a href="https://blog.csdn.net/u013608300/article/details/78988523">TimingDesigner安装使用</a></h5><blockquote><p>Others</p></blockquote><h2 id="3-其他软件"><a href="#3-其他软件" class="headerlink" title="3.  其他软件"></a>3.  其他软件</h2><h5 id="user-me"><a href="#user-me" class="headerlink" title="user.me"></a><a href="https://www.uzer.me/">user.me</a></h5><p> <strong>在线应用 matlab ps office 等</strong></p><h5 id="IPIP"><a href="#IPIP" class="headerlink" title="IPIP"></a><a href="https://www.ipip.net/">IPIP</a></h5><p> <strong>Best IP database</strong></p><p><a href="http://pandownload.com/"><strong>度盘</strong></a></p><h2 id="4-有意思的generator"><a href="#4-有意思的generator" class="headerlink" title="4.有意思的generator"></a>4.有意思的generator</h2><p><a href="https://m.photofunia.com/categories/all_effects">PhotoFunia</a>：在线的图片生成工具，可以向图片中添加自己想要的文字，比如在雪地上写字，生成节日贺卡，杂志封面等。</p><p><a href="https://www.52doutu.cn/">斗图、表情包</a>：在线生成</p><p><a href="https://zzkia.noddl.me:8020/?from=www.shadiao.app">诺基亚短信生成</a></p><p><a href="https://www.nihaowua.com/">毒鸡汤、撩妹黄段</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ IO流</title>
    <link href="/2019/03/09/C++/IO/IO%E6%B5%81/"/>
    <url>/2019/03/09/C++/IO/IO%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<hr><h4 id="写在开头："><a href="#写在开头：" class="headerlink" title="写在开头："></a>写在开头：</h4><p>  本文是对公众号<a href="https://mp.weixin.qq.com/s/XjFIooBa9RMGt8qFw8gZqw">C&#x2F;C++编程实验室</a>中第一二章内容学习的总结.</p><hr><h3 id="主要内容："><a href="#主要内容：" class="headerlink" title="主要内容："></a>主要内容：</h3><ol><li><h5 id="自定义输出流对象输出到控制台"><a href="#自定义输出流对象输出到控制台" class="headerlink" title="自定义输出流对象输出到控制台"></a>自定义输出流对象输出到控制台</h5></li><li><h5 id="自定义输出流对象输出到文件"><a href="#自定义输出流对象输出到文件" class="headerlink" title="自定义输出流对象输出到文件"></a>自定义输出流对象输出到文件</h5></li><li><h5 id="标准IO流对象-iostream-输出到控制台"><a href="#标准IO流对象-iostream-输出到控制台" class="headerlink" title="标准IO流对象(iostream)输出到控制台"></a>标准IO流对象(iostream)输出到控制台</h5></li><li><h5 id="打印自定义类型"><a href="#打印自定义类型" class="headerlink" title="打印自定义类型"></a>打印自定义类型</h5></li><li><h5 id="fstream对文件进行读写"><a href="#fstream对文件进行读写" class="headerlink" title="fstream对文件进行读写"></a>fstream对文件进行读写</h5></li></ol><hr><ul><li><h4 id="自定义输出流对象输出到控制台-1"><a href="#自定义输出流对象输出到控制台-1" class="headerlink" title="自定义输出流对象输出到控制台"></a>自定义输出流对象输出到控制台</h4><h6 id="先要有一个My-String类"><a href="#先要有一个My-String类" class="headerlink" title="先要有一个My_String类"></a>先要有一个My_String类</h6>通过自定义流对象，将My_String的对象输出到控制台</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">My_String</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">My_String</span>();<br><span class="hljs-built_in">My_String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str);<br><span class="hljs-built_in">My_String</span>(<span class="hljs-type">const</span> My_String&amp;);<br>~<span class="hljs-built_in">My_String</span>();<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> m_len;<br>&#125;<br>My_String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> My_String&amp;);<br>My_String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*);<br><span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i);<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span>;<br><span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-built_in">operator</span>&lt;(<span class="hljs-type">const</span> My_String&amp; str1, <span class="hljs-type">const</span> My_String&amp; str2);<br><span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> My_String&amp; str1, <span class="hljs-type">const</span> My_String&amp; str2);<br><span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> My_String&amp; str1, <span class="hljs-type">const</span> My_String&amp; str2);<br><span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="hljs-type">const</span> My_String &amp;str);<br><span class="hljs-keyword">friend</span> istream&amp; <span class="hljs-keyword">operator</span> &gt;&gt; (istream &amp;is, My_String &amp;str);<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span> <span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">strlen</span>(m_str); &#125;   <span class="hljs-comment">//const成员函数，不会改变对象</span><br><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">c_str</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_str; &#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">char</span>* m_str;<br><span class="hljs-type">int</span> m_len;<br>&#125;;<br></code></pre></td></tr></table></figure><h6 id="定义输出流对象的基类MyStrIobase。"><a href="#定义输出流对象的基类MyStrIobase。" class="headerlink" title="定义输出流对象的基类MyStrIobase。"></a>定义输出流对象的基类MyStrIobase。</h6><p>  基类中的虚函数send用来在不同的子类中被继承，以实现多种功能（输出到控制台，或者输出到文件中），体现C++多态思想。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStrIobase</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">MyStrIobase</span>() &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* ptr, <span class="hljs-type">int</span> n)</span> </span>&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h6 id="定义输出流对象类OStream，并继承基类"><a href="#定义输出流对象类OStream，并继承基类" class="headerlink" title="定义输出流对象类OStream，并继承基类"></a>定义输出流对象类OStream，并继承基类</h6><p>  OStream能将My_String打印到控制台</p><p>  在OStream重载send函数，将字符数组打印到控制台</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OStream</span> :<span class="hljs-keyword">public</span> MyStrIobase&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* ptr, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    <span class="hljs-comment">/*ptr要打印的字符数组，n字符长度*/</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br><span class="hljs-built_in">putc</span>(*ptr++, stdout);<br><span class="hljs-built_in">putc</span>(<span class="hljs-string">&#x27;\n&#x27;</span>, stdout);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h6 id="重载-lt-lt-运算符"><a href="#重载-lt-lt-运算符" class="headerlink" title="重载&lt;&lt;运算符"></a>重载&lt;&lt;运算符</h6><p>  可以用模板函数</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt; <span class="hljs-symbol">T</span>&amp; <span class="hljs-symbol">operator</span>&lt;&lt;(<span class="hljs-symbol">T</span>&amp; <span class="hljs-symbol">io, <span class="hljs-symbol">const</span></span> <span class="hljs-symbol">My_String</span>&amp; <span class="hljs-symbol">str</span>)<br>&#123;<br>sendstr(io, str.c_str(), str.size());<br><span class="hljs-keyword">return</span> io;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以专门为OStream重载一个&lt;&lt;</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs axapta">OStream&amp; operator &lt;&lt;(OStream&amp; io, <span class="hljs-keyword">const</span> My_String&amp; <span class="hljs-built_in">str</span>)<br>&#123;<br>sendstr(io, <span class="hljs-built_in">str</span>.c_str(), <span class="hljs-built_in">str</span>.size());<br><span class="hljs-keyword">return</span> io;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="需要定义sendstr函数"><a href="#需要定义sendstr函数" class="headerlink" title="需要定义sendstr函数"></a>需要定义sendstr函数</h6><p>  这里参数是基类MyStrIobase，便于实现更多的功能，比如输出到文件的类，只需要继承基类MyStrIobase 就可以使用sendstr函数，不需要重新定义。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-type">void</span> sendstr(<span class="hljs-type">MyStrIobase</span>&amp; strio, <span class="hljs-keyword">const</span> <span class="hljs-type">char</span>* <span class="hljs-keyword">ptr</span>, <span class="hljs-type">int</span> n)<br>&#123;<br>strio.send(<span class="hljs-keyword">ptr</span>, n);<br>&#125;<br></code></pre></td></tr></table></figure><hr><ul><li><h4 id="自定义输出流对象输出到文件-1"><a href="#自定义输出流对象输出到文件-1" class="headerlink" title="自定义输出流对象输出到文件"></a>自定义输出流对象输出到文件</h4><h5 id="定义输出到文件的流对象类————FileOStream"><a href="#定义输出到文件的流对象类————FileOStream" class="headerlink" title="定义输出到文件的流对象类————FileOStream"></a>定义输出到文件的流对象类————FileOStream</h5><p>FileOStream也集成基类MyStrIobase，用来重载send函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileOStream</span> :<span class="hljs-keyword">public</span> MyStrIobase &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">FileOStream</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* filename, <span class="hljs-type">char</span>* mode)<br>&#123;<br>m_File = <span class="hljs-built_in">fopen</span>(filename, mode);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str, <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (m_File == <span class="hljs-literal">nullptr</span> || len &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i)<br><span class="hljs-built_in">putc</span>(*str++, m_File);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">fclose</span>(m_File);<br>m_File = <span class="hljs-literal">nullptr</span>;<br>&#125;<br>       <span class="hljs-keyword">private</span>:<br>FILE* m_File&#123; <span class="hljs-literal">nullptr</span> &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在FileOStream 构造函数中打开文件。</p></li><li><h4 id="标准IO流对象-iostream-输出到控制台-1"><a href="#标准IO流对象-iostream-输出到控制台-1" class="headerlink" title="标准IO流对象(iostream)输出到控制台"></a>标准IO流对象(iostream)输出到控制台</h4><p>标准ostream对象也可以输出My_String对象,重载sendstr，是sendstr而不是send，因为ostream不能去继承自定义的类型MyStrIobase</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-type">void</span> sendstr(ostream&amp; os, <span class="hljs-keyword">const</span> <span class="hljs-type">char</span>* <span class="hljs-keyword">ptr</span>, <span class="hljs-type">int</span> n)<br>&#123;<br>os.write(<span class="hljs-keyword">ptr</span>, n);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><h4 id="ostream-打印自定义类型-MInt"><a href="#ostream-打印自定义类型-MInt" class="headerlink" title="ostream 打印自定义类型 MInt"></a>ostream 打印自定义类型 MInt</h4><p> 需要重载&lt;&lt; ,&gt;&gt;运算符</p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/*打印自定义类型  MInt*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MInt</span> </span>&#123;<br><span class="hljs-keyword">public</span>:<br>MInt(int <span class="hljs-keyword">val</span>) :mVal(<span class="hljs-keyword">val</span>) &#123;&#125;<br>MInt(<span class="hljs-keyword">const</span> MInt&amp; other) :mVal(other.mVal) &#123;&#125;<br>friend ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="hljs-keyword">const</span> MInt&amp; other);<br>friend istream&amp; <span class="hljs-keyword">operator</span> &gt;&gt; (istream&amp; <span class="hljs-keyword">is</span>, MInt&amp; <span class="hljs-keyword">out</span>);<br><span class="hljs-keyword">private</span>:<br>int mVal;<br>&#125;;<br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="hljs-keyword">const</span> MInt&amp; other) &#123;<br>os &lt;&lt; other.mVal;<br><span class="hljs-keyword">return</span> os;<br>&#125;<br>istream&amp; <span class="hljs-keyword">operator</span> &gt;&gt; (istream&amp; <span class="hljs-keyword">is</span>, MInt&amp; <span class="hljs-keyword">out</span>) &#123;<br><span class="hljs-keyword">is</span> &gt;&gt; <span class="hljs-keyword">out</span>.mVal;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">is</span>;<br>&#125;<br>````<br>---<br>- #### fstream对文件进行读写<br></code></pre></td></tr></table></figure><p>&#x2F;* 用标准库fstream来对文件进行读写*&#x2F;<br>  void writetofile1()<br>  {<br>  &#x2F;<em>构造函数中打开文件</em>&#x2F;<br>  &#x2F;<em>fstream对象的输入输出模式out in ,可以参考CPlusPlus网站</em>&#x2F;<br>  ofstream outFile(“2.txt”, std::ios::out);<br>  &#x2F;<em>因为fostream类中重载了&lt;&lt; &gt;&gt;，这里直接用</em>&#x2F;<br>  outFile &lt;&lt; “this is test writetofile1 pro!” &lt;&lt; endl;<br>  outFile.close();<br>  }<br>  void writetofile2()<br>  {<br>  ofstream outFile;<br>  &#x2F;<em>open函数打开文件</em>&#x2F;<br>  outFile.open(“3.txt”, std::ios::out);<br>  outFile &lt;&lt; “this is test writetofile2 pro!” &lt;&lt; endl;<br>  outFile.close();<br>  }<br>  void writefromfile1()<br>  {<br>  &#x2F;<em>先将内容写进文件</em>&#x2F;<br>  ofstream outFile;<br>  outFile.open(“4.txt”, std::ios::out);<br>  outFile &lt;&lt; “this is test writefromfile1 pro!” &lt;&lt; endl;<br>  outFile.close();<br>  ifstream inFile(“4.txt”, std::ios::in);<br>  &#x2F;<em>也可以用open函数打开</em>&#x2F;<br>  string str;<br>  &#x2F;<em>std::getline读一行内容，注意是std命名空间中的getline，fstream泪也有一个getline函数，<br>  但用法不一样，std::getline 原型istream&amp; getline (istream&amp;  is, string&amp; str);<br>  istream.getline()原型 istream&amp; getline (char</em> s, streamsize n );*&#x2F;<br>  std::getline(inFile, str);<br>  cout &lt;&lt; str &lt;&lt; endl;<br>  inFile.close();<br>  }</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-bullet">-</span> <span class="hljs-comment">#### 测试以上案例</span><br></code></pre></td></tr></table></figure><p>void test1()<br>{<br>  static My_String str(“this is a test!”);<br>  OStream Out;<br>  Out &lt;&lt; str;<br>  &#x2F;*测试iostream输出My_String*&#x2F;<br>  cout &lt;&lt; str &lt;&lt; endl;;<br>  &#x2F;*测试输出到文件*&#x2F;<br>  FileOStream Fout(“1.txt”,”w+”);<br>  Fout &lt;&lt; str;<br>  Fout.close();<br>  &#x2F;*测试打印自定义类型MInt*&#x2F;<br>  MInt m(0);<br>  cout &lt;&lt; m &lt;&lt; endl;<br>  cout &lt;&lt; “enter a integer :” &lt;&lt; endl;<br>  cin &gt;&gt; m;<br>  cout &lt;&lt; m &lt;&lt; endl;<br>  writetofile1();<br>  writetofile2();<br>  writefromfile1();<br>}</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean">- #### [源代码](https:<span class="hljs-comment">//github.com/east1203/CPlusPlus.git)</span><br> io流 和 mycase文件<br>- #### 问题<br>模板函数如果定义在cases.h文件中出错，最后把它定义在main函数所在的文件中<br></code></pre></td></tr></table></figure><p>&#x2F;<em>如果定义在cases.h中出错，识别不了My_String 类型</em>&#x2F;<br>template<class T> T&amp; operator&lt;&lt;(T&amp; io, const My_String&amp; str)<br>{<br>  sendstr(io, str.c_str(), str.size());<br>  return io;<br>}<br>&#96;&#96;&#96;</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迭代器小结</title>
    <link href="/2019/03/09/C++/%E5%AE%B9%E5%99%A8/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <url>/2019/03/09/C++/%E5%AE%B9%E5%99%A8/%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="每次修改容器的时候，可能会改变容器本身，需要重新获取迭代器"><a href="#每次修改容器的时候，可能会改变容器本身，需要重新获取迭代器" class="headerlink" title="每次修改容器的时候，可能会改变容器本身，需要重新获取迭代器"></a>每次修改容器的时候，可能会改变容器本身，需要重新获取迭代器</h4><figure class="highlight asciidoc"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs asciidoc">vector&lt;int&gt;::iterator p=a.begin();<br>a.insert(p+1,1);<br>p = a.begin();<br>……<br>p = a.begin();<br>a.erase(p,p+5);<br><span class="hljs-section">p = a.begin();</span><br><span class="hljs-section">-------------------------------</span><br></code></pre></td></tr></table></figure><p>在这里，p应该就是指向第一个元素的迭代器，但为什么我们还要重置呢？<strong>当我们插入或者是删除元素时，是有可能改变容器本身的，就比如，他可能会迁移到其他地方，就算不迁移到其他地方，不管是插入元素或者是删除元素，也足以令一部分迭代器失效</strong>，所以，如果我们不重置p的话，我们接下来使用的会是无效的迭代器，这足以令程序宕掉，所以，为了安全起见，无论我们是插入元素还是删除元素，当我们要用迭代器时，就记得重迭代器</p></li><li><h4 id="定义了迭代器，但没有将迭代器绑定到对象上，不能使用该迭代器"><a href="#定义了迭代器，但没有将迭代器绑定到对象上，不能使用该迭代器" class="headerlink" title="定义了迭代器，但没有将迭代器绑定到对象上，不能使用该迭代器"></a>定义了迭代器，但没有将迭代器绑定到对象上，不能使用该迭代器</h4></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数返回局部对象引用</title>
    <link href="/2019/03/09/C++/%E6%8A%A5%E9%94%99%E5%88%86%E6%9E%90/%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E6%88%96%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8/"/>
    <url>/2019/03/09/C++/%E6%8A%A5%E9%94%99%E5%88%86%E6%9E%90/%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E6%88%96%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题 :"></a>问题 :</h3><p>昨天再写C++的时候碰到 ：</p><blockquote><p><strong>未处理的异常: 0xC0000005: 读取位置 0xCCCCCCCCC 时发生访问冲突</strong></p></blockquote><p>昨天晚上搞到一点多都没明白是怎么回事，上网查说<a href="https://typecodes.com/cseries/pointermemaccess0xC0000005.html">指针访问内存时，访问了超过指针所管理的内<br>存区域</a>.</p><p>今天再写其他函数的时候有调用了昨天的那个命名空间，这次提示<a href="https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warning-level-1-c4172?view=vs-2017">errorC4172，返回局部变量或<br>临时变量的引用</a>.</p><h3 id="分析-："><a href="#分析-：" class="headerlink" title="分析 ："></a>分析 ：</h3><p>突然发现昨天写的程序是：<br>  <figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml">SpreadSheetCell&amp; SpreadSheet::<span class="hljs-constructor">GetCelld(<span class="hljs-params">int</span> <span class="hljs-params">x</span>, <span class="hljs-params">int</span> <span class="hljs-params">y</span>)</span><br>&#123;<br>return  m_Data-&gt;<span class="hljs-constructor">GetCell(<span class="hljs-params">x</span>, <span class="hljs-params">y</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h5 id="返回的是-SpreadSheetCell类型的引用-—————SpreadSheetCell-amp"><a href="#返回的是-SpreadSheetCell类型的引用-—————SpreadSheetCell-amp" class="headerlink" title="返回的是    SpreadSheetCell类型的引用 —————SpreadSheetCell&amp;"></a>返回的是    <em><strong>SpreadSheetCell类型的引用</strong></em> —————<em><strong>SpreadSheetCell&amp;</strong></em></h5><p>确实是返回了局部对象的引用——返回局部对象本身。局部对象再函数返回之前会被释放掉，返回出错。</p><h3 id="修改："><a href="#修改：" class="headerlink" title="修改："></a>修改：</h3><h5 id="改成返回类型本身-————SpreadSheetCell"><a href="#改成返回类型本身-————SpreadSheetCell" class="headerlink" title="改成返回类型本身 ————SpreadSheetCell"></a>改成返回类型本身 ————SpreadSheetCell</h5>  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">SpreadSheetCell SpreadSheet::<span class="hljs-constructor">GetCelld(<span class="hljs-params">int</span> <span class="hljs-params">x</span>, <span class="hljs-params">int</span> <span class="hljs-params">y</span>)</span><br>&#123;<br>return  m_Data-&gt;<span class="hljs-constructor">GetCell(<span class="hljs-params">x</span>, <span class="hljs-params">y</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>  程序运行正常。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol><li>不能返回局部对象或临时对象</li><li>也不能返回局部对象的指针</li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中的继承小结(1)</title>
    <link href="/2019/03/09/C++/%E7%B1%BB/C++%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%E5%B0%8F%E7%BB%93(1)/"/>
    <url>/2019/03/09/C++/%E7%B1%BB/C++%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%E5%B0%8F%E7%BB%93(1)/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>C++中继承的方式有三种public,private,protected。子类根据继承方式继承父类的成员函数和数据成员。</p></li><li><h4 id="书写格式"><a href="#书写格式" class="headerlink" title="书写格式"></a>书写格式</h4><figure class="highlight crystal"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-class"><span class="hljs-keyword">class</span> &lt;新建子类名&gt;: <span class="hljs-title">public</span> &lt;父类名&gt;&#123;&#125;；</span><br></code></pre></td></tr></table></figure></li><li><h4 id="调用构造函数、析构函数顺序"><a href="#调用构造函数、析构函数顺序" class="headerlink" title="调用构造函数、析构函数顺序"></a>调用构造函数、析构函数顺序</h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Member</span> &#123;<br><span class="hljs-keyword">public</span>:<br>Member() &#123; cout &lt;&lt; <span class="hljs-string">&quot;create Member&quot;</span> &lt;&lt; endl; &#125;<br>~Member() &#123; cout &lt;&lt; <span class="hljs-string">&quot;delete Member&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>Base() &#123; cout &lt;&lt; <span class="hljs-string">&quot;create Base &quot;</span> &lt;&lt; endl; &#125;<br>~Base() &#123; cout &lt;&lt; <span class="hljs-string">&quot;delete Base &quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sub</span> :<span class="hljs-keyword">public</span> Base&#123;<br><span class="hljs-keyword">public</span>:<br>Sub() &#123; cout &lt;&lt; <span class="hljs-string">&quot;create Sub &quot;</span> &lt;&lt; endl; &#125;<br>~Sub() &#123; cout &lt;&lt; <span class="hljs-string">&quot;delete Sub&quot;</span> &lt;&lt; endl; &#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">//Member m;</span><br><span class="hljs-keyword">protected</span>:<br>Member m;<br>&#125;;<br><br><span class="hljs-built_in">int</span> main(<span class="hljs-keyword">void</span>)<br>&#123;<br>Sub* a = <span class="hljs-keyword">new</span> Sub();<br>delete a;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> Base<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">Member</span><br><span class="hljs-keyword">create</span> Sub<br><span class="hljs-keyword">delete</span> Sub<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">Member</span><br><span class="hljs-keyword">delete</span> Base<br></code></pre></td></tr></table></figure><p>先调用父类构造函数，然后生成数据成员调用成员的构造函数，最后调用子类的构造函数，析构函数顺序相反。</p></li><li><h4 id="把基类的析构函数写成虚函数virtual"><a href="#把基类的析构函数写成虚函数virtual" class="headerlink" title="把基类的析构函数写成虚函数virtual"></a>把基类的析构函数写成虚函数virtual</h4><p>上面定义基类Base时，析构函数不是虚函数。如果把main函数写成如下，左边对基类赋值。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>Base* a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Sub</span>();<br><span class="hljs-keyword">delete</span> a;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>  执行结果：<br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> Base<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">Member</span><br><span class="hljs-keyword">create</span> Sub<br><span class="hljs-keyword">delete</span> Base<br></code></pre></td></tr></table></figure></p><p>  只释放了基类，没有对所有的资源回收。</p><p>  把基类的析构函数写成：<br>  <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">  class <span class="hljs-keyword">Base </span>&#123;<br><span class="hljs-symbol">  public:</span><br><span class="hljs-keyword">Base() </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;create Base &quot;</span> &lt;&lt; endl<span class="hljs-comment">; &#125;</span><br>virtual ~<span class="hljs-keyword">Base() </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;delete Base &quot;</span> &lt;&lt; endl<span class="hljs-comment">; &#125;</span><br>&#125;;<br></code></pre></td></tr></table></figure><br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> Base<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">Member</span><br><span class="hljs-keyword">create</span> Sub<br><span class="hljs-keyword">delete</span> Sub<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">Member</span><br><span class="hljs-keyword">delete</span> Base<br></code></pre></td></tr></table></figure></p><p>  <strong>所以基类的析构函数写成虚函数</strong></p><ul><li><h4 id="子类给父类赋值"><a href="#子类给父类赋值" class="headerlink" title="子类给父类赋值"></a>子类给父类赋值</h4><ol><li>子类赋值给父类引用</li><li>子类赋值给父类指针</li><li>子类直接赋值给父类</li></ol><p>前两种调用子类成员，第三种调用父类成员。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"> <span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;<br> <span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span>()</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;this is Base !&quot;</span> &lt;&lt; endl;<br>&#125;<br> &#125;;<br> <span class="hljs-keyword">class</span> <span class="hljs-title">Sub</span> :<span class="hljs-title">public</span> <span class="hljs-title">Base</span>&#123;<br> <span class="hljs-keyword">public</span>:<br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span>()</span><br> &#123;<br> cout &lt;&lt; <span class="hljs-string">&quot;this is Sub !&quot;</span> &lt;&lt; endl;<br> &#125;<br> &#125;;<br><br> <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)</span><br> &#123;<br> Sub s = Sub();<br> Base&amp; a = s;<br> Base* b = &amp;s;<br> Base c = s;<br> a.show();<br> b-&gt;show();<br> c.show();<br> system(<span class="hljs-string">&quot;pause&quot;</span>);<br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> Sub !<br><br><span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> Sub !<br><br><span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> Base !<br><br></code></pre></td></tr></table></figure></li><li><h4 id="纯虚函数-、-抽象类"><a href="#纯虚函数-、-抽象类" class="headerlink" title="纯虚函数 、 抽象类"></a>纯虚函数 、 抽象类</h4></li><li><h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><p><code>class &lt;新建子类名&gt;: public &lt;父类名1&gt;，public &lt;父类名2&gt;，...&#123;&#125;；</code></p><p>如果子类调用父类中的重名函数：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">Sub<span class="hljs-selector-class">.Base1</span>::<span class="hljs-built_in">show</span>();<br>Sub<span class="hljs-selector-class">.Base2</span>::<span class="hljs-built_in">show</span>()<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HLS高层次综合</title>
    <link href="/2019/03/09/IC/Synthesis/HLS%E9%AB%98%E5%B1%82%E6%AC%A1%E7%BB%BC%E5%90%88/"/>
    <url>/2019/03/09/IC/Synthesis/HLS%E9%AB%98%E5%B1%82%E6%AC%A1%E7%BB%BC%E5%90%88/</url>
    
    <content type="html"><![CDATA[<ul><li><h3 id="一、-背景"><a href="#一、-背景" class="headerlink" title="一、 背景"></a>一、 背景</h3><h4 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h4><p>  HLS就是把采用高级语言(C&#x2F;C++&#x2F;System C等)描述的数字系统映射成RTL结构，并且满足约束和目标。</p><h4 id="HLS优点："><a href="#HLS优点：" class="headerlink" title="HLS优点："></a>HLS优点：</h4><ol><li>从算法层的功能描述成RTL容易出错，耗费大量时间，</li><li>RTL仿真速度慢</li><li>HLS有利于IP复用</li><li>项目进度快，可以选择最适合的架构</li></ol></li><li><h3 id="二、-C-到HDL的映射"><a href="#二、-C-到HDL的映射" class="headerlink" title="二、 C++到HDL的映射"></a>二、 C++到HDL的映射</h3><h4 id="结构："><a href="#结构：" class="headerlink" title="结构："></a>结构：</h4><ol><li>C++是函数组成，HDL是module，将C++单线程映射成HDL多线程</li><li>C++中函数调用通过函数名相关联，函数之间的传值是通过端口变量实现的。相应<br>地，HDL中地模块调用也通过模块名相关联，模块之间的联系同样通过端口之问的连接实现，所不同的是，它反映的是硬件之间的实际物理连接。C／C++函数调用是唯一的，每一个都是相同的，可以无限制调用；而HDL对模块的调用都必须赋予一个不同的别名，调用次数受硬件电路资源的限制。</li><li>C++中从main函数开始执行，在HDL中每个module是等价的，其必定存在一个顶层模块testbench。main函数相当于testbench</li><li>C++中没有时钟异步、同步，也没有延迟</li></ol><h4 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h4><ol><li>C++和HDL中基本类型的对应</li><li>数组</li><li>指针：</li></ol><p>  HDL中不存在地址的概念，所以C中的指针没法映射到HDL<br>4. 类&#x2F;结构体：</p><p>  类&#x2F;结构体可以映射成HDL。联合体（union）不知其真实大小，不能映射</p><h4 id="设计接口："><a href="#设计接口：" class="headerlink" title="设计接口："></a>设计接口：</h4><ol><li>输入：</li></ol><p>  入端口将数据从外界传入设计模块进行处理。C／C++参数列表里非指针的参数和在函数中只被读的指针参数对应于HDL中的输入端口。<br>![](<a href="https://cl.ly/3caa51bae366/Image">https://cl.ly/3caa51bae366/Image</a> 2019-03-09 at 4.03.35 PM)<br>这个是MD<br><img src="https://i.imgur.com/ckfhs2Q.png"><br>整型a是输入，指针p是输出<br>2. 输出:</p><p>  输出端口将处理后的数据从设计模块传递给外界。函数的返回值和参数列表里在函数中只被写的指针、数组参数对应于HDL中的输出端口。<br>3. 双向<br>    向端口既可以从外界接收数据也可以将处理的数据传递给外界。C／CH参数列表里<br>    的指针或数组在函数中若既被读又被写则对应于HDL中的双向端口．<br>    <img src="https://i.imgur.com/GIRIhw3.png"></p><p>  除以上所述之外，HDL描述端口还包括时钟、复位、使能等专用端口。</p><p>  ◆时钟：给出硬件设计的工作频率，并确定同步情况下的有效时钟沿。</p><p>  ◆复位：给整个设计提供复位操作，并确定是同步复位或异步复位。</p><p>  ◆使能：为硬件模块提供使能信号，并确定有效时钟沿。</p><p>  ◆握手协议：一般包括开始和完成反馈信号，开始有效时输入数据被读入，完成有效时表示输出数据已准备好。</p></li><li><h3 id="三、-可综合C"><a href="#三、-可综合C" class="headerlink" title="三、 可综合C++"></a>三、 可综合C++</h3><h4 id="层次化设计"><a href="#层次化设计" class="headerlink" title="层次化设计"></a>层次化设计</h4><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><h4 id="静态对象"><a href="#静态对象" class="headerlink" title="静态对象"></a>静态对象</h4></li><li><h3 id="四、-IP重用"><a href="#四、-IP重用" class="headerlink" title="四、 IP重用"></a>四、 IP重用</h3><ul><li>可以根据不同的需要、应用场景，修改约束条件，将C++映射成不同的RTL</li><li>C++等高级语言实现的IP与工艺无关，能够映射成不同FPGA厂家、型号和foundry工艺</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
      <category>Synthesis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC</tag>
      
      <tag>Synthesis</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
